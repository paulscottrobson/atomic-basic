
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -q --m65xx -L asm.out/basic.lst -l asm.out/basic.lbl -o asm.out/basic.prg basic.asm
; Thu Dec 10 17:04:59 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: boot/x16/01constants.inc

=8							DataStackSize = 8
=16							HashTableSize = 16
=$00							ZeroPageStart = $00
=$20							DataStackStart = $20
=$800							DataStart = $800					; must be on a page boundary.
=$1000							CodeBase = $1000
=$9e00							EndMemory = $9E00

;******  Return to file: basic.asm


;******  Processing file: boot/common/02data.inc

>0000					codePtr:.fill 		3 						; code ptr - extra byte for paging.
>0003					tempShort:.fill 	1 						; used for v.short term saving.
>0004					temp0:	.fill 		2
>0006					temp1:	.fill 		2
>0008					temp2:	.fill 		2
>000a					temp3:	.fill 		2
>000c					temp4:	.fill 		2
>000e					StackPtr:.fill 		2						; highest byte allocated, stack works down.
>0010					LowMemory:.fill 	2 						; next byte available working up
>0020					esType:	.fill 		DataStackSize 			; bit 7 any reference, bit 6 byte reference, bit 0 string.
>0028					esInt0:	.fill 		DataStackSize		 	; 32 bit integer, also used for string address
>0030					esInt1:	.fill 		DataStackSize			; (16 bit only)
>0038					esInt2:	.fill 		DataStackSize
>0040					esInt3:	.fill 		DataStackSize
=$28					esStrLow = esInt0 							; String address synonym
=$30					esStrHigh = esInt1
>0800							.align 	256  						; these two must be on one page.
.0800					RootVariables:
>0800							.fill 	26*4 						; variables A-Z which are fixed.
.0868					HashTable:
>0868							.fill 	HashTableSize*2 			; variable hash table.
.0888					Seed32:
>0888							.fill 	4 							; random number
.088c					Buffer:
>088c							.fill 	20
.08a0					ClockTicks:
>08a0							.fill 	4
.08a4					IToSCount:
>08a4							.fill 	1
.08a5					ChrBuffer:
>08a5							.fill 	2
.08a7					PrintCRFlag:
>08a7							.fill 	1

;******  Return to file: basic.asm


;******  Processing file: boot/common/03stdmac.inc


;******  Return to file: basic.asm


;******  Processing file: boot/common/boot.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; initialise 6502 stac
.1002	9a		txs				txs
.1003	4c 64 10	jmp $1064			jmp 	ColdStart

;******  Return to file: basic.asm


;******  Processing file: extern/x16/x16hardware.asm

.1006					XTGetKey:
.1006	8a		txa				txa
.1007	48		pha				pha
.1008	98		tya				tya
.1009	48		pha				pha
.100a	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.100d	85 03		sta $03				sta 	tempShort
.100f	68		pla				pla
.1010	a8		tay				tay
.1011	68		pla				pla
.1012	aa		tax				tax
.1013	a5 03		lda $03				lda 	tempShort
.1015	60		rts				rts
.1016					XTUpdateClock:
.1016	48		pha				pha
.1017	8a		txa				txa
.1018	48		pha				pha
.1019	98		tya				tya
.101a	48		pha				pha
.101b	20 de ff	jsr $ffde			jsr 	$FFDE
.101e	8c a2 08	sty $08a2			sty 	ClockTicks+2
.1021	8e a1 08	stx $08a1			stx 	ClockTicks+1
.1024	8d a0 08	sta $08a0			sta 	ClockTicks
.1027	a9 00		lda #$00			lda 	#0
.1029	8d a3 08	sta $08a3			sta 	ClockTicks+3
.102c	68		pla				pla
.102d	a8		tay				tay
.102e	68		pla				pla
.102f	aa		tax				tax
.1030	68		pla				pla
.1031	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: extern/x16/x16print.asm

.1032					XTPrintAC:
.1032	c9 61		cmp #$61			cmp 	#"a"
.1034	90 1c		bcc $1052			bcc 	XTPrintA
.1036	c9 7b		cmp #$7b			cmp 	#"z"+1
.1038	b0 18		bcs $1052			bcs 	XTPrintA
.103a	48		pha				pha
.103b	49 20		eor #$20			eor 	#$20
.103d	20 52 10	jsr $1052			jsr 	XTPrintA
.1040	68		pla				pla
.1041	60		rts				rts
.1042					XTPrintCR:
.1042	48		pha				pha
.1043	a9 0d		lda #$0d			lda 	#13
.1045	20 52 10	jsr $1052			jsr 	XTPrintA
.1048	68		pla				pla
.1049	60		rts				rts
.104a					XTPrintTab:
.104a	48		pha				pha
.104b	a9 20		lda #$20			lda 	#32
.104d	20 52 10	jsr $1052			jsr 	XTPrintA
.1050	68		pla				pla
.1051	60		rts				rts
.1052					XTPrintA:
.1052	85 03		sta $03				sta 	tempShort
.1054	48		pha				pha
.1055	8a		txa				txa
.1056	48		pha				pha
.1057	98		tya				tya
.1058	48		pha				pha
.1059	a5 03		lda $03				lda 	tempShort
.105b	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.105e	68		pla				pla
.105f	a8		tay				tay
.1060	68		pla				pla
.1061	aa		tax				tax
.1062	68		pla				pla
.1063	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: interface/none/ifdummy.asm

.1064					ColdStart:
.1064	4c 6b 13	jmp $136b			jmp 	Command_RUN
.1067					WarmStart:
.1067	4c 67 10	jmp $1067			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: common/generated/keywords.inc

=$80					KWD_LESSLESSENDGREATERGREATER        = $80 ; 128
=$81					KWD_AND                              = $81 ; 129
=$82					KWD_OR                               = $82 ; 130
=$83					KWD_XOR                              = $83 ; 131
=$84					KWD_GREATER                          = $84 ; 132
=$85					KWD_LESS                             = $85 ; 133
=$86					KWD_GREATEREQUAL                     = $86 ; 134
=$87					KWD_LESSEQUAL                        = $87 ; 135
=$88					KWD_LESSGREATER                      = $88 ; 136
=$89					KWD_EQUAL                            = $89 ; 137
=$8a					KWD_PLUS                             = $8a ; 138
=$8b					KWD_MINUS                            = $8b ; 139
=$8c					KWD_ASTERISK                         = $8c ; 140
=$8d					KWD_SLASH                            = $8d ; 141
=$8e					KWD_PERCENT                          = $8e ; 142
=$8f					KWD_GREATERGREATER                   = $8f ; 143
=$90					KWD_LESSLESS                         = $90 ; 144
=$91					KWD_PLING                            = $91 ; 145
=$92					KWD_QUESTION                         = $92 ; 146
=$93					KWD_DOLLAR                           = $93 ; 147
=$94					KWD_TILDE                            = $94 ; 148
=$95					KWD_LPAREN                           = $95 ; 149
=$96					KWD_AMPERSAND                        = $96 ; 150
=$97					KWD_AT                               = $97 ; 151
=$98					KWD_LEN                              = $98 ; 152
=$99					KWD_SGN                              = $99 ; 153
=$9a					KWD_ABS                              = $9a ; 154
=$9b					KWD_RANDOM                           = $9b ; 155
=$9c					KWD_PAGE                             = $9c ; 156
=$9d					KWD_TRUE                             = $9d ; 157
=$9e					KWD_FALSE                            = $9e ; 158
=$9f					KWD_MIN                              = $9f ; 159
=$a0					KWD_MAX                              = $a0 ; 160
=$a1					KWD_SYS                              = $a1 ; 161
=$a2					KWD_CODE                             = $a2 ; 162
=$a3					KWD_TIMER                            = $a3 ; 163
=$a4					KWD_EVENT                            = $a4 ; 164
=$a5					KWD_GET                              = $a5 ; 165
=$a6					KWD_JOYPERIODX                       = $a6 ; 166
=$a7					KWD_JOYPERIODY                       = $a7 ; 167
=$a8					KWD_JOYPERIODBTN                     = $a8 ; 168
=$a9					KWD_INKEY                            = $a9 ; 169
=$aa					KWD_ALLOC                            = $aa ; 170
=$ab					KWD_CHR                              = $ab ; 171
=$ac					KWD_COMMA                            = $ac ; 172
=$ad					KWD_SEMICOLON                        = $ad ; 173
=$ae					KWD_RPAREN                           = $ae ; 174
=$af					KWD_PLUSPLUS                         = $af ; 175
=$b0					KWD_MINUSMINUS                       = $b0 ; 176
=$b1					KWD_LSQPAREN                         = $b1 ; 177
=$b2					KWD_RSQPAREN                         = $b2 ; 178
=$b3					KWD_IF                               = $b3 ; 179
=$b4					KWD_FOR                              = $b4 ; 180
=$b5					KWD_REPEAT                           = $b5 ; 181
=$b6					KWD_PROC                             = $b6 ; 182
=$b7					KWD_WHILE                            = $b7 ; 183
=$b8					KWD_ENDIF                            = $b8 ; 184
=$b9					KWD_NEXT                             = $b9 ; 185
=$ba					KWD_UNTIL                            = $ba ; 186
=$bb					KWD_ENDPROC                          = $bb ; 187
=$bc					KWD_WEND                             = $bc ; 188
=$bd					KWD_REM                              = $bd ; 189
=$be					KWD_LET                              = $be ; 190
=$bf					KWD_SQUOTE                           = $bf ; 191
=$c0					KWD_COLON                            = $c0 ; 192
=$c1					KWD_THEN                             = $c1 ; 193
=$c2					KWD_ELSE                             = $c2 ; 194
=$c3					KWD_TO                               = $c3 ; 195
=$c4					KWD_STEP                             = $c4 ; 196
=$c5					KWD_VDU                              = $c5 ; 197
=$c6					KWD_PRINT                            = $c6 ; 198
=$c7					KWD_CALL                             = $c7 ; 199
=$c8					KWD_LOCAL                            = $c8 ; 200
=$c9					KWD_GOTO                             = $c9 ; 201
=$ca					KWD_GOSUB                            = $ca ; 202
=$cb					KWD_RETURN                           = $cb ; 203
=$cc					KWD_ASSERT                           = $cc ; 204
=$cd					KWD_STOP                             = $cd ; 205
=$ce					KWD_END                              = $ce ; 206
=$cf					KWD_DIM                              = $cf ; 207
=$d0					KWD_CLEAR                            = $d0 ; 208
=$d1					KWD_LOAD                             = $d1 ; 209
=$d2					KWD_SAVE                             = $d2 ; 210
=$d3					KWD_LIST                             = $d3 ; 211
=$d4					KWD_NEW                              = $d4 ; 212
=$d5					KWD_RUN                              = $d5 ; 213

;******  Return to file: basic.asm


;******  Processing file: common/math/intmacros.inc


;******  Return to file: basic.asm


;******  Processing file: common/utility/stack.inc

=$14					SMGosub = $14 								; gosub marker (4 bytes, marker + position)
=$24					SMRepeat = $24 								; repeat marker (4 bytes, marker + position)
=$34					SMWhile = $34 								; while marker (4 bytes, marker + position)
=$4b					SMFor = $4B 								; for marker (11 bytes, see for.asm)
=$54					SMProcedure = $54 							; procedure marker (4 bytes, marker + position)
=$67					SMLocal = $67 								; local marker (7 bytes, marker, address, data)
=$0f					StackSizeMask = $0F 						; converts marker to bytes required.

;******  Return to file: basic.asm


;******  Processing file: common/commands/assert.asm

.106a					Command_Assert:
.106a	20 c1 15	jsr $15c1			jsr 	EvaluateBaseDeRef			; evaluate the thing being asserted.
.106d	20 74 1d	jsr $1d74			jsr 	Int32Zero 					; check if zero
.1070	f0 01		beq $1073			beq 	_CAError
.1072	60		rts				rts
.1073					_CAError:
.1073	4c a9 18	jmp $18a9			jmp 	EHandlerAssert

;******  Return to file: basic.asm


;******  Processing file: common/commands/clear.asm

.1076					FindEnd:
.1076	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.1078	85 04		sta $04				sta 	temp0
.107a	a9 1f		lda #$1f			lda 	#(BasicProgram) >> 8
.107c	85 05		sta $05				sta 	1+(temp0)
.107e	98		tya				tya
.107f	48		pha				pha
.1080	a0 00		ldy #$00	_FELoop:ldy 	#0 							; look at offset
.1082	b1 04		lda ($04),y			lda 	(temp0),y
.1084	f0 0c		beq $1092			beq 	_FEExit 					; end if zero
.1086	18		clc				clc 								; add to position.
.1087	65 04		adc $04				adc 	temp0
.1089	85 04		sta $04				sta 	temp0
.108b	90 f3		bcc $1080			bcc 	_FELoop
.108d	e6 05		inc $05				inc 	temp0+1
.108f	4c 80 10	jmp $1080			jmp 	_FELoop
.1092					_FEExit:
.1092	68		pla				pla
.1093	a8		tay				tay
.1094	60		rts				rts
.1095					CommandClear:
.1095	8a		txa				txa
.1096	48		pha				pha
.1097	20 76 10	jsr $1076			jsr 	FindEnd 					; find end of memory
.109a	e6 04		inc $04				inc 	temp0 						; add 1, first free byte
.109c	d0 02		bne $10a0			bne 	_CCSkip
.109e	e6 05		inc $05				inc 	temp0+1
.10a0	a5 04		lda $04		_CCSkip:lda 	temp0 						; copy into low memory
.10a2	85 10		sta $10				sta 	LowMemory
.10a4	a5 05		lda $05				lda 	temp0+1
.10a6	85 11		sta $11				sta 	LowMemory+1
.10a8	a9 00		lda #$00			lda 	#(EndMemory) & $FF
.10aa	85 0e		sta $0e				sta 	StackPtr
.10ac	a9 9e		lda #$9e			lda 	#(EndMemory) >> 8
.10ae	85 0f		sta $0f				sta 	1+(StackPtr)
.10b0	a2 00		ldx #$00			ldx 	#0 							; blank hash table
.10b2	8a		txa				txa
.10b3					_CCErase:
.10b3	9d 68 08	sta $0868,x			sta 	HashTable,x
.10b6	e8		inx				inx
.10b7	e0 20		cpx #$20			cpx 	#HashTableSize*2
.10b9	d0 f8		bne $10b3			bne 	_CCErase
.10bb	68		pla				pla
.10bc	aa		tax				tax
.10bd	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/for.asm

.10be					Command_FOR:
.10be	a9 4b		lda #$4b			lda 	#SMFor 						; allocate the space.
.10c0	20 ff 1d	jsr $1dff			jsr 	StackOpen
.10c3	20 48 12	jsr $1248			jsr 	Command_LET 				; do the same as LET.
.10c6	20 cd 13	jsr $13cd			jsr 	CheckTO 					; check TO something.
.10c9	a2 01		ldx #$01			ldx 	#1 							; keep the variable address in stack 0
.10cb	20 c7 15	jsr $15c7			jsr 	EvaluateTOSDeRef			; get terminal value in stack 1
.10ce	98		tya				tya
.10cf	48		pha				pha
.10d0	a0 04		ldy #$04			ldy 	#4
.10d2	a5 28		lda $28				lda		esInt0 						; the address of the index into 4 and 5
.10d4	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10d6	c8		iny				iny
.10d7	a5 30		lda $30				lda		esInt1
.10d9	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10db	c8		iny				iny
.10dc	a9 01		lda #$01			lda 	#1  						; the default step in 6
.10de	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10e0	c8		iny				iny
.10e1	a5 29		lda $29				lda		esInt0+1 					; terminal value in 7 to 11.
.10e3	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10e5	c8		iny				iny
.10e6	a5 31		lda $31				lda		esInt1+1
.10e8	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10ea	c8		iny				iny
.10eb	a5 39		lda $39				lda		esInt2+1
.10ed	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10ef	c8		iny				iny
.10f0	a5 41		lda $41				lda		esInt3+1
.10f2	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10f4	68		pla				pla
.10f5	a8		tay				tay
.10f6	b1 00		lda ($00),y			lda 	(codePtr),y 				; followed by STEP.
.10f8	c9 c4		cmp #$c4			cmp 	#KWD_STEP
.10fa	d0 0e		bne $110a			bne 	_CFDone
.10fc	c8		iny				iny									; skip over step.
.10fd	20 c7 15	jsr $15c7			jsr 	EvaluateTOSDeref 			; get step
.1100	98		tya				tya
.1101	48		pha				pha
.1102	b5 28		lda $28,x			lda 	esInt0,x 					; copy it into step (bit lazy here)
.1104	a0 06		ldy #$06			ldy 	#6
.1106	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1108	68		pla				pla
.1109	a8		tay				tay
.110a					_CFDone:
.110a	20 53 1e	jsr $1e53			jsr 	StackSavePosition 			; save position.
.110d	60		rts				rts
.110e					Command_NEXT:
.110e	a9 4b		lda #$4b			lda 	#SMFor 						; check NEXT
.1110	20 24 1e	jsr $1e24			jsr 	StackCheck
.1113	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it NEXT <index>
.1115	30 1e		bmi $1135			bmi 	_CNNoIndex
.1117	c9 60		cmp #$60			cmp 	#$60
.1119	b0 1a		bcs $1135			bcs 	_CNNoIndex
.111b	a2 00		ldx #$00			ldx 	#0 							; start on stack
.111d	a9 07		lda #$07			lda 	#7  						; get a term
.111f	20 d1 15	jsr $15d1			jsr 	EvaluateLevelAX 			; this is the variable/parameter to localise.
.1122	98		tya				tya
.1123	48		pha				pha
.1124	a0 04		ldy #$04			ldy 	#4 							; check same variable
.1126	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.1128	d5 28		cmp $28,x			cmp 	esInt0,x
.112a	d0 72		bne $119e			bne 	_CNBadIndex
.112c	c8		iny				iny
.112d	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.112f	d5 30		cmp $30,x			cmp 	esInt1,x
.1131	d0 6b		bne $119e			bne 	_CNBadIndex
.1133	68		pla				pla
.1134	a8		tay				tay
.1135					_CNNoIndex:
.1135	98		tya				tya
.1136	48		pha				pha
.1137	a0 04		ldy #$04			ldy 	#4 							; make temp0 point to the index
.1139	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.113b	85 04		sta $04				sta 	temp0
.113d	c8		iny				iny
.113e	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.1140	85 05		sta $05				sta 	temp0+1
.1142	c8		iny				iny
.1143	a2 00		ldx #$00			ldx 	#0 							; X is the sign of the step.
.1145	b1 0e		lda ($0e),y			lda 	(StackPtr),y 				; get the step.
.1147	85 09		sta $09				sta 	temp2+1 					; save for later.
.1149	10 01		bpl $114c			bpl 	_CNSignX
.114b	ca		dex				dex
.114c					_CNSignX:
.114c	18		clc				clc 								; add to the LSB
.114d	a0 00		ldy #$00			ldy 	#0
.114f	71 04		adc ($04),y			adc 	(temp0),y
.1151	91 04		sta ($04),y			sta 	(temp0),y
.1153					_CNPropogate:
.1153	c8		iny				iny  								; add the sign extended in X to the rest.
.1154	8a		txa				txa
.1155	71 04		adc ($04),y			adc 	(temp0),y
.1157	91 04		sta ($04),y			sta 	(temp0),y
.1159	c8		iny				iny
.115a	8a		txa				txa
.115b	71 04		adc ($04),y			adc 	(temp0),y
.115d	91 04		sta ($04),y			sta 	(temp0),y
.115f	c8		iny				iny
.1160	8a		txa				txa
.1161	71 04		adc ($04),y			adc 	(temp0),y
.1163	91 04		sta ($04),y			sta 	(temp0),y
.1165	18		clc				clc 								; point temp1 to the terminal value.
.1166	a5 0e		lda $0e				lda 	StackPtr
.1168	69 07		adc #$07			adc 	#7
.116a	85 06		sta $06				sta 	temp1
.116c	a9 00		lda #$00			lda 	#0
.116e	85 08		sta $08				sta 	temp2 						; clear temp2, which is the OR of all the subtractions.
.1170	a8		tay				tay 								; and clear the Y register again.
.1171	65 0f		adc $0f				adc 	StackPtr+1
.1173	85 07		sta $07				sta 	temp1+1
.1175	38		sec				sec 								; calculate current - limit oring interim values.
.1176	20 a8 11	jsr $11a8			jsr 	_CNCompare
.1179	20 a8 11	jsr $11a8			jsr 	_CNCompare
.117c	20 a8 11	jsr $11a8			jsr 	_CNCompare
.117f	20 a8 11	jsr $11a8			jsr 	_CNCompare
.1182	50 02		bvc $1186			bvc 	_CNNoOverflow 				; converts to a signed comparison on the sign bit.
.1184	49 80		eor #$80			eor 	#$80
.1186					_CNNoOverflow:
.1186	a4 09		ldy $09				ldy 	temp2+1						; get step back
.1188	30 17		bmi $11a1			bmi 	_CNCheckDownto
.118a	c9 00		cmp #$00			cmp 	#0
.118c	30 0a		bmi $1198			bmi 	_CNLoopRound 				; loop round if < =
.118e	a5 08		lda $08				lda 	temp2
.1190	f0 06		beq $1198			beq 	_CNLoopRound
.1192					_CNLoopExit:
.1192	68		pla				pla
.1193	a8		tay				tay
.1194	20 2f 1e	jsr $1e2f			jsr		StackClose 					; delete from stack and continue
.1197	60		rts				rts
.1198					_CNLoopRound:
.1198	68		pla				pla
.1199	a8		tay				tay
.119a	20 43 1e	jsr $1e43			jsr 	StackLoadPosition			; go back to the loop top
.119d	60		rts				rts
.119e					_CNBadIndex:
.119e	4c ba 18	jmp $18ba			jmp 	EHandlerBadIndex
.11a1					_CNCheckDownto:
.11a1	c9 00		cmp #$00			cmp 	#0
.11a3	10 f3		bpl $1198			bpl 	_CNLoopRound
.11a5	4c 92 11	jmp $1192			jmp 	_CNLoopExit
.11a8					_CNCompare:
.11a8	b1 04		lda ($04),y			lda 	(temp0),y 					; do the subtraction - compare don't care about answer
.11aa	f1 06		sbc ($06),y			sbc 	(temp1),y
.11ac	05 08		ora $08				ora 	temp2 						; Or into temp2 (does not affect carry)
.11ae	85 08		sta $08				sta 	temp2
.11b0	c8		iny				iny
.11b1	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/gosub.asm

.11b2					Command_Gosub:
.11b2	20 c1 15	jsr $15c1			jsr 	EvaluateBaseDeRef			; get the target line #
.11b5	a9 14		lda #$14			lda 	#SMGosub 					; gosub marker allocate 4 bytes.
.11b7	20 ff 1d	jsr $1dff			jsr 	StackOpen 					; create on stack.
.11ba	20 53 1e	jsr $1e53			jsr 	StackSavePosition 			; save position.
.11bd	4c d4 11	jmp $11d4			jmp 	GotoTOS 					; and use the GOTO code.
.11c0					Command_Return:
.11c0	a9 14		lda #$14			lda 	#SMGosub 					; check the stack matches
.11c2	20 24 1e	jsr $1e24			jsr 	StackCheck
.11c5	d0 07		bne $11ce			bne 	_RTError
.11c7	20 43 1e	jsr $1e43			jsr 	StackLoadPosition 			; load the position back
.11ca	20 2f 1e	jsr $1e2f			jsr 	StackClose 					; close the frame.
.11cd	60		rts				rts
.11ce					_RTError:
.11ce	4c 2f 19	jmp $192f			jmp 	EHandlerNoGosub

;******  Return to file: basic.asm


;******  Processing file: common/commands/goto.asm

.11d1					Command_Goto:
.11d1	20 c1 15	jsr $15c1			jsr 	EvaluateBaseDeRef			; get the target line #
.11d4					GotoTOS:
.11d4	20 e7 11	jsr $11e7			jsr 	FindGoto
.11d7	90 0b		bcc $11e4			bcc 	GotoError 					; not found
.11d9	a5 04		lda $04				lda		temp0 						; copy new line address
.11db	85 00		sta $00				sta 	codePtr
.11dd	a5 05		lda $05				lda 	temp0+1
.11df	85 01		sta $01				sta 	codePtr+1
.11e1	a0 03		ldy #$03			ldy 	#3 							; first token.
.11e3	60		rts				rts
.11e4					GotoError:
.11e4	4c 08 19	jmp $1908			jmp 	EHandlerLineNumber
.11e7					FindGoto:
.11e7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.11e9	85 04		sta $04				sta 	temp0
.11eb	a9 1f		lda #$1f			lda 	#(BasicProgram) >> 8
.11ed	85 05		sta $05				sta 	1+(temp0)
.11ef					_FGLoop:
.11ef	a0 00		ldy #$00			ldy 	#0 							; look at link
.11f1	b1 04		lda ($04),y			lda 	(temp0),y
.11f3	18		clc				clc
.11f4	f0 0f		beq $1205			beq 	_FGExit
.11f6	c8		iny				iny 								; compare line.low
.11f7	b1 04		lda ($04),y			lda 	(temp0),y
.11f9	d5 28		cmp $28,x			cmp 	esInt0,x
.11fb	d0 09		bne $1206			bne 	_FGNext
.11fd	c8		iny				iny 								; compare line.high
.11fe	b1 04		lda ($04),y			lda 	(temp0),y
.1200	d5 30		cmp $30,x			cmp 	esInt1,x
.1202	d0 02		bne $1206			bne 	_FGNext
.1204	38		sec				sec
.1205					_FGExit:
.1205	60		rts				rts
.1206					_FGNext:
.1206	a0 00		ldy #$00			ldy 	#0
.1208	18		clc				clc
.1209	b1 04		lda ($04),y			lda 	(temp0),y
.120b	65 04		adc $04				adc 	temp0
.120d	85 04		sta $04				sta 	temp0
.120f	90 de		bcc $11ef			bcc 	_FGLoop
.1211	e6 05		inc $05				inc 	temp0+1
.1213	4c ef 11	jmp $11ef			jmp 	_FGLoop

;******  Return to file: basic.asm


;******  Processing file: common/commands/if.asm

.1216					Command_IF:
.1216	20 c1 15	jsr $15c1			jsr 	EvaluateBaseDeRef			; get the target address
.1219	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by THEN ?
.121b	c9 c1		cmp #$c1			cmp 	#KWD_THEN
.121d	d0 15		bne $1234			bne 	StructureIF
.121f	c8		iny				iny 								; skip THEN
.1220	20 74 1d	jsr $1d74			jsr 	Int32Zero 					; is it true ?
.1223	f0 0c		beq $1231			beq 	_IfFalse
.1225	b1 00		lda ($00),y			lda 	(codePtr),y 				; if THEN <const> do GOTO.
.1227	30 04		bmi $122d			bmi 	_CIFExit
.1229	c9 70		cmp #$70			cmp 	#$70
.122b	b0 01		bcs $122e			bcs 	_CIFGoto
.122d					_CIFExit:
.122d	60		rts				rts 								; otherwise carry on.
.122e					_CIFGoto:
.122e	4c d1 11	jmp $11d1			jmp 	Command_GOTO
.1231					_IfFalse:
.1231	4c 89 13	jmp $1389			jmp 	CommandNextLine
.1234					StructureIF:
.1234	20 74 1d	jsr $1d74			jsr 	Int32Zero 					; is it true ?
.1237	f0 01		beq $123a			beq 	_SIFSkip 					; if non-zero then skip to ELSE/ENDIF
.1239	60		rts				rts 								; else continue.
.123a					_SIFSkip:
.123a	a9 c2		lda #$c2			lda	 	#KWD_ELSE 					; test failed, go to ELSE or ENDIF whichever comes first.
.123c	a2 b8		ldx #$b8			ldx 	#KWD_ENDIF
.123e	4c b1 1d	jmp $1db1			jmp		ScanForward
.1241					Command_ELSE:
.1241	a2 b8		ldx #$b8			ldx 	#KWD_ENDIF
.1243	8a		txa				txa
.1244	4c b1 1d	jmp $1db1			jmp		ScanForward
.1247					Command_ENDIF:
.1247	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/let.asm

.1248					Command_LET:
.1248	a2 00		ldx #$00			ldx 	#0 							; start on stack
.124a	a9 04		lda #$04			lda 	#4  						; this means ! ? and $ binary operators only work.
.124c	20 d1 15	jsr $15d1			jsr 	EvaluateLevelAX 			; this is the LHS
.124f	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.1251	10 2f		bpl $1282			bpl 	_CLSyntax 					; if not, syntax error.
.1253	20 c7 13	jsr $13c7			jsr 	CheckEquals 				; check equals follows.
.1256	e8		inx				inx 								; get the right hand side.
.1257	20 c7 15	jsr $15c7			jsr 	EvaluateTOSDeRef
.125a	ca		dex				dex
.125b	b5 28		lda $28,x			lda 	esInt0,x 					; copy target address to temp0
.125d	85 04		sta $04				sta 	temp0
.125f	b5 30		lda $30,x			lda 	esInt1,x
.1261	85 05		sta $05				sta 	temp0+1
.1263	b5 20		lda $20,x			lda 	esType,x 					; what sort of reference ?
.1265	0a		asl a				asl 	a 							; will now be $00 integer $80 byte $02 string.
.1266	f0 22		beq $128a			beq 	_CLIntCopy
.1268	30 1b		bmi $1285			bmi 	_CLByteCopy
.126a	b5 29		lda $29,x			lda 	esInt0+1,x 					; source -> temp1
.126c	85 06		sta $06				sta 	temp1
.126e	b5 31		lda $31,x			lda 	esInt1+1,x
.1270	85 07		sta $07				sta 	temp1+1
.1272	98		tya				tya
.1273	48		pha				pha
.1274	a0 00		ldy #$00			ldy 	#0
.1276					_CLStringCopy:
.1276	b1 06		lda ($06),y			lda 	(temp1),y
.1278	91 04		sta ($04),y			sta 	(temp0),y
.127a	f0 03		beq $127f			beq 	_CLCopyExit 				; copied trailing NULL
.127c	c8		iny				iny
.127d	d0 f7		bne $1276			bne 	_CLStringCopy 				; it could run riot.
.127f					_CLCopyExit:
.127f	68		pla				pla
.1280	a8		tay				tay
.1281	60		rts				rts
.1282					_CLSyntax:
.1282	4c ba 19	jmp $19ba			jmp 	EHandlerSyntax
.1285					_CLByteCopy:
.1285	b5 29		lda $29,x			lda 	esInt0+1,x 					; get the byte to write.
.1287	81 04		sta ($04,x)			sta 	(temp0,x)					; write, taking advantage of X = 0
.1289	60		rts				rts
.128a					_CLIntCopy:
.128a	e8		inx				inx
.128b	20 8f 12	jsr $128f			jsr 	CopyTOSToTemp0
.128e	60		rts				rts
.128f					CopyTOSToTemp0:
.128f	98		tya				tya
.1290	48		pha				pha
.1291	a0 00		ldy #$00			ldy 	#0
.1293	b5 28		lda $28,x			lda 	esInt0,x
.1295	91 04		sta ($04),y			sta 	(temp0),y
.1297	c8		iny				iny
.1298	b5 30		lda $30,x			lda 	esInt1,x
.129a	91 04		sta ($04),y			sta 	(temp0),y
.129c	c8		iny				iny
.129d	b5 38		lda $38,x			lda 	esInt2,x
.129f	91 04		sta ($04),y			sta 	(temp0),y
.12a1	c8		iny				iny
.12a2	b5 40		lda $40,x			lda 	esInt3,x
.12a4	91 04		sta ($04),y			sta 	(temp0),y
.12a6	68		pla				pla
.12a7	a8		tay				tay
.12a8	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/new.asm

.12a9					Command_New:
.12a9	a9 00		lda #$00			lda 	#0 							; clear program
.12ab	8d 00 1f	sta $1f00			sta 	BasicProgram
.12ae	4c 95 10	jmp $1095			jmp 	CommandClear				; clear variables etc.

;******  Return to file: basic.asm


;******  Processing file: common/commands/print.asm

.12b1					Command_Print:
.12b1					_CPRLoop:
.12b1	a9 00		lda #$00			lda 	#0 							; zero the print CRFlag
.12b3					_CPRSetFlag:
.12b3	8d a7 08	sta $08a7			sta 	PrintCRFlag
.12b6	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token.
.12b8	c9 80		cmp #$80			cmp 	#$80						; if EOL exit.
.12ba	f0 5d		beq $1319			beq 	_CPRExit
.12bc	c9 c0		cmp #$c0			cmp 	#KWD_COLON 					; if colon exit
.12be	f0 59		beq $1319			beq 	_CPRExit
.12c0	c9 60		cmp #$60			cmp 	#$60 						; if $60  it is a string.
.12c2	f0 38		beq $12fc			beq 	_CPRString
.12c4	c9 00		cmp #$00			cmp 	#$00 						; if -ve go to token
.12c6	30 04		bmi $12cc			bmi 	_CPRToken
.12c8	c9 70		cmp #$70			cmp 	#$70 						; is it a number, if so print as decimal.
.12ca	b0 14		bcs $12e0			bcs 	_CPRDecimal
.12cc					_CPRToken:
.12cc	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the token ID and skip it.
.12ce	c8		iny				iny
.12cf	c9 ad		cmp #$ad			cmp 	#KWD_SEMICOLON 				; semicolon goes to set flag which is now non zero
.12d1	f0 e0		beq $12b3			beq 	_CPRSetFlag
.12d3	c9 bf		cmp #$bf			cmp 	#KWD_SQUOTE 				; single quote is CR.
.12d5	f0 34		beq $130b			beq 	_CPRNewLine
.12d7	c9 96		cmp #$96			cmp 	#KWD_AMPERSAND 				; &x means print in hex
.12d9	f0 09		beq $12e4			beq 	_CPRHexaDecimal
.12db	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; comma is tab (possibly space)
.12dd	f0 32		beq $1311			beq 	_CPRTab
.12df	88		dey				dey 								; undo the skip.
.12e0					_CPRDecimal:
.12e0	a9 8a		lda #$8a			lda 	#10+128
.12e2	d0 3e		bne $1322			bne 	_CPRPrintInteger
.12e4					_CPRHexaDecimal:
.12e4	a9 10		lda #$10			lda 	#16
.12e6	d0 3a		bne $1322			bne 	_CPRPrintInteger
.12e8					_CPRStringExpr:
.12e8	68		pla				pla 								; chuck the base.
.12e9	8a		txa				txa
.12ea	48		pha				pha
.12eb	98		tya				tya
.12ec	48		pha				pha
.12ed	b4 28		ldy $28,x			ldy 	esInt0,x
.12ef	b5 30		lda $30,x			lda 	esInt1,x
.12f1	aa		tax				tax
.12f2	20 36 14	jsr $1436			jsr 	PrintXYString
.12f5	68		pla				pla
.12f6	a8		tay				tay
.12f7	68		pla				pla
.12f8	aa		tax				tax
.12f9	4c b1 12	jmp $12b1			jmp 	_CPRLoop
.12fc					_CPRString:
.12fc	c8		iny				iny 								; move to start of string.
.12fd	c8		iny				iny
.12fe					_CPRStringLoop:
.12fe	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character and bump
.1300	c8		iny				iny
.1301	c9 00		cmp #$00			cmp 	#0 							; end of string, loop back.
.1303	f0 ac		beq $12b1			beq 	_CPRLoop
.1305	20 52 10	jsr $1052			jsr 	XTPrintA 					; print it and try next character.
.1308	4c fe 12	jmp $12fe			jmp 	_CPRStringLoop
.130b					_CPRNewLine:
.130b	20 42 10	jsr $1042			jsr 	XTPrintCR
.130e	4c b1 12	jmp $12b1			jmp 	_CPRLoop
.1311					_CPRTab:
.1311	20 4a 10	jsr $104a			jsr 	XTPrintTab
.1314	a9 01		lda #$01			lda 	#1
.1316	4c b3 12	jmp $12b3			jmp 	_CPRSetFlag
.1319					_CPRExit:
.1319	ad a7 08	lda $08a7			lda 	PrintCRFlag 				; check flag.
.131c	d0 03		bne $1321			bne 	_CPRNoNL
.131e	20 42 10	jsr $1042			jsr 	XTPrintCR
.1321					_CPRNoNL:
.1321	60		rts				rts
.1322					_CPRPrintInteger:
.1322	48		pha				pha 								; save base on stack
.1323	20 c1 15	jsr $15c1			jsr 	EvaluateBaseDeref 			; evaluate whatever it is.
.1326	b5 20		lda $20,x			lda 	esType,x 					; is it a string expression ?
.1328	4a		lsr a				lsr 	a
.1329	b0 bd		bcs $12e8			bcs 	_CPRStringExpr
.132b	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.132d	85 04		sta $04				sta 	temp0
.132f	a9 08		lda #$08			lda 	#(buffer) >> 8
.1331	85 05		sta $05				sta 	1+(temp0)
.1333	68		pla				pla
.1334	20 a9 1c	jsr $1ca9			jsr 	Int32ToString 				; convert in the buffer.
.1337	8a		txa				txa
.1338	48		pha				pha
.1339	a2 00		ldx #$00			ldx 	#0
.133b					_CPROutBuffer:
.133b	bd 8c 08	lda $088c,x			lda 	buffer,x
.133e	f0 06		beq $1346			beq 	_CPROBExit
.1340	20 52 10	jsr $1052			jsr 	XTPrintA
.1343	e8		inx				inx
.1344	d0 f5		bne $133b			bne 	_CPROutBuffer
.1346					_CPROBExit:
.1346	68		pla				pla
.1347	aa		tax				tax
.1348	4c b1 12	jmp $12b1			jmp 	_CPRLoop

;******  Return to file: basic.asm


;******  Processing file: common/commands/rem.asm

.134b					Command_Rem:
.134b					Command_Rem2:
.134b	b1 00		lda ($00),y			lda 	(codePtr),y
.134d	c9 80		cmp #$80			cmp 	#$80 						; end of line.
.134f	f0 0a		beq $135b			beq 	_RemExit
.1351	c9 c0		cmp #$c0			cmp 	#KWD_COLON
.1353	f0 06		beq $135b			beq 	_RemExit
.1355	20 5c 13	jsr $135c			jsr 	AdvancePointer
.1358	4c 4b 13	jmp $134b			jmp 	Command_Rem
.135b					_RemExit:
.135b	60		rts				rts
.135c					AdvancePointer:
.135c	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token
.135e	c9 01		cmp #$01			cmp 	#$01 						; quoted string
.1360	f0 02		beq $1364			beq 	_APString
.1362	c8		iny				iny 								; advance and return.
.1363	60		rts				rts
.1364					_APString:
.1364	98		tya				tya 								; and length to position
.1365	c8		iny				iny
.1366	18		clc				clc
.1367	71 00		adc ($00),y			adc 	(codePtr),y
.1369	a8		tay				tay
.136a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/run.asm

.136b					Command_Run:
.136b	20 95 10	jsr $1095			jsr 	CommandClear 				; clear variables, memory pointers, hash table.
.136e	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.1370	85 00		sta $00				sta 	codePtr
.1372	a9 1f		lda #$1f			lda 	#(BasicProgram) >> 8
.1374	85 01		sta $01				sta 	1+(codePtr)
.1376	a0 00		ldy #$00			ldy 	#0 							; check if off end of program.
.1378	b1 00		lda ($00),y			lda 	(codePtr),y
.137a	f0 28		beq $13a4			beq 	Command_End
.137c	a0 03		ldy #$03			ldy 	#3 							; start at this offset.
.137e					CommandNextCommand:
.137e	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first token ... see if it is a token.
.1380	10 1b		bpl $139d			bpl 	CommandTryLet				; if not, try LET as a default.
.1382	c8		iny				iny 								; advance past it.
.1383	20 fe 16	jsr $16fe			jsr 	ExecuteCommand 				; execute the command
.1386	4c 7e 13	jmp $137e			jmp 	CommandNextCommand
.1389					CommandNextLine:
.1389	a0 00		ldy #$00			ldy 	#0 							; get offset and add
.138b	b1 00		lda ($00),y			lda 	(codePtr),y
.138d	18		clc				clc
.138e	65 00		adc $00				adc 	codePtr
.1390	85 00		sta $00				sta 	codePtr
.1392	90 02		bcc $1396			bcc 	_CSLExit
.1394	e6 01		inc $01				inc 	codePtr+1
.1396					_CSLExit:
.1396	b1 00		lda ($00),y			lda 	(codePtr),y 				; reached end of code ?
.1398	f0 0a		beq $13a4			beq 	Command_End
.139a	a0 03		ldy #$03			ldy 	#3 							; 3rd position next line.
.139c	60		rts				rts
.139d					CommandTryLet:
.139d	20 48 12	jsr $1248			jsr 	Command_LET
.13a0	4c 7e 13	jmp $137e			jmp 	CommandNextCommand
.13a3					Command_Colon:
.13a3	60		rts				rts
.13a4					Command_End:
.13a4	4c 67 10	jmp $1067			jmp 	WarmStart
.13a7					Command_Stop:
.13a7	4c b2 19	jmp $19b2			jmp 	EHandlerStop

;******  Return to file: basic.asm


;******  Processing file: common/commands/vdu.asm

.13aa					Command_Vdu:
.13aa	20 c1 15	jsr $15c1			jsr 	EvaluateBaseDeRef			; evaluate the thing being asserted.
.13ad	b5 28		lda $28,x			lda 	esInt0,x 					; get the byte
.13af	20 52 10	jsr $1052			jsr 	XTPrintA 					; and print it
.13b2	b1 00		lda ($00),y			lda 	(codePtr),y 				; if comma follows
.13b4	c8		iny				iny
.13b5	c9 ac		cmp #$ac			cmp 	#KWD_COMMA
.13b7	f0 f1		beq $13aa			beq 	Command_Vdu 				; loop back roun.
.13b9	88		dey				dey
.13ba	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/errors/checksyntax.asm

.13bb					CheckComma:
.13bb	48		pha				pha
.13bc	a9 ac		lda #$ac			lda 	#KWD_COMMA
.13be	4c d9 13	jmp $13d9			jmp 	CheckSyntax
.13c1					CheckLeftParen:
.13c1	48		pha				pha
.13c2	a9 95		lda #$95			lda 	#KWD_LPAREN
.13c4	4c d9 13	jmp $13d9			jmp 	CheckSyntax
.13c7					CheckEquals:
.13c7	48		pha				pha
.13c8	a9 89		lda #$89			lda 	#KWD_EQUAL
.13ca	4c d9 13	jmp $13d9			jmp 	CheckSyntax
.13cd					CheckTO:
.13cd	48		pha				pha
.13ce	a9 c3		lda #$c3			lda 	#KWD_TO
.13d0	4c d9 13	jmp $13d9			jmp 	CheckSyntax
.13d3					CheckRightParen:
.13d3	48		pha				pha
.13d4	a9 ae		lda #$ae			lda 	#KWD_RPAREN
.13d6	4c d9 13	jmp $13d9			jmp 	CheckSyntax
.13d9					CheckSyntax:
.13d9	d1 00		cmp ($00),y			cmp 	(codePtr),y
.13db	d0 03		bne $13e0			bne 	_CSFail
.13dd	c8		iny				iny
.13de	68		pla				pla
.13df	60		rts				rts
.13e0					_CSFail:
.13e0	4c ba 19	jmp $19ba			jmp 	EHandlerSyntax
.13e3					NoOp1:
.13e3					NoOp2:
.13e3					NoOp3:
.13e3					NoOp6:
.13e3					NoOp7:
.13e3					NoOp8:
.13e3					NoOp9:
.13e3	4c ba 19	jmp $19ba			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/errors/errorhandler.asm

.13e6					ErrorHandler:
.13e6	84 0a		sty $0a				sty 	temp3
.13e8	68		pla				pla 								; line addr into XY.
.13e9	a8		tay				tay
.13ea	68		pla				pla
.13eb	aa		tax				tax
.13ec	c8		iny				iny
.13ed	d0 01		bne $13f0			bne 	_EHNoBump
.13ef	e8		inx				inx
.13f0					_EHNoBump:
.13f0	20 36 14	jsr $1436			jsr 	PrintXYString 				; print it
.13f3	a0 00		ldy #$00			ldy 	#0 							; if offset = 0 (e.g. not in program)
.13f5	b1 00		lda ($00),y			lda 	(codePtr),y
.13f7	f0 30		beq $1429			beq 	_GoWarm 					; no line #
.13f9	20 31 14	jsr $1431			jsr 	PrintSpace
.13fc	a9 40		lda #$40			lda 	#'@'
.13fe	20 32 10	jsr $1032			jsr 	XTPrintAC
.1401	20 31 14	jsr $1431			jsr 	PrintSpace
.1404	a2 00		ldx #$00			ldx 	#0 							; set up for ITOA conversion
.1406	c8		iny				iny
.1407	b1 00		lda ($00),y			lda 	(codePtr),y
.1409	95 28		sta $28,x			sta 	esInt0,x
.140b	c8		iny				iny
.140c	b1 00		lda ($00),y			lda 	(codePtr),y
.140e	95 30		sta $30,x			sta 	esInt1,x
.1410	8a		txa				txa
.1411	95 38		sta $38,x			sta 	esInt2,x
.1413	95 40		sta $40,x			sta 	esInt3,x
.1415	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.1417	85 04		sta $04				sta 	temp0
.1419	a9 08		lda #$08			lda 	#(buffer) >> 8
.141b	85 05		sta $05				sta 	1+(temp0)
.141d	a9 0a		lda #$0a			lda 	#10 						; convert base 10.
.141f	20 a9 1c	jsr $1ca9			jsr 	Int32ToString
.1422	a2 08		ldx #$08			ldx 	#buffer >> 8
.1424	a0 8c		ldy #$8c			ldy 	#buffer & $FF
.1426	20 36 14	jsr $1436			jsr 	PrintXYString
.1429					_GoWarm:
.1429	a5 0a		lda $0a				lda 	temp3
.142b	4c 67 10	jmp $1067			jmp 	WarmStart
.142e					InstructionUndefined:
.142e	4c 8d 19	jmp $198d			jmp 	EHandlerNotImplemented
.1431					PrintSpace:
.1431	a9 20		lda #$20			lda 	#32
.1433	4c 32 10	jmp $1032			jmp 	XTPrintAC
.1436					PrintXYString:
.1436	48		pha				pha
.1437	84 04		sty $04				sty 	temp0
.1439	86 05		stx $05				stx 	temp0+1
.143b	a0 00		ldy #$00			ldy 	#0
.143d					_PXYSLoop:
.143d	b1 04		lda ($04),y			lda 	(temp0),y
.143f	20 32 10	jsr $1032			jsr 	XTPrintAC
.1442	c8		iny				iny
.1443	b1 04		lda ($04),y			lda 	(temp0),y
.1445	d0 f6		bne $143d			bne 	_PXYSLoop
.1447	a4 04		ldy $04				ldy 	temp0
.1449	a6 05		ldx $05				ldx 	temp0+1
.144b	68		pla				pla
.144c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary1.asm

.144d					BinaryAdd:
.144d	20 89 16	jsr $1689			jsr		DeRefBoth
.1450	20 3e 1c	jsr $1c3e			jsr 	Int32Add
.1453	a9 00		lda #$00			lda 	#0
.1455	95 20		sta $20,x			sta 	esType,x
.1457	60		rts				rts
.1458					BinarySub:
.1458	20 89 16	jsr $1689			jsr		DeRefBoth
.145b	20 58 1c	jsr $1c58			jsr 	Int32Sub
.145e	a9 00		lda #$00			lda 	#0
.1460	95 20		sta $20,x			sta 	esType,x
.1462	60		rts				rts
.1463					BinaryMult:
.1463	20 89 16	jsr $1689			jsr		DeRefBoth
.1466	20 72 1c	jsr $1c72			jsr 	Int32Multiply
.1469	a9 00		lda #$00			lda 	#0
.146b	95 20		sta $20,x			sta 	esType,x
.146d	60		rts				rts
.146e					BinaryDivide:
.146e	20 89 16	jsr $1689			jsr		DeRefBoth
.1471	20 8a 14	jsr $148a			jsr		CheckDivisorNonZero
.1474	20 5b 1b	jsr $1b5b			jsr 	Int32SDivide
.1477	a9 00		lda #$00			lda 	#0
.1479	95 20		sta $20,x			sta 	esType,x
.147b	60		rts				rts
.147c					BinaryModulus:
.147c	20 89 16	jsr $1689			jsr		DeRefBoth
.147f	20 8a 14	jsr $148a			jsr 	CheckDivisorNonZero
.1482	20 ca 1b	jsr $1bca			jsr		Int32Modulus
.1485	a9 00		lda #$00			lda 	#0
.1487	95 20		sta $20,x			sta 	esType,x
.1489	60		rts				rts
.148a					CheckDivisorNonZero:
.148a	e8		inx				inx
.148b	20 74 1d	jsr $1d74			jsr 	Int32Zero
.148e	f0 02		beq $1492			beq 	_BDivZero
.1490	ca		dex				dex
.1491	60		rts				rts
.1492					_BDivZero:
.1492	4c f6 18	jmp $18f6			jmp 	EHandlerDivideZero
.1495					BinaryXor:
.1495	20 89 16	jsr $1689			jsr		DeRefBoth
.1498	20 0f 1b	jsr $1b0f			jsr 	Int32Xor
.149b	a9 00		lda #$00			lda 	#0
.149d	95 20		sta $20,x			sta 	esType,x
.149f	60		rts				rts
.14a0					BinaryOr:
.14a0	20 89 16	jsr $1689			jsr		DeRefBoth
.14a3	20 f6 1a	jsr $1af6			jsr 	Int32Or
.14a6	a9 00		lda #$00			lda 	#0
.14a8	95 20		sta $20,x			sta 	esType,x
.14aa	60		rts				rts
.14ab					BinaryAnd:
.14ab	20 89 16	jsr $1689			jsr		DeRefBoth
.14ae	20 dd 1a	jsr $1add			jsr 	Int32And
.14b1	a9 00		lda #$00			lda 	#0
.14b3	95 20		sta $20,x			sta 	esType,x
.14b5	60		rts				rts
.14b6					BinaryShiftLeft:
.14b6	20 89 16	jsr $1689			jsr		DeRefBoth
.14b9	20 e3 14	jsr $14e3			jsr 	CheckShiftParam2
.14bc	d0 21		bne $14df			bne 	BinaryShiftZero
.14be					BSLLoop:
.14be	d6 29		dec $29,x			dec 	esInt0+1,x
.14c0	30 18		bmi $14da			bmi 	BinaryShiftExit
.14c2	20 62 1d	jsr $1d62			jsr 	Int32ShiftLeft
.14c5	4c be 14	jmp $14be			jmp 	BSLLoop
.14c8					BinaryShiftRight:
.14c8	20 89 16	jsr $1689			jsr		DeRefBoth
.14cb	20 e3 14	jsr $14e3			jsr 	CheckShiftParam2
.14ce	d0 0f		bne $14df			bne 	BinaryShiftZero
.14d0					BSRLoop:
.14d0	d6 29		dec $29,x			dec 	esInt0+1,x
.14d2	30 06		bmi $14da			bmi 	BinaryShiftExit
.14d4	20 6b 1d	jsr $1d6b			jsr 	Int32ShiftRight
.14d7	4c d0 14	jmp $14d0			jmp 	BSRLoop
.14da					BinaryShiftExit:
.14da	a9 00		lda #$00			lda 	#0
.14dc	95 20		sta $20,x			sta 	esType,x
.14de	60		rts				rts
.14df					BinaryShiftZero:
.14df	20 4d 1d	jsr $1d4d			jsr 	Int32False
.14e2	60		rts				rts
.14e3					CheckShiftParam2:
.14e3	b5 29		lda $29,x			lda 	esInt0+1,x 					; if value >= 32 then result is zero
.14e5	29 e0		and #$e0			and 	#$E0
.14e7	15 31		ora $31,x			ora 	esInt1+1,x
.14e9	15 39		ora $39,x			ora 	esInt2+1,x
.14eb	15 41		ora $41,x			ora 	esInt3+1,x
.14ed	60		rts				rts
.14ee					IndirectWord:
.14ee	20 89 16	jsr $1689			jsr		DeRefBoth
.14f1	20 3e 1c	jsr $1c3e			jsr 	Int32Add
.14f4	a9 80		lda #$80			lda 	#$80 						; make it a reference
.14f6	95 20		sta $20,x			sta 	esType,x
.14f8	60		rts				rts
.14f9					IndirectByte:
.14f9	20 89 16	jsr $1689			jsr		DeRefBoth
.14fc	20 3e 1c	jsr $1c3e			jsr 	Int32Add
.14ff	a9 c0		lda #$c0			lda 	#$C0 						; type is set to byte reference.
.1501	95 20		sta $20,x			sta 	esType,x
.1503	60		rts				rts
.1504					IndirectString:
.1504	20 89 16	jsr $1689			jsr		DeRefBoth
.1507	20 3e 1c	jsr $1c3e			jsr 	Int32Add
.150a	a9 81		lda #$81			lda 	#$81 						; type is set to string reference.
.150c	95 20		sta $20,x			sta 	esType,x
.150e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary2.asm

.150f					Binary_Equal:
.150f	20 3f 15	jsr $153f			jsr 	TestEqual
.1512	b0 04		bcs $1518			bcs 	CompTrue
.1514					CompFalse:
.1514	20 4d 1d	jsr $1d4d			jsr 	Int32False
.1517	60		rts				rts
.1518					CompTrue
.1518	20 49 1d	jsr $1d49			jsr 	Int32True
.151b	60		rts				rts
.151c					Binary_NotEqual:
.151c	20 3f 15	jsr $153f			jsr 	TestEqual
.151f	90 f7		bcc $1518			bcc 	CompTrue
.1521	b0 f1		bcs $1514			bcs 	CompFalse
.1523					Binary_Less:
.1523	20 56 15	jsr $1556			jsr 	TestLess
.1526	b0 f0		bcs $1518			bcs 	CompTrue
.1528	90 ea		bcc $1514			bcc 	CompFalse
.152a					Binary_GreaterEqual:
.152a	20 56 15	jsr $1556			jsr 	TestLess
.152d	90 e9		bcc $1518			bcc 	CompTrue
.152f	b0 e3		bcs $1514			bcs 	CompFalse
.1531					Binary_LessEqual:
.1531	20 53 15	jsr $1553			jsr 	TestLessSwap
.1534	90 e2		bcc $1518			bcc 	CompTrue
.1536	b0 dc		bcs $1514			bcs 	CompFalse
.1538					Binary_Greater:
.1538	20 53 15	jsr $1553			jsr 	TestLessSwap
.153b	b0 db		bcs $1518			bcs 	CompTrue
.153d	90 d5		bcc $1514			bcc 	CompFalse
.153f					TestEqual:
.153f	20 6d 15	jsr $156d			jsr 	TypeCheck
.1542	c9 00		cmp #$00			cmp 	#0
.1544	f0 0a		beq $1550			beq 	_TEInteger
.1546	20 96 15	jsr $1596			jsr 	StringCompare
.1549	c9 00		cmp #$00			cmp 	#0
.154b	38		sec				sec
.154c	f0 01		beq $154f			beq 	_TEZero
.154e	18		clc				clc
.154f					_TEZero
.154f	60		rts				rts
.1550					_TEInteger:
.1550	4c 28 1b	jmp $1b28			jmp 	Int32Equal
.1553					TestLessSwap:
.1553	20 7a 15	jsr $157a			jsr 	SwapTopStack
.1556					TestLess:
.1556	20 6d 15	jsr $156d			jsr 	TypeCheck
.1559	c9 00		cmp #$00			cmp 	#0
.155b	f0 0d		beq $156a			beq 	_TLInteger
.155d	20 96 15	jsr $1596			jsr 	StringCompare
.1560	c9 00		cmp #$00			cmp 	#0
.1562	38		sec				sec
.1563	30 01		bmi $1566			bmi 	_TELess
.1565	18		clc				clc
.1566					_TELess:
.1566	60		rts				rts
.1567	4c 8d 19	jmp $198d			jmp 	EHandlerNotImplemented
.156a					_TLInteger:
.156a	4c 42 1b	jmp $1b42			jmp 	Int32Less
.156d					TypeCheck:
.156d	20 89 16	jsr $1689			jsr 	DerefBoth
.1570	b5 20		lda $20,x			lda 	esType,x
.1572	d5 21		cmp $21,x			cmp 	esType+1,x
.1574	d0 01		bne $1577			bne 	_TCMismatch
.1576	60		rts				rts
.1577					_TCMismatch:
.1577	4c ca 19	jmp $19ca			jmp 	EHandlerTypeMismatch
.157a					SwapTopStack:
.157a	a9 06		lda #$06			lda 	#6
.157c	85 03		sta $03				sta 	tempShort
.157e	8a		txa				txa
.157f	48		pha				pha
.1580					_TLSLoop:
.1580	b5 20		lda $20,x			lda 	esType,x
.1582	48		pha				pha
.1583	b5 21		lda $21,x			lda 	esType+1,x
.1585	95 20		sta $20,x			sta 	esType,x
.1587	68		pla				pla
.1588	95 21		sta $21,x			sta 	esType+1,x
.158a	8a		txa				txa
.158b	18		clc				clc
.158c	69 08		adc #$08			adc 	#DataStackSize
.158e	aa		tax				tax
.158f	c6 03		dec $03				dec 	tempShort
.1591	d0 ed		bne $1580			bne 	_TLSLoop
.1593	68		pla				pla
.1594	aa		tax				tax
.1595	60		rts				rts
.1596					StringCompare:
.1596	b5 28		lda $28,x			lda 	esInt0,x 					; copy addresses.
.1598	85 04		sta $04				sta 	temp0
.159a	b5 30		lda $30,x			lda 	esInt1,x
.159c	85 05		sta $05				sta 	temp0+1
.159e	b5 29		lda $29,x			lda 	esInt0+1,x
.15a0	85 06		sta $06				sta 	temp1
.15a2	b5 31		lda $31,x			lda 	esInt1+1,x
.15a4	85 07		sta $07				sta 	temp1+1
.15a6	84 03		sty $03				sty 	tempShort
.15a8	a0 ff		ldy #$ff			ldy 	#255
.15aa	c8		iny		_SCLoop:iny
.15ab	b1 04		lda ($04),y			lda 	(temp0),y 					; check match return +ve/-ve if fail.
.15ad	38		sec				sec
.15ae	f1 06		sbc ($06),y			sbc 	(temp1),y
.15b0	d0 04		bne $15b6			bne 	_SCExit
.15b2	b1 04		lda ($04),y			lda 	(temp0),y 					; matched zero, then exit with zero
.15b4	d0 f4		bne $15aa			bne 	_SCLoop
.15b6					_SCExit:
.15b6	a4 03		ldy $03				ldy 	tempShort
.15b8	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/evaluate.asm

.15b9					EvaluateTerm:
.15b9	a9 0f		lda #$0f			lda 	#15
.15bb	20 d1 15	jsr $15d1			jsr 	EvaluateLevelAX
.15be	4c 8e 16	jmp $168e			jmp 	DeRefTop
.15c1					EvaluateBaseDeRef:
.15c1	20 cd 15	jsr $15cd			jsr 	EvaluateBase
.15c4	4c 8e 16	jmp $168e			jmp 	DeRefTop
.15c7					EvaluateTOSDeRef:
.15c7	20 cf 15	jsr $15cf			jsr 	EvaluateTOS
.15ca	4c 8e 16	jmp $168e			jmp 	DeRefTop
.15cd					EvaluateBase:
.15cd	a2 00		ldx #$00			ldx 	#0 							; reset Stack index
.15cf					EvaluateTOS:
.15cf	a9 00		lda #$00			lda 	#0 							; start from lowest level.
.15d1					EvaluateLevelAX:
.15d1	48		pha				pha 								; save level on stack
.15d2	a9 00		lda #$00			lda 	#0 							; erase the current stack level
.15d4	95 28		sta $28,x			sta 	esInt0,x
.15d6	95 30		sta $30,x			sta 	esInt1,x
.15d8	95 38		sta $38,x			sta 	esInt2,x
.15da	95 40		sta $40,x			sta 	esInt3,x
.15dc	95 20		sta $20,x			sta 	esType,x 					; default to integer.
.15de	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next token/element.
.15e0	30 59		bmi $163b			bmi 	EBNotVariable 				; if $80-$FF it is a token.
.15e2	c9 70		cmp #$70			cmp 	#$70 						; if $70-$7F it is a constant
.15e4	90 06		bcc $15ec			bcc 	_EBNotConstant
.15e6					_EBConstant:
.15e6	20 cd 16	jsr $16cd			jsr 	ExtractConstant
.15e9	4c 0f 16	jmp $160f			jmp 	EBHaveTerm
.15ec					_EBNotConstant:
.15ec	c9 60		cmp #$60			cmp 	#$60 						; 60 is a string.
.15ee	f0 06		beq $15f6			beq 	_EBHaveString
.15f0	20 8b 1e	jsr $1e8b			jsr 	VariableAccess
.15f3	4c 0f 16	jmp $160f			jmp 	EBHaveTerm
.15f6					_EBHaveString:
.15f6	98		tya				tya 								; put codePtr + 2 in the address, it's a string.
.15f7	18		clc				clc
.15f8	69 02		adc #$02			adc 	#2
.15fa	65 00		adc $00				adc 	codePtr
.15fc	95 28		sta $28,x			sta 	esInt0,x
.15fe	a5 01		lda $01				lda 	codePtr+1
.1600	69 00		adc #$00			adc 	#0
.1602	95 30		sta $30,x			sta 	esInt1,x
.1604	f6 20		inc $20,x			inc 	esType,x 					; make the type a string.
.1606	98		tya				tya 								; position in A
.1607	c8		iny				iny 								; point to offset and add it
.1608	18		clc				clc
.1609	71 00		adc ($00),y			adc 	(codePtr),y
.160b	a8		tay				tay
.160c	4c 0f 16	jmp $160f			jmp 	EBHaveTerm 				; do the term code.
.160f					EBHaveTerm:
.160f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next element.
.1611	10 26		bpl $1639			bpl 	_EBPopExit 					; needs to be a token to continue.
.1613	84 03		sty $03				sty 	tempShort
.1615	a8		tay				tay
.1616	b9 5b 19	lda $195b,y			lda 	KeywordTypes-$80,y 			; get the type of the keyword.
.1619	a4 03		ldy $03				ldy 	tempShort
.161b	c9 10		cmp #$10			cmp 	#16 						; not a binary operator.
.161d	b0 1a		bcs $1639			bcs 	_EBPopExit
.161f	85 03		sta $03				sta 	tempShort 					; save level of new operator.
.1621	68		pla				pla 								; restore current level.
.1622	c5 03		cmp $03				cmp 	tempShort 					; if current >= operator then exit
.1624	b0 14		bcs $163a			bcs 	_EBExit
.1626	48		pha				pha 								; push level on stack.
.1627	b1 00		lda ($00),y			lda		(codePtr),y					; get the token ID and skip
.1629	c8		iny				iny
.162a	48		pha				pha 								; put that on the stack.
.162b	e8		inx				inx 								; do the term in the next stack level.
.162c	a5 03		lda $03				lda 	tempShort 					; get the level of the operator.
.162e	20 d1 15	jsr $15d1			jsr 	EvaluateLevelAX
.1631	ca		dex				dex
.1632	68		pla				pla 								; get token ID
.1633	20 fe 16	jsr $16fe			jsr 	ExecuteCommand 				; execute command A.
.1636	4c 0f 16	jmp $160f			jmp 	EBHaveTerm 					; keep going round
.1639					_EBPopExit:
.1639	68		pla				pla
.163a					_EBExit:
.163a	60		rts				rts
.163b					EBNotVariable:
.163b	84 03		sty $03				sty 	tempShort 					; get the type
.163d	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.163f	a8		tay				tay
.1640	b9 5b 19	lda $195b,y			lda 	KeywordTypes-$80,y
.1643	a4 03		ldy $03				ldy 	tempShort
.1645	29 40		and #$40			and 	#$40 						; check unary function
.1647	d0 37		bne $1680			bne 	_EBExecUnaryFunction
.1649	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.164b	c8		iny				iny
.164c	c9 8b		cmp #$8b			cmp 	#KWD_MINUS
.164e	f0 0f		beq $165f			beq 	_EBNegate
.1650	c9 91		cmp #$91			cmp 	#KWD_PLING
.1652	f0 14		beq $1668			beq 	_EBUnaryReference
.1654	c9 92		cmp #$92			cmp 	#KWD_QUESTION
.1656	f0 10		beq $1668			beq 	_EBUnaryReference
.1658	c9 93		cmp #$93			cmp 	#KWD_DOLLAR
.165a	f0 0c		beq $1668			beq 	_EBUnaryReference
.165c					_EBError:
.165c	4c ba 19	jmp $19ba			jmp 	EHandlerSyntax
.165f					_EBNegate:
.165f	20 b9 15	jsr $15b9			jsr 	EvaluateTerm
.1662	20 07 1d	jsr $1d07			jsr 	Int32Negate
.1665	4c 0f 16	jmp $160f			jmp 	EBHaveTerm
.1668					_EBUnaryReference:
.1668	48		pha				pha 								; save keyword
.1669	20 b9 15	jsr $15b9			jsr 	EvaluateTerm 				; get the address to case.
.166c	68		pla				pla
.166d	49 91		eor #$91			eor 	#KWD_PLING 					; is it pling, then will now be zero.
.166f	f0 08		beq $1679			beq 	_EBSetType
.1671	49 02		eor #$02			eor 	#KWD_DOLLAR^KWD_PLING 		; if was dollar will now be zero
.1673	f0 02		beq $1677			beq 	_EBSetString
.1675	a9 41		lda #$41			lda 	#$41 						; will end up as $C0
.1677					_EBSetString:
.1677	49 01		eor #$01			eor 	#$01 						; will end up as $81
.1679					_EBSetType:
.1679	09 80		ora #$80			ora 	#$80 						; make it a reference.
.167b	95 20		sta $20,x			sta 	esType,x
.167d	4c 0f 16	jmp $160f			jmp 	EBHaveTerm
.1680					_EBExecUnaryFunction:
.1680	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the function token.
.1682	c8		iny				iny
.1683	20 fe 16	jsr $16fe			jsr 	ExecuteCommand 				; and do it.
.1686	4c 0f 16	jmp $160f			jmp 	EBHaveTerm
.1689					DeRefBoth:
.1689	e8		inx				inx
.168a	20 8e 16	jsr $168e			jsr 	DeRefTop
.168d	ca		dex				dex
.168e					DeRefTop:
.168e	b5 20		lda $20,x			lda 	esType,x 					; is it a reference ?
.1690	10 3a		bpl $16cc			bpl 	_DRTExit
.1692	29 7f		and #$7f			and 	#$7F 						; clear the reference bit and write back.
.1694	95 20		sta $20,x			sta 	esType,x
.1696	4a		lsr a				lsr 	a 							; if string, exit. Strings are always references
.1697	b0 33		bcs $16cc			bcs 	_DRTExit
.1699	b5 28		lda $28,x			lda 	esInt0,x 					; copy address over.
.169b	85 04		sta $04				sta 	temp0
.169d	b5 30		lda $30,x			lda 	esInt1,x
.169f	85 05		sta $05				sta 	temp0+1
.16a1	98		tya				tya
.16a2	48		pha				pha
.16a3	a0 00		ldy #$00			ldy 	#0
.16a5	b1 04		lda ($04),y			lda 	(temp0),y
.16a7	95 28		sta $28,x			sta 	esInt0,x
.16a9	b5 20		lda $20,x			lda 	esType,x 					; is it now zero, e.g. it's a !
.16ab	f0 0c		beq $16b9			beq 	_DRTPling
.16ad	98		tya				tya 								; clear upper 3 bytes
.16ae	95 30		sta $30,x			sta 	esInt1,x
.16b0	95 38		sta $38,x			sta 	esInt2,x
.16b2	95 40		sta $40,x			sta 	esInt3,x
.16b4	95 20		sta $20,x			sta 	esType,x
.16b6	4c ca 16	jmp $16ca			jmp	 	_DRTExit2
.16b9					_DRTPling:
.16b9	94 20		sty $20,x			sty 	esType,x 					; make it an integer
.16bb	c8		iny				iny
.16bc	b1 04		lda ($04),y			lda 	(temp0),y 					; copy 4 bytes.
.16be	95 30		sta $30,x			sta 	esInt1,x
.16c0	c8		iny				iny
.16c1	b1 04		lda ($04),y			lda 	(temp0),y
.16c3	95 38		sta $38,x			sta 	esInt2,x
.16c5	c8		iny				iny
.16c6	b1 04		lda ($04),y			lda 	(temp0),y
.16c8	95 40		sta $40,x			sta 	esInt3,x
.16ca					_DRTExit2:
.16ca	68		pla				pla
.16cb	a8		tay				tay
.16cc					_DRTExit:
.16cc	60		rts				rts
.16cd					ExtractConstant:
.16cd	a9 00		lda #$00			lda 	#0 							; count of number of hex digits read.
.16cf	85 03		sta $03				sta 	tempShort 					; use tempShort for that
.16d1	8a		txa				txa
.16d2	48		pha				pha
.16d3					_EBConstLoop:
.16d3	e6 03		inc $03				inc 	tempShort 					; bump the hex digit count.
.16d5	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character.
.16d7	29 f0		and #$f0			and 	#$F0 						; check it is 70-7F
.16d9	c9 70		cmp #$70			cmp 	#$70
.16db	d0 1e		bne $16fb			bne 	_EBConstEnd
.16dd	a5 03		lda $03				lda 	tempShort 					; check LSB of digit count
.16df	4a		lsr a				lsr 	a
.16e0	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the digit and bump
.16e2	c8		iny				iny
.16e3	90 06		bcc $16eb			bcc		_EBConstHigh 				; goes in upper byte.
.16e5	29 0f		and #$0f			and 	#$0F
.16e7	95 28		sta $28,x			sta 	esInt0,x 					; and write it out.
.16e9	10 e8		bpl $16d3			bpl 	_EBConstLoop 				; try next one.
.16eb					_EBConstHigh:
.16eb	0a		asl a				asl 	a
.16ec	0a		asl a				asl 	a
.16ed	0a		asl a				asl 	a
.16ee	0a		asl a				asl 	a
.16ef	15 28		ora $28,x			ora 	esInt0,x 					; put into upper 4 bits
.16f1	95 28		sta $28,x			sta 	esInt0,x
.16f3	8a		txa				txa 								; move to next slot in data stack.
.16f4	18		clc				clc
.16f5	69 08		adc #$08			adc 	#DataStackSize
.16f7	aa		tax				tax
.16f8	4c d3 16	jmp $16d3			jmp 	_EBConstLoop
.16fb					_EBConstEnd:
.16fb	68		pla				pla
.16fc	aa		tax				tax
.16fd	60		rts				rts
.16fe					ExecuteCommand:
.16fe	85 03		sta $03				sta 	tempShort  					; needs making 65C02 specific.
.1700	8a		txa				txa
.1701	48		pha				pha
.1702	a6 03		ldx $03				ldx 	tempShort
.1704	bd b1 19	lda $19b1,x			lda 	TokenVectorLow-$80,x
.1707	85 04		sta $04				sta 	temp0
.1709	bd 07 1a	lda $1a07,x			lda 	TokenVectorHigh-$80,x
.170c	85 05		sta $05				sta 	temp0+1
.170e	68		pla				pla
.170f	aa		tax				tax
.1710	6c 04 00	jmp ($0004)			jmp 	(temp0)

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/unary.asm

.1713					UnaryPage:
.1713	20 2a 17	jsr $172a			jsr 	UnaryFalse 					; set all to zero/int
.1716	a9 00		lda #$00			lda 	#BasicProgram & $FF
.1718	95 28		sta $28,x			sta 	esInt0,x
.171a	a9 1f		lda #$1f			lda 	#BasicProgram >> 8
.171c	95 30		sta $30,x			sta 	esInt1,x
.171e	60		rts				rts
.171f					UnaryParenthesis:
.171f	20 cf 15	jsr $15cf			jsr 	EvaluateTOS					; evaluate expression
.1722	20 d3 13	jsr $13d3			jsr 	CheckRightParen				; check for )
.1725	60		rts				rts
.1726					UnaryTrue:
.1726	20 49 1d	jsr $1d49			jsr 	Int32True
.1729	60		rts				rts
.172a					UnaryFalse:
.172a	20 4d 1d	jsr $1d4d			jsr 	Int32False
.172d	60		rts				rts
.172e					UnaryAbs:
.172e	20 b9 15	jsr $15b9			jsr 	EvaluateTerm				; work out value required and dispatch
.1731	20 02 1d	jsr $1d02			jsr		Int32Absolute
.1734	a9 00		lda #$00			lda 	#0
.1736	95 20		sta $20,x			sta 	esType,x
.1738	60		rts				rts
.1739					UnarySys:
.1739	20 b9 15	jsr $15b9			jsr 	EvaluateTerm				; address to call
.173c	b5 28		lda $28,x			lda 	esInt0,x 					; copy call address
.173e	85 04		sta $04				sta 	temp0
.1740	b5 30		lda $30,x			lda 	esInt1,x
.1742	85 05		sta $05				sta 	temp0+1
.1744	8a		txa				txa
.1745	48		pha				pha
.1746	98		tya				tya
.1747	48		pha				pha
.1748	ad 00 08	lda $0800			lda 	('A'-'A')*4+RootVariables 	; load AXY
.174b	ae 5c 08	ldx $085c			ldx 	('X'-'A')*4+RootVariables
.174e	ac 60 08	ldy $0860			ldy 	('Y'-'A')*4+RootVariables
.1751	20 73 17	jsr $1773			jsr 	_USCall						; call code
.1754	8d 00 08	sta $0800			sta 	('A'-'A')*4+RootVariables 	; save AXY
.1757	8e 5c 08	stx $085c			stx 	('X'-'A')*4+RootVariables
.175a	8c 60 08	sty $0860			sty 	('Y'-'A')*4+RootVariables
.175d	68		pla				pla
.175e	a8		tay				tay
.175f	68		pla				pla
.1760	aa		tax				tax
.1761	ad 00 08	lda $0800			lda 	('A'-'A')*4+RootVariables 	; return A.
.1764	95 28		sta $28,x			sta 	esInt0,x
.1766	a9 00		lda #$00			lda 	#0
.1768	95 30		sta $30,x			sta 	esInt1,x
.176a	95 38		sta $38,x			sta 	esInt2,x
.176c	95 40		sta $40,x			sta 	esInt3,x
.176e	a9 00		lda #$00			lda 	#0
.1770	95 20		sta $20,x			sta 	esType,x
.1772	60		rts				rts
.1773	6c 04 00	jmp ($0004)	_USCall:jmp 	(temp0)
.1776					UnarySgn1:
.1776	20 b9 15	jsr $15b9			jsr 	EvaluateTerm				; work out value required and dispatch
.1779	20 3a 1d	jsr $1d3a			jsr 	Int32Sign
.177c	a9 00		lda #$00			lda 	#0
.177e	95 20		sta $20,x			sta 	esType,x
.1780	60		rts				rts
.1781					UnaryNot:
.1781	20 b9 15	jsr $15b9			jsr 	EvaluateTerm				; work out value required and dispatch
.1784	20 21 1d	jsr $1d21			jsr 	Int32Not
.1787	a9 00		lda #$00			lda 	#0
.1789	95 20		sta $20,x			sta 	esType,x
.178b	60		rts				rts
.178c					UnaryMin:
.178c	38		sec				sec 								; min indicated with CS
.178d	b0 01		bcs $1790			bcs 	UnaryMax+1
.178f					UnaryMax:
.178f	18		clc				clc 								; max is CC.
.1790	08		php				php 								; save what we're doing.
.1791	20 c1 13	jsr $13c1			jsr 	CheckLeftParen 				; check for (, required here
.1794	20 c7 15	jsr $15c7			jsr 	EvaluateTOSDeRef			; evaluate expression
.1797	e8		inx				inx
.1798	20 bb 13	jsr $13bb			jsr 	CheckComma
.179b	20 c7 15	jsr $15c7			jsr 	EvaluateTOSDeRef
.179e	20 89 16	jsr $1689			jsr 	DerefBoth 					; dereference them.
.17a1	ca		dex				dex
.17a2	20 d3 13	jsr $13d3			jsr 	CheckRightParen
.17a5	20 42 1b	jsr $1b42			jsr 	Int32Less 					; is p1 < p2, CS if true.
.17a8	a9 00		lda #$00			lda 	#0 							; put into A, now 1 if <, 0 if >
.17aa	69 00		adc #$00			adc 	#0
.17ac	28		plp				plp
.17ad	69 00		adc #$00			adc 	#0 							; toggle bit 0 for Min.
.17af	4a		lsr a				lsr 	a 							; put into carry
.17b0	90 03		bcc $17b5			bcc 	_UMinMaxExit 				; if clear just exit.
.17b2	20 7a 15	jsr $157a			jsr 	SwapTopStack 				; swap two values over.
.17b5					_UMinMaxExit:
.17b5	a9 00		lda #$00			lda 	#0
.17b7	95 20		sta $20,x			sta 	esType,x
.17b9	60		rts				rts
.17ba					UTypeError:
.17ba	4c ca 19	jmp $19ca			jmp 	EHandlerTypeMismatch
.17bd					UnaryRefToValue:
.17bd	a9 0f		lda #$0f			lda 	#15
.17bf	20 d1 15	jsr $15d1			jsr 	EvaluateLevelAX 			; get a term.
.17c2	b5 20		lda $20,x			lda 	esType,x
.17c4	10 f4		bpl $17ba			bpl 	UTypeError 					; not a reference
.17c6	29 7f		and #$7f			and 	#$7F 						; clear reference bit.
.17c8	95 20		sta $20,x			sta 	esType,x 					; overwrite type
.17ca	a9 00		lda #$00			lda 	#0
.17cc	95 20		sta $20,x			sta 	esType,x
.17ce	60		rts				rts
.17cf					UnaryHexMarker:
.17cf	4c b9 15	jmp $15b9			jmp 	EvaluateTerm
.17d2					UnaryRandom:
.17d2	20 7d 1d	jsr $1d7d			jsr 	Int32Random 				; random #
.17d5	a9 00		lda #$00			lda 	#0
.17d7	95 20		sta $20,x			sta 	esType,x
.17d9	60		rts				rts
.17da					UnaryLen:
.17da	20 b9 15	jsr $15b9			jsr 	EvaluateTerm				; work out value required and dispatch
.17dd	b5 28		lda $28,x			lda 	esInt0,x 					; copy addr to temp0
.17df	85 04		sta $04				sta 	temp0
.17e1	b5 30		lda $30,x			lda 	esInt1,x
.17e3	85 05		sta $05				sta 	temp0+1
.17e5	20 2a 17	jsr $172a			jsr 	UnaryFalse 					; sets return to int zero.
.17e8	98		tya				tya
.17e9	48		pha				pha
.17ea	a0 00		ldy #$00			ldy 	#0
.17ec					_ULCheck:
.17ec	b1 04		lda ($04),y			lda 	(temp0),y
.17ee	f0 03		beq $17f3			beq 	_ULFound
.17f0	c8		iny				iny
.17f1	d0 f9		bne $17ec			bne 	_ULCheck
.17f3					_ULFound:
.17f3	94 28		sty $28,x			sty 	esInt0,x 					; update result
.17f5	68		pla				pla
.17f6	a8		tay				tay
.17f7	60		rts				rts
.17f8	60		rts				rts
.17f9					UnaryChr:
.17f9	20 b9 15	jsr $15b9			jsr 	EvaluateTerm				; work out value required and dereference
.17fc	b5 28		lda $28,x			lda 	esInt0,x 					; get char code
.17fe	8d a5 08	sta $08a5			sta 	ChrBuffer 					; put into buffer.
.1801	a9 00		lda #$00			lda 	#0
.1803	8d a6 08	sta $08a6			sta 	ChrBuffer+1 				; make ASCIIZ
.1806	a9 a5		lda #$a5			lda 	#ChrBuffer & $FF 			; set address
.1808	95 28		sta $28,x			sta 	esInt0,x
.180a	a9 08		lda #$08			lda 	#ChrBuffer >> 8
.180c	95 30		sta $30,x			sta 	esInt1,x
.180e	f6 20		inc $20,x			inc 	esType,x 					; makes it a string
.1810	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/alloc.asm

.1811					Unary_Alloc:
.1811	4c 8d 19	jmp $198d			jmp 	EHandlerNotImplemented

;******  Return to file: basic.asm


;******  Processing file: common/functions/event.asm

.1814					Event_Function:
.1814	20 c1 13	jsr $13c1			jsr 	CheckLeftParen 				; check for (
.1817	a9 04		lda #$04			lda 	#4  						; this means ! ? and $ binary operators only work.
.1819	20 d1 15	jsr $15d1			jsr 	EvaluateLevelAX 			; this is the event variable.
.181c	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.181e	10 5d		bpl $187d			bpl 	_EFSyntax 					; if not, syntax error.
.1820	20 bb 13	jsr $13bb			jsr 	CheckComma
.1823	e8		inx				inx
.1824	20 c7 15	jsr $15c7			jsr 	EvaluateTOSDeRef 			; get the rate
.1827	ca		dex				dex
.1828	20 d3 13	jsr $13d3			jsr 	CheckRightParen 			; closing bracket.
.182b	20 16 10	jsr $1016			jsr 	XTUpdateClock
.182e	98		tya				tya
.182f	48		pha				pha
.1830	b5 28		lda $28,x			lda 	esInt0,x 					; point temp0 to the variable
.1832	85 04		sta $04				sta 	temp0
.1834	b5 30		lda $30,x			lda 	esInt1,x
.1836	85 05		sta $05				sta 	temp0+1
.1838	a0 00		ldy #$00			ldy 	#0 							; check if zero, if so initialise/return FLASE
.183a	b1 04		lda ($04),y			lda 	(temp0),y
.183c	c8		iny				iny
.183d	11 04		ora ($04),y			ora 	(temp0),y
.183f	f0 1b		beq $185c			beq 	_EFInitialise
.1841	a0 00		ldy #$00			ldy 	#0 							; calc timer - variable
.1843	ad a0 08	lda $08a0			lda 	ClockTicks
.1846	d1 04		cmp ($04),y			cmp 	(temp0),y
.1848	c8		iny				iny
.1849	ad a1 08	lda $08a1			lda 	ClockTicks+1
.184c	f1 04		sbc ($04),y			sbc 	(temp0),y
.184e	10 06		bpl $1856			bpl 	_EFFire						; if >= reset and return TRUE
.1850	20 4d 1d	jsr $1d4d			jsr 	Int32False					; otherwise just return FALSE
.1853	4c 7a 18	jmp $187a			jmp 	_EFExit
.1856					_EFFire:
.1856	20 49 1d	jsr $1d49			jsr 	Int32True
.1859	4c 5f 18	jmp $185f			jmp 	_EFResetTimer
.185c					_EFInitialise:
.185c	20 4d 1d	jsr $1d4d			jsr 	Int32False 					; return FALSE
.185f					_EFResetTimer:
.185f	a0 00		ldy #$00			ldy 	#0 							; reset the variable to clock + rate.
.1861	18		clc				clc
.1862	ad a0 08	lda $08a0			lda 	ClockTicks
.1865	75 29		adc $29,x			adc 	esInt0+1,x
.1867	91 04		sta ($04),y			sta 	(temp0),y
.1869	c8		iny				iny
.186a	ad a1 08	lda $08a1			lda 	ClockTicks+1
.186d	75 31		adc $31,x			adc 	esInt1+1,x
.186f	91 04		sta ($04),y			sta 	(temp0),y
.1871	88		dey				dey									; check zero
.1872	11 04		ora ($04),y			ora 	(temp0),y
.1874	d0 04		bne $187a			bne 	_EFExit
.1876	a9 01		lda #$01			lda 	#1 							; if so set it to 1.
.1878	91 04		sta ($04),y			sta 	(temp0),y
.187a					_EFExit:
.187a	68		pla				pla
.187b	a8		tay				tay
.187c	60		rts				rts
.187d					_EFSyntax:
.187d	4c ba 19	jmp $19ba			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/functions/keyboard.asm

.1880					Unary_Inkey:
.1880	20 06 10	jsr $1006			jsr 	XTGetKey
.1883	95 28		sta $28,x			sta 	esInt0,x
.1885	4c 5c 1d	jmp $1d5c			jmp 	Int32Set8Bit
.1888					Unary_Get:
.1888	20 80 18	jsr $1880			jsr 	Unary_Inkey
.188b	b5 28		lda $28,x			lda 	esInt0,x
.188d	f0 f9		beq $1888			beq 	Unary_Get
.188f	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/timer.asm

.1890					Unary_Timer:
.1890	20 16 10	jsr $1016			jsr 	XTUpdateClock
.1893	ad a0 08	lda $08a0			lda 	ClockTicks
.1896	95 28		sta $28,x			sta 	esInt0,x
.1898	ad a1 08	lda $08a1			lda 	ClockTicks+1
.189b	95 30		sta $30,x			sta 	esInt1,x
.189d	ad a2 08	lda $08a2			lda 	ClockTicks+2
.18a0	95 38		sta $38,x			sta 	esInt2,x
.18a2	a9 00		lda #$00			lda 	#0
.18a4	95 40		sta $40,x			sta 	esInt3,x
.18a6	95 20		sta $20,x			sta 	esType,x
.18a8	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/generated/errors.asm

.18a9					EHandlerAssert:
.18a9	20 e6 13	jsr $13e6		jsr	ErrorHandler
>18ac	41 73 73 65 72 74 20 46			.text "Assert Failed",0
>18b4	61 69 6c 65 64 00
.18ba					EHandlerBadIndex:
.18ba	20 e6 13	jsr $13e6		jsr	ErrorHandler
>18bd	57 72 6f 6e 67 20 4e 45			.text "Wrong NEXT index",0
>18c5	58 54 20 69 6e 64 65 78 00
.18ce					EHandlerBadProc:
.18ce	20 e6 13	jsr $13e6		jsr	ErrorHandler
>18d1	55 6e 6b 6e 6f 77 6e 20			.text "Unknown Procedure",0
>18d9	50 72 6f 63 65 64 75 72 65 00
.18e3					EHandlerClosure:
.18e3	20 e6 13	jsr $13e6		jsr	ErrorHandler
>18e6	53 74 72 75 63 74 75 72			.text "Structure Error",0
>18ee	65 20 45 72 72 6f 72 00
.18f6					EHandlerDivideZero:
.18f6	20 e6 13	jsr $13e6		jsr	ErrorHandler
>18f9	44 69 76 69 64 65 20 62			.text "Divide by Zero",0
>1901	79 20 5a 65 72 6f 00
.1908					EHandlerLineNumber:
.1908	20 e6 13	jsr $13e6		jsr	ErrorHandler
>190b	55 6e 6b 6e 6f 77 6e 20			.text "Unknown line",0
>1913	6c 69 6e 65 00
.1918					EHandlerMemory:
.1918	20 e6 13	jsr $13e6		jsr	ErrorHandler
>191b	49 6e 73 75 66 66 69 63			.text "Insufficient Memory",0
>1923	69 65 6e 74 20 4d 65 6d 6f 72 79 00
.192f					EHandlerNoGosub:
.192f	20 e6 13	jsr $13e6		jsr	ErrorHandler
>1932	52 65 74 75 72 6e 20 77			.text "Return without Gosub",0
>193a	69 74 68 6f 75 74 20 47 6f 73 75 62 00
.1947					EHandlerNoProc:
.1947	20 e6 13	jsr $13e6		jsr	ErrorHandler
>194a	45 6e 64 50 72 6f 63 20			.text "EndProc without Proc",0
>1952	77 69 74 68 6f 75 74 20 50 72 6f 63 00
.195f					EHandlerNoRepeat:
.195f	20 e6 13	jsr $13e6		jsr	ErrorHandler
>1962	55 6e 74 69 6c 20 77 69			.text "Until without Repeat",0
>196a	74 68 6f 75 74 20 52 65 70 65 61 74 00
.1977					EHandlerNoWhile:
.1977	20 e6 13	jsr $13e6		jsr	ErrorHandler
>197a	57 65 6e 64 20 77 69 74			.text "Wend without While",0
>1982	68 6f 75 74 20 57 68 69 6c 65 00
.198d					EHandlerNotImplemented:
.198d	20 e6 13	jsr $13e6		jsr	ErrorHandler
>1990	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>1998	65 6d 65 6e 74 65 64 00
.19a0					EHandlerParameters:
.19a0	20 e6 13	jsr $13e6		jsr	ErrorHandler
>19a3	42 61 64 20 50 61 72 61			.text "Bad Parameters",0
>19ab	6d 65 74 65 72 73 00
.19b2					EHandlerStop:
.19b2	20 e6 13	jsr $13e6		jsr	ErrorHandler
>19b5	53 74 6f 70 00				.text "Stop",0
.19ba					EHandlerSyntax:
.19ba	20 e6 13	jsr $13e6		jsr	ErrorHandler
>19bd	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>19c5	72 72 6f 72 00
.19ca					EHandlerTypeMismatch:
.19ca	20 e6 13	jsr $13e6		jsr	ErrorHandler
>19cd	54 79 70 65 20 4d 69 73			.text "Type Mismatch",0
>19d5	6d 61 74 63 68 00

;******  Return to file: basic.asm


;******  Processing file: common/generated/keytypes.asm

.19db					KeywordTypes:
>19db	81					.byte $81 ; $80 <<end>>
>19dc	01					.byte $01 ; $81 and
>19dd	01					.byte $01 ; $82 or
>19de	01					.byte $01 ; $83 xor
>19df	02					.byte $02 ; $84 >
>19e0	02					.byte $02 ; $85 <
>19e1	02					.byte $02 ; $86 >=
>19e2	02					.byte $02 ; $87 <=
>19e3	02					.byte $02 ; $88 <>
>19e4	02					.byte $02 ; $89 =
>19e5	03					.byte $03 ; $8a +
>19e6	03					.byte $03 ; $8b -
>19e7	04					.byte $04 ; $8c *
>19e8	04					.byte $04 ; $8d /
>19e9	04					.byte $04 ; $8e %
>19ea	04					.byte $04 ; $8f >>
>19eb	04					.byte $04 ; $90 <<
>19ec	05					.byte $05 ; $91 !
>19ed	05					.byte $05 ; $92 ?
>19ee	05					.byte $05 ; $93 $
>19ef	40					.byte $40 ; $94 ~
>19f0	40					.byte $40 ; $95 (
>19f1	40					.byte $40 ; $96 &
>19f2	40					.byte $40 ; $97 @
>19f3	40					.byte $40 ; $98 len
>19f4	40					.byte $40 ; $99 sgn
>19f5	40					.byte $40 ; $9a abs
>19f6	40					.byte $40 ; $9b random
>19f7	40					.byte $40 ; $9c page
>19f8	40					.byte $40 ; $9d true
>19f9	40					.byte $40 ; $9e false
>19fa	40					.byte $40 ; $9f min
>19fb	40					.byte $40 ; $a0 max
>19fc	40					.byte $40 ; $a1 sys
>19fd	40					.byte $40 ; $a2 code
>19fe	40					.byte $40 ; $a3 timer
>19ff	40					.byte $40 ; $a4 event
>1a00	40					.byte $40 ; $a5 get
>1a01	40					.byte $40 ; $a6 joy.x
>1a02	40					.byte $40 ; $a7 joy.y
>1a03	40					.byte $40 ; $a8 joy.btn
>1a04	40					.byte $40 ; $a9 inkey
>1a05	40					.byte $40 ; $aa alloc
>1a06	40					.byte $40 ; $ab chr
>1a07	81					.byte $81 ; $ac ,
>1a08	81					.byte $81 ; $ad ;
>1a09	81					.byte $81 ; $ae )
>1a0a	81					.byte $81 ; $af ++
>1a0b	81					.byte $81 ; $b0 --
>1a0c	81					.byte $81 ; $b1 [
>1a0d	81					.byte $81 ; $b2 ]
>1a0e	82					.byte $82 ; $b3 if
>1a0f	82					.byte $82 ; $b4 for
>1a10	82					.byte $82 ; $b5 repeat
>1a11	82					.byte $82 ; $b6 proc
>1a12	82					.byte $82 ; $b7 while
>1a13	80					.byte $80 ; $b8 endif
>1a14	80					.byte $80 ; $b9 next
>1a15	80					.byte $80 ; $ba until
>1a16	80					.byte $80 ; $bb endproc
>1a17	80					.byte $80 ; $bc wend
>1a18	81					.byte $81 ; $bd rem
>1a19	81					.byte $81 ; $be let
>1a1a	81					.byte $81 ; $bf '
>1a1b	81					.byte $81 ; $c0 :
>1a1c	81					.byte $81 ; $c1 then
>1a1d	81					.byte $81 ; $c2 else
>1a1e	81					.byte $81 ; $c3 to
>1a1f	81					.byte $81 ; $c4 step
>1a20	81					.byte $81 ; $c5 vdu
>1a21	81					.byte $81 ; $c6 print
>1a22	81					.byte $81 ; $c7 call
>1a23	81					.byte $81 ; $c8 local
>1a24	81					.byte $81 ; $c9 goto
>1a25	81					.byte $81 ; $ca gosub
>1a26	81					.byte $81 ; $cb return
>1a27	81					.byte $81 ; $cc assert
>1a28	81					.byte $81 ; $cd stop
>1a29	81					.byte $81 ; $ce end
>1a2a	81					.byte $81 ; $cf dim
>1a2b	81					.byte $81 ; $d0 clear
>1a2c	81					.byte $81 ; $d1 load
>1a2d	81					.byte $81 ; $d2 save
>1a2e	81					.byte $81 ; $d3 list
>1a2f	81					.byte $81 ; $d4 new
>1a30	81					.byte $81 ; $d5 run

;******  Return to file: basic.asm


;******  Processing file: common/generated/vectors.asm

.1a31					TokenVectorLow:
>1a31	89					.byte CommandNextLine & $FF            ; <<end>>
>1a32	ab					.byte BinaryAnd & $FF                  ; and
>1a33	a0					.byte BinaryOr & $FF                   ; or
>1a34	95					.byte BinaryXor & $FF                  ; xor
>1a35	38					.byte Binary_Greater & $FF             ; >
>1a36	23					.byte Binary_Less & $FF                ; <
>1a37	2a					.byte Binary_GreaterEqual & $FF        ; >=
>1a38	31					.byte Binary_LessEqual & $FF           ; <=
>1a39	1c					.byte Binary_NotEqual & $FF            ; <>
>1a3a	0f					.byte Binary_Equal & $FF               ; =
>1a3b	4d					.byte BinaryAdd & $FF                  ; +
>1a3c	58					.byte BinarySub & $FF                  ; -
>1a3d	63					.byte BinaryMult & $FF                 ; *
>1a3e	6e					.byte BinaryDivide & $FF               ; /
>1a3f	7c					.byte BinaryModulus & $FF              ; %
>1a40	c8					.byte BinaryShiftRight & $FF           ; >>
>1a41	b6					.byte BinaryShiftLeft & $FF            ; <<
>1a42	ee					.byte IndirectWord & $FF               ; !
>1a43	f9					.byte IndirectByte & $FF               ; ?
>1a44	04					.byte IndirectString & $FF             ; $
>1a45	81					.byte UnaryNot & $FF                   ; ~
>1a46	1f					.byte UnaryParenthesis & $FF           ; (
>1a47	cf					.byte UnaryHexMarker & $FF             ; &
>1a48	bd					.byte UnaryRefToValue & $FF            ; @
>1a49	da					.byte UnaryLen & $FF                   ; len
>1a4a	76					.byte UnarySgn1 & $FF                  ; sgn
>1a4b	2e					.byte UnaryAbs & $FF                   ; abs
>1a4c	d2					.byte UnaryRandom & $FF                ; random
>1a4d	13					.byte UnaryPage & $FF                  ; page
>1a4e	26					.byte UnaryTrue & $FF                  ; true
>1a4f	2a					.byte UnaryFalse & $FF                 ; false
>1a50	8c					.byte UnaryMin & $FF                   ; min
>1a51	8f					.byte UnaryMax & $FF                   ; max
>1a52	39					.byte UnarySys & $FF                   ; sys
>1a53	2e					.byte InstructionUndefined & $FF       ; code
>1a54	90					.byte Unary_Timer & $FF                ; timer
>1a55	14					.byte Event_Function & $FF             ; event
>1a56	88					.byte Unary_Get & $FF                  ; get
>1a57	2e					.byte InstructionUndefined & $FF       ; joy.x
>1a58	2e					.byte InstructionUndefined & $FF       ; joy.y
>1a59	2e					.byte InstructionUndefined & $FF       ; joy.btn
>1a5a	80					.byte Unary_Inkey & $FF                ; inkey
>1a5b	11					.byte Unary_Alloc & $FF                ; alloc
>1a5c	f9					.byte UnaryChr & $FF                   ; chr
>1a5d	e3					.byte NoOp1 & $FF                      ; ,
>1a5e	e3					.byte NoOp2 & $FF                      ; ;
>1a5f	e3					.byte NoOp3 & $FF                      ; )
>1a60	2e					.byte InstructionUndefined & $FF       ; ++
>1a61	2e					.byte InstructionUndefined & $FF       ; --
>1a62	2e					.byte InstructionUndefined & $FF       ; [
>1a63	2e					.byte InstructionUndefined & $FF       ; ]
>1a64	16					.byte Command_IF & $FF                 ; if
>1a65	be					.byte Command_FOR & $FF                ; for
>1a66	2e					.byte InstructionUndefined & $FF       ; repeat
>1a67	e3					.byte NoOp6 & $FF                      ; proc
>1a68	2e					.byte InstructionUndefined & $FF       ; while
>1a69	47					.byte Command_ENDIF & $FF              ; endif
>1a6a	0e					.byte Command_NEXT & $FF               ; next
>1a6b	2e					.byte InstructionUndefined & $FF       ; until
>1a6c	2e					.byte InstructionUndefined & $FF       ; endproc
>1a6d	2e					.byte InstructionUndefined & $FF       ; wend
>1a6e	4b					.byte Command_Rem & $FF                ; rem
>1a6f	48					.byte Command_LET & $FF                ; let
>1a70	4b					.byte Command_Rem2 & $FF               ; '
>1a71	a3					.byte Command_Colon & $FF              ; :
>1a72	e3					.byte NoOp7 & $FF                      ; then
>1a73	41					.byte Command_ELSE & $FF               ; else
>1a74	e3					.byte NoOp8 & $FF                      ; to
>1a75	e3					.byte NoOp9 & $FF                      ; step
>1a76	aa					.byte Command_Vdu & $FF                ; vdu
>1a77	b1					.byte Command_Print & $FF              ; print
>1a78	2e					.byte InstructionUndefined & $FF       ; call
>1a79	2e					.byte InstructionUndefined & $FF       ; local
>1a7a	d1					.byte Command_Goto & $FF               ; goto
>1a7b	b2					.byte Command_Gosub & $FF              ; gosub
>1a7c	c0					.byte Command_Return & $FF             ; return
>1a7d	6a					.byte Command_Assert & $FF             ; assert
>1a7e	a7					.byte Command_Stop & $FF               ; stop
>1a7f	a4					.byte Command_End & $FF                ; end
>1a80	2e					.byte InstructionUndefined & $FF       ; dim
>1a81	95					.byte CommandClear & $FF               ; clear
>1a82	2e					.byte InstructionUndefined & $FF       ; load
>1a83	2e					.byte InstructionUndefined & $FF       ; save
>1a84	2e					.byte InstructionUndefined & $FF       ; list
>1a85	a9					.byte Command_New & $FF                ; new
>1a86	6b					.byte Command_Run & $FF                ; run
.1a87					TokenVectorHigh:
>1a87	13					.byte CommandNextLine >> 8             ; <<end>>
>1a88	14					.byte BinaryAnd >> 8                   ; and
>1a89	14					.byte BinaryOr >> 8                    ; or
>1a8a	14					.byte BinaryXor >> 8                   ; xor
>1a8b	15					.byte Binary_Greater >> 8              ; >
>1a8c	15					.byte Binary_Less >> 8                 ; <
>1a8d	15					.byte Binary_GreaterEqual >> 8         ; >=
>1a8e	15					.byte Binary_LessEqual >> 8            ; <=
>1a8f	15					.byte Binary_NotEqual >> 8             ; <>
>1a90	15					.byte Binary_Equal >> 8                ; =
>1a91	14					.byte BinaryAdd >> 8                   ; +
>1a92	14					.byte BinarySub >> 8                   ; -
>1a93	14					.byte BinaryMult >> 8                  ; *
>1a94	14					.byte BinaryDivide >> 8                ; /
>1a95	14					.byte BinaryModulus >> 8               ; %
>1a96	14					.byte BinaryShiftRight >> 8            ; >>
>1a97	14					.byte BinaryShiftLeft >> 8             ; <<
>1a98	14					.byte IndirectWord >> 8                ; !
>1a99	14					.byte IndirectByte >> 8                ; ?
>1a9a	15					.byte IndirectString >> 8              ; $
>1a9b	17					.byte UnaryNot >> 8                    ; ~
>1a9c	17					.byte UnaryParenthesis >> 8            ; (
>1a9d	17					.byte UnaryHexMarker >> 8              ; &
>1a9e	17					.byte UnaryRefToValue >> 8             ; @
>1a9f	17					.byte UnaryLen >> 8                    ; len
>1aa0	17					.byte UnarySgn1 >> 8                   ; sgn
>1aa1	17					.byte UnaryAbs >> 8                    ; abs
>1aa2	17					.byte UnaryRandom >> 8                 ; random
>1aa3	17					.byte UnaryPage >> 8                   ; page
>1aa4	17					.byte UnaryTrue >> 8                   ; true
>1aa5	17					.byte UnaryFalse >> 8                  ; false
>1aa6	17					.byte UnaryMin >> 8                    ; min
>1aa7	17					.byte UnaryMax >> 8                    ; max
>1aa8	17					.byte UnarySys >> 8                    ; sys
>1aa9	14					.byte InstructionUndefined >> 8        ; code
>1aaa	18					.byte Unary_Timer >> 8                 ; timer
>1aab	18					.byte Event_Function >> 8              ; event
>1aac	18					.byte Unary_Get >> 8                   ; get
>1aad	14					.byte InstructionUndefined >> 8        ; joy.x
>1aae	14					.byte InstructionUndefined >> 8        ; joy.y
>1aaf	14					.byte InstructionUndefined >> 8        ; joy.btn
>1ab0	18					.byte Unary_Inkey >> 8                 ; inkey
>1ab1	18					.byte Unary_Alloc >> 8                 ; alloc
>1ab2	17					.byte UnaryChr >> 8                    ; chr
>1ab3	13					.byte NoOp1 >> 8                       ; ,
>1ab4	13					.byte NoOp2 >> 8                       ; ;
>1ab5	13					.byte NoOp3 >> 8                       ; )
>1ab6	14					.byte InstructionUndefined >> 8        ; ++
>1ab7	14					.byte InstructionUndefined >> 8        ; --
>1ab8	14					.byte InstructionUndefined >> 8        ; [
>1ab9	14					.byte InstructionUndefined >> 8        ; ]
>1aba	12					.byte Command_IF >> 8                  ; if
>1abb	10					.byte Command_FOR >> 8                 ; for
>1abc	14					.byte InstructionUndefined >> 8        ; repeat
>1abd	13					.byte NoOp6 >> 8                       ; proc
>1abe	14					.byte InstructionUndefined >> 8        ; while
>1abf	12					.byte Command_ENDIF >> 8               ; endif
>1ac0	11					.byte Command_NEXT >> 8                ; next
>1ac1	14					.byte InstructionUndefined >> 8        ; until
>1ac2	14					.byte InstructionUndefined >> 8        ; endproc
>1ac3	14					.byte InstructionUndefined >> 8        ; wend
>1ac4	13					.byte Command_Rem >> 8                 ; rem
>1ac5	12					.byte Command_LET >> 8                 ; let
>1ac6	13					.byte Command_Rem2 >> 8                ; '
>1ac7	13					.byte Command_Colon >> 8               ; :
>1ac8	13					.byte NoOp7 >> 8                       ; then
>1ac9	12					.byte Command_ELSE >> 8                ; else
>1aca	13					.byte NoOp8 >> 8                       ; to
>1acb	13					.byte NoOp9 >> 8                       ; step
>1acc	13					.byte Command_Vdu >> 8                 ; vdu
>1acd	12					.byte Command_Print >> 8               ; print
>1ace	14					.byte InstructionUndefined >> 8        ; call
>1acf	14					.byte InstructionUndefined >> 8        ; local
>1ad0	11					.byte Command_Goto >> 8                ; goto
>1ad1	11					.byte Command_Gosub >> 8               ; gosub
>1ad2	11					.byte Command_Return >> 8              ; return
>1ad3	10					.byte Command_Assert >> 8              ; assert
>1ad4	13					.byte Command_Stop >> 8                ; stop
>1ad5	13					.byte Command_End >> 8                 ; end
>1ad6	14					.byte InstructionUndefined >> 8        ; dim
>1ad7	10					.byte CommandClear >> 8                ; clear
>1ad8	14					.byte InstructionUndefined >> 8        ; load
>1ad9	14					.byte InstructionUndefined >> 8        ; save
>1ada	14					.byte InstructionUndefined >> 8        ; list
>1adb	12					.byte Command_New >> 8                 ; new
>1adc	13					.byte Command_Run >> 8                 ; run

;******  Return to file: basic.asm


;******  Processing file: common/math/int32binary.asm

.1add					Int32And:
.1add	b5 28		lda $28,x			lda 	esInt0,x
.1adf	35 29		and $29,x			and 	esInt0+1,x
.1ae1	95 28		sta $28,x			sta 	esInt0,x
.1ae3	b5 30		lda $30,x			lda 	esInt1,x
.1ae5	35 31		and $31,x			and 	esInt1+1,x
.1ae7	95 30		sta $30,x			sta 	esInt1,x
.1ae9	b5 38		lda $38,x			lda 	esInt2,x
.1aeb	35 39		and $39,x			and 	esInt2+1,x
.1aed	95 38		sta $38,x			sta 	esInt2,x
.1aef	b5 40		lda $40,x			lda 	esInt3,x
.1af1	35 41		and $41,x			and 	esInt3+1,x
.1af3	95 40		sta $40,x			sta 	esInt3,x
.1af5	60		rts				rts
.1af6					Int32Or:
.1af6	b5 28		lda $28,x			lda 	esInt0,x
.1af8	15 29		ora $29,x			ora 	esInt0+1,x
.1afa	95 28		sta $28,x			sta 	esInt0,x
.1afc	b5 30		lda $30,x			lda 	esInt1,x
.1afe	15 31		ora $31,x			ora 	esInt1+1,x
.1b00	95 30		sta $30,x			sta 	esInt1,x
.1b02	b5 38		lda $38,x			lda 	esInt2,x
.1b04	15 39		ora $39,x			ora 	esInt2+1,x
.1b06	95 38		sta $38,x			sta 	esInt2,x
.1b08	b5 40		lda $40,x			lda 	esInt3,x
.1b0a	15 41		ora $41,x			ora 	esInt3+1,x
.1b0c	95 40		sta $40,x			sta 	esInt3,x
.1b0e	60		rts				rts
.1b0f					Int32Xor:
.1b0f	b5 28		lda $28,x			lda 	esInt0,x
.1b11	55 29		eor $29,x			eor 	esInt0+1,x
.1b13	95 28		sta $28,x			sta 	esInt0,x
.1b15	b5 30		lda $30,x			lda 	esInt1,x
.1b17	55 31		eor $31,x			eor 	esInt1+1,x
.1b19	95 30		sta $30,x			sta 	esInt1,x
.1b1b	b5 38		lda $38,x			lda 	esInt2,x
.1b1d	55 39		eor $39,x			eor 	esInt2+1,x
.1b1f	95 38		sta $38,x			sta 	esInt2,x
.1b21	b5 40		lda $40,x			lda 	esInt3,x
.1b23	55 41		eor $41,x			eor 	esInt3+1,x
.1b25	95 40		sta $40,x			sta 	esInt3,x
.1b27	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32compare.asm

.1b28					Int32Equal:
.1b28	b5 28		lda $28,x			lda 	esInt0,x
.1b2a	d5 29		cmp $29,x			cmp 	esInt0+1,x
.1b2c	d0 2b		bne $1b59			bne 	Int32CFail
.1b2e	b5 30		lda $30,x			lda 	esInt1,x
.1b30	d5 31		cmp $31,x			cmp 	esInt1+1,x
.1b32	d0 25		bne $1b59			bne 	Int32CFail
.1b34	b5 38		lda $38,x			lda 	esInt2,x
.1b36	d5 39		cmp $39,x			cmp 	esInt2+1,x
.1b38	d0 1f		bne $1b59			bne 	Int32CFail
.1b3a	b5 40		lda $40,x			lda 	esInt3,x
.1b3c	d5 41		cmp $41,x			cmp 	esInt3+1,x
.1b3e	d0 19		bne $1b59			bne 	Int32CFail
.1b40					Int32CSucceed:
.1b40	38		sec				sec
.1b41	60		rts				rts
.1b42					Int32Less:
.1b42	38		sec				sec
.1b43	b5 28		lda $28,x			lda		esInt0,x
.1b45	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1b47	b5 30		lda $30,x			lda		esInt1,x
.1b49	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1b4b	b5 38		lda $38,x			lda		esInt2,x
.1b4d	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1b4f	b5 40		lda $40,x			lda		esInt3,x
.1b51	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1b53	50 02		bvc $1b57			bvc 	_I32LNoOverflow
.1b55	49 80		eor #$80			eor 	#$80
.1b57					_I32LNoOverflow
.1b57	30 e7		bmi $1b40			bmi 	Int32CSucceed
.1b59					Int32CFail:
.1b59	18		clc				clc
.1b5a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32divide.asm

.1b5b					Int32SDivide:
.1b5b	98		tya				tya  								; save Y, which is the count of negations
.1b5c	48		pha				pha
.1b5d	a0 00		ldy #$00			ldy 	#0 							; zero count
.1b5f	20 77 1b	jsr $1b77			jsr 	_Int32SRemSign 				; unsign TOS
.1b62	e8		inx				inx 								; unsign TOS+1
.1b63	20 77 1b	jsr $1b77			jsr 	_Int32SRemSign
.1b66	ca		dex				dex
.1b67	98		tya				tya 								; save sign count on stack
.1b68	48		pha				pha
.1b69	20 80 1b	jsr $1b80			jsr 	Int32UDivide 				; unsigned division
.1b6c	68		pla				pla 								; get sign count back
.1b6d	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.1b6f	f0 03		beq $1b74			beq 	_I32SNoNeg
.1b71	20 07 1d	jsr $1d07			jsr 	Int32Negate
.1b74					_I32SNoNeg:
.1b74	68		pla				pla 								; restoe Y and exit
.1b75	a8		tay				tay
.1b76	60		rts				rts
.1b77					_Int32SRemSign:
.1b77	b5 40		lda $40,x			lda 	esInt3,x 					; is it -ve
.1b79	10 04		bpl $1b7f			bpl 	_Int32SRSExit
.1b7b	c8		iny				iny 								; increment the sign count
.1b7c	20 07 1d	jsr $1d07			jsr 	Int32Negate 				; negate the value.
.1b7f					_Int32SRSExit:
.1b7f	60		rts				rts
.1b80					Int32UDivide:
.1b80	e8		inx				inx 								; clear A
.1b81	e8		inx				inx
.1b82	20 4d 1d	jsr $1d4d			jsr 	Int32False
.1b85	ca		dex				dex
.1b86	ca		dex				dex
.1b87	98		tya				tya 								; save Y on the stack
.1b88	48		pha				pha
.1b89	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.1b8b					_Int32UDLoop:
.1b8b	16 28		asl $28,x			asl 	esInt0,x					; shift QA left. First Q
.1b8d	36 30		rol $30,x			rol 	esInt1,x
.1b8f	36 38		rol $38,x			rol 	esInt2,x
.1b91	36 40		rol $40,x			rol 	esInt3,x
.1b93	36 2a		rol $2a,x			rol 	esInt0+2,x 					; then A.
.1b95	36 32		rol $32,x			rol 	esInt1+2,x
.1b97	36 3a		rol $3a,x			rol 	esInt2+2,x
.1b99	36 42		rol $42,x			rol 	esInt3+2,x
.1b9b	38		sec				sec 								; calculate A-M saving result on the stack
.1b9c	b5 2a		lda $2a,x			lda 	esInt0+2,x
.1b9e	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1ba0	48		pha				pha
.1ba1	b5 32		lda $32,x			lda 	esInt1+2,x
.1ba3	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1ba5	48		pha				pha
.1ba6	b5 3a		lda $3a,x			lda 	esInt2+2,x
.1ba8	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1baa	48		pha				pha
.1bab	b5 42		lda $42,x			lda 	esInt3+2,x
.1bad	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1baf	90 10		bcc $1bc1			bcc		_Int32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.1bb1	95 42		sta $42,x			sta 	esInt3+2,x 					; write result back to A
.1bb3	68		pla				pla
.1bb4	95 3a		sta $3a,x			sta 	esInt2+2,x
.1bb6	68		pla				pla
.1bb7	95 32		sta $32,x			sta 	esInt1+2,x
.1bb9	68		pla				pla
.1bba	95 2a		sta $2a,x			sta 	esInt0+2,x
.1bbc	f6 28		inc $28,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.1bbe	4c c4 1b	jmp $1bc4			jmp 	_Int32Next 					; do the next iteration
.1bc1					_Int32NoSubtract:
.1bc1	68		pla				pla
.1bc2	68		pla				pla
.1bc3	68		pla				pla
.1bc4					_Int32Next:
.1bc4	88		dey				dey 								; do this 32 times.
.1bc5	d0 c4		bne $1b8b			bne 	_Int32UDLoop
.1bc7	68		pla				pla 								; restore Y and exit
.1bc8	a8		tay				tay
.1bc9	60		rts				rts
.1bca					Int32Modulus:
.1bca	20 80 1b	jsr $1b80			jsr 	Int32UDivide 				; do the division.
.1bcd	b5 42		lda $42,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.1bcf	95 40		sta $40,x			sta 	esInt3,x
.1bd1	b5 3a		lda $3a,x			lda 	esInt2+2,x
.1bd3	95 38		sta $38,x			sta 	esInt2,x
.1bd5	b5 32		lda $32,x			lda 	esInt1+2,x
.1bd7	95 30		sta $30,x			sta 	esInt1,x
.1bd9	b5 2a		lda $2a,x			lda 	esInt0+2,x
.1bdb	95 28		sta $28,x			sta 	esInt0,x
.1bdd	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32fromstr.asm

.1bde					Int32FromString:
.1bde	85 03		sta $03				sta 	tempShort 					; save base
.1be0	98		tya				tya
.1be1	48		pha				pha
.1be2	a0 00		ldy #$00			ldy 	#0 							; set index into string being read
.1be4	b1 04		lda ($04),y			lda 	(temp0),y 					; look at first character
.1be6	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.1be8	d0 01		bne $1beb			bne 	_I32FSNotNegative
.1bea	c8		iny				iny 								; if so consume it.
.1beb					_I32FSNotNegative:
.1beb	a5 03		lda $03				lda 	tempShort 					; get the base back.
.1bed	c0 00		cpy #$00			cpy 	#0 							; if we read a -ve (e.g. Y != 0)
.1bef	f0 02		beq $1bf3			beq 	_I32FSNN2
.1bf1	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.1bf3					_I32FSNN2:
.1bf3	48		pha				pha 								; save base + final sign on stack.
.1bf4	20 4d 1d	jsr $1d4d			jsr 	Int32False 					; zero the return value.
.1bf7					I32FSMainLoop:
.1bf7	68		pla				pla 								; get the base back into tempshort
.1bf8	48		pha				pha
.1bf9	29 7f		and #$7f			and 	#$7F
.1bfb	85 03		sta $03				sta 	tempShort
.1bfd	b1 04		lda ($04),y			lda 	(temp0),y 					; look at next character.
.1bff	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.1c01	90 02		bcc $1c05			bcc 	_I32FSNotLC
.1c03	e9 20		sbc #$20			sbc 	#32
.1c05					_I32FSNotLC:
.1c05	38		sec				sec 								; subtract 48 (ASCII "0")
.1c06	e9 30		sbc #$30			sbc 	#"0"
.1c08	90 26		bcc $1c30			bcc 	_I32FSDone 					; nothing more to do.
.1c0a	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.1c0c	90 06		bcc $1c14			bcc 	_I32FSValidate
.1c0e	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.1c10	90 1e		bcc $1c30			bcc 	_I32FSDone
.1c12	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.1c14					_I32FSValidate:
.1c14	c5 03		cmp $03				cmp 	tempShort 					; compare against the base.
.1c16	b0 18		bcs $1c30			bcs 	_I32FSDone 					; sorry, too large for this base.
.1c18	48		pha				pha 								; save the new digit value.
.1c19	e8		inx				inx 								; put base into next slot.
.1c1a	a5 03		lda $03				lda 	tempShort
.1c1c	20 5c 1d	jsr $1d5c			jsr 	Int32Set8Bit
.1c1f	ca		dex				dex
.1c20	20 72 1c	jsr $1c72			jsr 	Int32Multiply 				; multiply current by the base
.1c23	e8		inx				inx
.1c24	68		pla				pla  								; put additive into next slot
.1c25	20 5c 1d	jsr $1d5c			jsr 	Int32Set8Bit
.1c28	ca		dex				dex
.1c29	20 3e 1c	jsr $1c3e			jsr 	Int32Add 					; and add it
.1c2c	c8		iny				iny 								; look at next character
.1c2d	4c f7 1b	jmp $1bf7			jmp 	I32FSMainLoop 				; and go round again.
.1c30					_I32FSDone:
.1c30	68		pla				pla 								; get base/final sign back
.1c31	10 04		bpl $1c37			bpl 	_I32FSNN3
.1c33	88		dey				dey 								; one fewer character to allow for the - prefix.
.1c34	20 07 1d	jsr $1d07			jsr 	Int32Negate 				; negate the result.
.1c37					_I32FSNN3:
.1c37	84 03		sty $03				sty 	tempShort 					; save the count of characters read
.1c39	68		pla				pla
.1c3a	a8		tay				tay
.1c3b	a5 03		lda $03				lda 	tempShort 					; get the count of characters read into A and exit
.1c3d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32math.asm

.1c3e					Int32Add:
.1c3e	18		clc				clc
.1c3f	b5 28		lda $28,x			lda 	esInt0,x
.1c41	75 29		adc $29,x			adc 	esInt0+1,x
.1c43	95 28		sta $28,x			sta 	esInt0,x
.1c45	b5 30		lda $30,x			lda 	esInt1,x
.1c47	75 31		adc $31,x			adc 	esInt1+1,x
.1c49	95 30		sta $30,x			sta 	esInt1,x
.1c4b	b5 38		lda $38,x			lda 	esInt2,x
.1c4d	75 39		adc $39,x			adc 	esInt2+1,x
.1c4f	95 38		sta $38,x			sta 	esInt2,x
.1c51	b5 40		lda $40,x			lda 	esInt3,x
.1c53	75 41		adc $41,x			adc 	esInt3+1,x
.1c55	95 40		sta $40,x			sta 	esInt3,x
.1c57	60		rts				rts
.1c58					Int32Sub:
.1c58	38		sec				sec
.1c59	b5 28		lda $28,x			lda 	esInt0,x
.1c5b	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1c5d	95 28		sta $28,x			sta 	esInt0,x
.1c5f	b5 30		lda $30,x			lda 	esInt1,x
.1c61	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1c63	95 30		sta $30,x			sta 	esInt1,x
.1c65	b5 38		lda $38,x			lda 	esInt2,x
.1c67	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1c69	95 38		sta $38,x			sta 	esInt2,x
.1c6b	b5 40		lda $40,x			lda 	esInt3,x
.1c6d	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1c6f	95 40		sta $40,x			sta 	esInt3,x
.1c71	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32multiply.asm

.1c72					Int32Multiply:
.1c72	e8		inx				inx 								; copy 2nd -> 3rd
.1c73	20 98 1c	jsr $1c98			jsr 	Int32CopyUp
.1c76	ca		dex				dex
.1c77	20 98 1c	jsr $1c98			jsr 	Int32CopyUp 				; copy 1st -> 2nd
.1c7a	20 4d 1d	jsr $1d4d			jsr 	Int32False 					; zero 1st.
.1c7d					_I32Loop:
.1c7d	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.1c7f	29 01		and #$01			and 	#1
.1c81	f0 03		beq $1c86			beq 	_I32NoAdd 					; if set
.1c83	20 3e 1c	jsr $1c3e			jsr 	Int32Add 					; add 2nd to 1st.
.1c86					_I32NoAdd:
.1c86	e8		inx				inx 								; shift 2nd left
.1c87	20 62 1d	jsr $1d62			jsr 	Int32ShiftLeft
.1c8a	e8		inx				inx  								; shift 3rd right
.1c8b	20 6b 1d	jsr $1d6b			jsr 	Int32ShiftRight
.1c8e	20 74 1d	jsr $1d74			jsr 	Int32Zero 					; check if zero.
.1c91	08		php				php 								; save status bits
.1c92	ca		dex				dex 	 							; point back to 1st
.1c93	ca		dex				dex
.1c94	28		plp				plp 								; get status bits
.1c95	d0 e6		bne $1c7d			bne 	_I32Loop 					; if non-zero keep going.
.1c97	60		rts				rts
.1c98					Int32CopyUp:
.1c98	b5 28		lda $28,x			lda 	esInt0,x
.1c9a	95 29		sta $29,x			sta 	esInt0+1,x
.1c9c	b5 30		lda $30,x			lda 	esInt1,x
.1c9e	95 31		sta $31,x			sta 	esInt1+1,x
.1ca0	b5 38		lda $38,x			lda 	esInt2,x
.1ca2	95 39		sta $39,x			sta 	esInt2+1,x
.1ca4	b5 40		lda $40,x			lda 	esInt3,x
.1ca6	95 41		sta $41,x			sta 	esInt3+1,x
.1ca8	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32tostr.asm

.1ca9					Int32ToString:
.1ca9	48		pha				pha 								; save base
.1caa	85 03		sta $03				sta 	tempShort 					; save target base.
.1cac	a9 00		lda #$00			lda 	#0
.1cae	8d a4 08	sta $08a4			sta 	IToSCount 					; clear character count.
.1cb1	98		tya				tya
.1cb2	48		pha				pha
.1cb3	a5 03		lda $03				lda 	tempShort 					; check if we are signed conversion
.1cb5	10 10		bpl $1cc7			bpl 	_I32TSUnsigned
.1cb7	48		pha				pha 								; save base on stack.
.1cb8	b5 40		lda $40,x			lda 	esInt3,x 					; is it actually negative
.1cba	10 08		bpl $1cc4			bpl 	_I32TSNoFlip
.1cbc	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.1cbe	20 f3 1c	jsr $1cf3			jsr 	I32WriteCharacter
.1cc1	20 07 1d	jsr $1d07			jsr 	Int32Negate 				; negate the value.
.1cc4					_I32TSNoFlip:
.1cc4	68		pla				pla 								; get the base back
.1cc5	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.1cc7					_I32TSUnsigned:
.1cc7	20 ce 1c	jsr $1cce			jsr 	I32DivideWrite 				; recursive code to output string.
.1cca	68		pla				pla
.1ccb	a8		tay				tay
.1ccc	68		pla				pla
.1ccd	60		rts				rts
.1cce					I32DivideWrite:
.1cce	48		pha				pha 								; save the divisor/base
.1ccf	e8		inx				inx 								; write in the dividing position.
.1cd0	20 5c 1d	jsr $1d5c			jsr 	Int32Set8Bit
.1cd3	ca		dex				dex
.1cd4	20 80 1b	jsr $1b80			jsr 	Int32UDivide 				; divide number by base.
.1cd7	68		pla				pla 								; get the base into Y
.1cd8	a8		tay				tay
.1cd9	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.1cdb	48		pha				pha
.1cdc	20 74 1d	jsr $1d74			jsr 	Int32Zero 					; is the result zero ?
.1cdf	f0 04		beq $1ce5			beq 	_I32NoRecurse 				; if so, don't recurse.
.1ce1	98		tya				tya 								; put base into A
.1ce2	20 ce 1c	jsr $1cce			jsr 	I32DivideWrite 				; and jsr the dividor recursively.
.1ce5					_I32NoRecurse:
.1ce5	68		pla				pla 								; get the remainder back
.1ce6	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.1ce8	90 02		bcc $1cec			bcc 	_I32NotHex
.1cea	69 06		adc #$06			adc 	#7-1
.1cec					_I32NotHex:
.1cec	18		clc				clc 								; make it ASCII
.1ced	69 30		adc #$30			adc 	#48
.1cef	20 f3 1c	jsr $1cf3			jsr 	I32WriteCharacter 			; write the character out
.1cf2	60		rts				rts 								; and exit.
.1cf3					I32WriteCharacter:
.1cf3	ac a4 08	ldy $08a4			ldy 	IToSCount 					; get position
.1cf6	91 04		sta ($04),y			sta 	(temp0),y 					; write out with trailing 0
.1cf8	c8		iny				iny
.1cf9	a9 00		lda #$00			lda 	#0
.1cfb	91 04		sta ($04),y			sta 	(temp0),y
.1cfd	ee a4 08	inc $08a4			inc 	IToSCount 					; bump count
.1d00	60		rts				rts
.1d01	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32unary.asm

.1d02					Int32Absolute:
.1d02	b5 40		lda $40,x			lda 	esInt3,x 					; use negate code if -ve.
.1d04	30 01		bmi $1d07			bmi 	Int32Negate
.1d06	60		rts				rts
.1d07					Int32Negate:
.1d07	38		sec				sec
.1d08	a9 00		lda #$00			lda 	#0
.1d0a	f5 28		sbc $28,x			sbc 	esInt0,x
.1d0c	95 28		sta $28,x			sta 	esInt0,x
.1d0e	a9 00		lda #$00			lda 	#0
.1d10	f5 30		sbc $30,x			sbc 	esInt1,x
.1d12	95 30		sta $30,x			sta 	esInt1,x
.1d14	a9 00		lda #$00			lda 	#0
.1d16	f5 38		sbc $38,x			sbc 	esInt2,x
.1d18	95 38		sta $38,x			sta 	esInt2,x
.1d1a	a9 00		lda #$00			lda 	#0
.1d1c	f5 40		sbc $40,x			sbc 	esInt3,x
.1d1e	95 40		sta $40,x			sta 	esInt3,x
.1d20	60		rts				rts
.1d21					Int32Not:
.1d21	b5 28		lda $28,x			lda 	esInt0,x
.1d23	49 ff		eor #$ff			eor 	#$FF
.1d25	95 28		sta $28,x			sta 	esInt0,x
.1d27	b5 30		lda $30,x			lda 	esInt1,x
.1d29	49 ff		eor #$ff			eor 	#$FF
.1d2b	95 30		sta $30,x			sta 	esInt1,x
.1d2d	b5 38		lda $38,x			lda 	esInt2,x
.1d2f	49 ff		eor #$ff			eor 	#$FF
.1d31	95 38		sta $38,x			sta 	esInt2,x
.1d33	b5 40		lda $40,x			lda 	esInt3,x
.1d35	49 ff		eor #$ff			eor 	#$FF
.1d37	95 40		sta $40,x			sta 	esInt3,x
.1d39	60		rts				rts
.1d3a					Int32Sign:
.1d3a	b5 40		lda $40,x			lda 	esInt3,x					; look at MSB
.1d3c	30 0b		bmi $1d49			bmi 	Int32True 					; if set return -1 (true)
.1d3e	20 74 1d	jsr $1d74			jsr 	Int32Zero 					; is it zero ?
.1d41	f0 0a		beq $1d4d			beq 	Int32False 					; if zero return 0 (false)
.1d43	20 4d 1d	jsr $1d4d			jsr 	Int32False 					; > 0 return 1
.1d46	f6 28		inc $28,x			inc 	esInt0,x
.1d48	60		rts				rts
.1d49					Int32True:
.1d49	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.1d4b	d0 02		bne $1d4f			bne 	Int32WriteAll
.1d4d					Int32False:
.1d4d	a9 00		lda #$00			lda 	#0
.1d4f					Int32WriteAll:
.1d4f	95 28		sta $28,x			sta 	esInt0,x
.1d51					Int32Write123:
.1d51	95 30		sta $30,x			sta 	esInt1,x
.1d53	95 38		sta $38,x			sta 	esInt2,x
.1d55	95 40		sta $40,x			sta 	esInt3,x
.1d57	a9 00		lda #$00			lda 	#$00						; and make it an integer
.1d59	95 20		sta $20,x			sta 	esType,x
.1d5b	60		rts				rts
.1d5c					Int32Set8Bit:
.1d5c	95 28		sta $28,x			sta 	esInt0,x
.1d5e	a9 00		lda #$00			lda 	#0
.1d60	f0 ef		beq $1d51			beq		Int32Write123
.1d62					Int32ShiftLeft:
.1d62	16 28		asl $28,x			asl 	esInt0,x
.1d64	36 30		rol $30,x			rol	 	esInt1,x
.1d66	36 38		rol $38,x			rol	 	esInt2,x
.1d68	36 40		rol $40,x			rol	 	esInt3,x
.1d6a	60		rts				rts
.1d6b					Int32ShiftRight:
.1d6b	56 40		lsr $40,x			lsr 	esInt3,x
.1d6d	76 38		ror $38,x			ror 	esInt2,x
.1d6f	76 30		ror $30,x			ror 	esInt1,x
.1d71	76 28		ror $28,x			ror 	esInt0,x
.1d73	60		rts				rts
.1d74					Int32Zero:
.1d74	b5 28		lda $28,x			lda 	esInt0,x
.1d76	15 30		ora $30,x			ora 	esInt1,x
.1d78	15 38		ora $38,x			ora 	esInt2,x
.1d7a	15 40		ora $40,x			ora 	esInt3,x
.1d7c	60		rts				rts
.1d7d					Int32Random:
.1d7d	98		tya				tya
.1d7e	48		pha				pha
.1d7f	a0 07		ldy #$07			ldy 	#7
.1d81	ad 88 08	lda $0888			lda 	Seed32+0
.1d84	d0 03		bne $1d89			bne 	_Random1
.1d86	a8		tay				tay
.1d87	a9 aa		lda #$aa			lda		#$AA
.1d89					_Random1:
.1d89	0a		asl a				asl 	a
.1d8a	2e 89 08	rol $0889			rol 	Seed32+1
.1d8d	2e 8a 08	rol $088a			rol 	Seed32+2
.1d90	2e 8b 08	rol $088b			rol 	Seed32+3
.1d93	90 02		bcc $1d97			bcc 	_Random2
.1d95	49 c5		eor #$c5			eor 	#$C5
.1d97					_Random2:
.1d97	88		dey				dey
.1d98	d0 ef		bne $1d89			bne 	_Random1
.1d9a	8d 88 08	sta $0888			sta 	Seed32+0
.1d9d	95 28		sta $28,x			sta 	esInt0,x
.1d9f	ad 89 08	lda $0889			lda 	Seed32+1
.1da2	95 30		sta $30,x			sta 	esInt1,x
.1da4	ad 8a 08	lda $088a			lda 	Seed32+2
.1da7	95 38		sta $38,x			sta 	esInt2,x
.1da9	ad 8b 08	lda $088b			lda 	Seed32+3
.1dac	95 40		sta $40,x			sta 	esInt3,x
.1dae	68		pla				pla
.1daf	a8		tay				tay
.1db0	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/utility/scanner.asm

.1db1					ScanForward:
.1db1	85 0a		sta $0a				sta 	temp3 						; save tokens to search in temp3/temp3+1
.1db3	86 0b		stx $0b				stx 	temp3+1
.1db5	a9 00		lda #$00			lda 	#0 							; temp2 counts structure levels.
.1db7	85 08		sta $08				sta 	temp2
.1db9	b1 00		lda ($00),y	_SFLoop:lda 	(codePtr),y 				; look at the high token.
.1dbb	c9 80		cmp #$80			cmp 	#$80
.1dbd	f0 13		beq $1dd2			beq 	_SFNextLine 				; if $80 go to next line.
.1dbf	b0 17		bcs $1dd8			bcs  	_SFFoundCommand				; if -ve its a token
.1dc1	c9 60		cmp #$60			cmp 	#$60 						; if $60 it's a string.
.1dc3	f0 04		beq $1dc9			beq 	_SFSkipString
.1dc5					_SFNextToken:
.1dc5	c8		iny				iny
.1dc6	4c b9 1d	jmp $1db9			jmp 	_SFLoop
.1dc9					_SFSkipString:
.1dc9	98		tya				tya
.1dca	c8		iny				iny
.1dcb	18		clc				clc
.1dcc	71 00		adc ($00),y			adc 	(codePtr),y
.1dce	a8		tay				tay
.1dcf	4c b9 1d	jmp $1db9			jmp 	_SFLoop
.1dd2					_SFNextLine:
.1dd2	20 89 13	jsr $1389			jsr 	CommandNextLine
.1dd5	4c b9 1d	jmp $1db9			jmp 	_SFLoop
.1dd8					_SFFoundCommand:
.1dd8	a5 08		lda $08				lda 	temp2 						; structure level is non-zero then don't check
.1dda	d0 0a		bne $1de6			bne 	_SFNoCheck
.1ddc	b1 00		lda ($00),y			lda 	(codePtr),y  				; get the token.
.1dde	c5 0a		cmp $0a				cmp 	temp3 						; if it matches either, then we win.
.1de0	f0 18		beq $1dfa			beq 	_SFFoundEnd
.1de2	c5 0b		cmp $0b				cmp 	temp3+1
.1de4	f0 14		beq $1dfa			beq 	_SFFoundEnd
.1de6					_SFNoCheck:
.1de6	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the token
.1de8	aa		tax				tax 								; get its type
.1de9	bd 5b 19	lda $195b,x			lda 	KeywordTypes-$80,x
.1dec	10 d7		bpl $1dc5			bpl		_SFNextToken 				; not a command
.1dee	38		sec				sec
.1def	e9 81		sbc #$81			sbc 	#$81 						; this is now -1 if close, 0 normal, 1 open.
.1df1	18		clc				clc
.1df2	65 08		adc $08				adc 	temp2 						; add to structure level
.1df4	85 08		sta $08				sta 	temp2
.1df6	30 04		bmi $1dfc			bmi		_SFBalance
.1df8	10 cb		bpl $1dc5			bpl 	_SFNextToken
.1dfa					_SFFoundEnd:
.1dfa	c8		iny				iny									; skip over the token
.1dfb	60		rts				rts
.1dfc					_SFBalance:
.1dfc	4c e3 18	jmp $18e3			jmp 	EHandlerClosure

;******  Return to file: basic.asm


;******  Processing file: common/utility/stack.asm

.1dff					StackOpen:
.1dff	85 03		sta $03				sta 	tempShort 					; save it
.1e01	29 0f		and #$0f			and 	#StackSizeMask 				; bytes to subtract.
.1e03	49 ff		eor #$ff			eor 	#$FF 						; add to stack pointer, 2's complement
.1e05	38		sec				sec
.1e06	65 0e		adc $0e				adc 	StackPtr
.1e08	85 0e		sta $0e				sta 	StackPtr
.1e0a	a5 0f		lda $0f				lda 	StackPtr+1
.1e0c	69 ff		adc #$ff			adc 	#$FF
.1e0e	85 0f		sta $0f				sta 	StackPtr+1
.1e10	98		tya				tya
.1e11	48		pha				pha
.1e12	a0 00		ldy #$00			ldy 	#0 							; write marker at offset 0
.1e14	a5 03		lda $03				lda 	tempShort
.1e16	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1e18	68		pla				pla
.1e19	a8		tay				tay
.1e1a	a5 11		lda $11				lda 	LowMemory+1 				; check memory available
.1e1c	c5 0f		cmp $0f				cmp 	StackPtr+1
.1e1e	b0 01		bcs $1e21			bcs		_SOMemory
.1e20	60		rts				rts
.1e21					_SOMemory:
.1e21	4c 18 19	jmp $1918			jmp 	EHandlerMemory
.1e24					StackCheck:
.1e24	84 03		sty $03				sty 	tempShort
.1e26	a0 00		ldy #$00			ldy 	#0 							; eor with marker
.1e28	51 0e		eor ($0e),y			eor 	(StackPtr),y
.1e2a	a4 03		ldy $03				ldy 	tempShort
.1e2c	c9 00		cmp #$00			cmp 	#0 							; set Z flag
.1e2e	60		rts				rts
.1e2f					StackClose:
.1e2f	98		tya				tya
.1e30	48		pha				pha
.1e31	a0 00		ldy #$00			ldy 	#0
.1e33	b1 0e		lda ($0e),y			lda 	(StackPtr),y 				; get type back
.1e35	29 0f		and #$0f			and 	#StackSizeMask 				; bytes to add
.1e37	18		clc				clc
.1e38	65 0e		adc $0e				adc 	StackPtr
.1e3a	85 0e		sta $0e				sta 	StackPtr
.1e3c	90 02		bcc $1e40			bcc 	_SCSkip
.1e3e	e6 0f		inc $0f				inc 	StackPtr+1
.1e40					_SCSkip:
.1e40	68		pla				pla
.1e41	a8		tay				tay
.1e42	60		rts				rts
.1e43					StackLoadPosition:
.1e43	a0 03		ldy #$03			ldy 	#3 							; read in codePtr from 3,2
.1e45	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.1e47	85 01		sta $01				sta 	codePtr+1
.1e49	88		dey				dey
.1e4a	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.1e4c	85 00		sta $00				sta 	codePtr
.1e4e	88		dey				dey
.1e4f	b1 0e		lda ($0e),y			lda 	(stackPtr),y 				; restore offset in line
.1e51	a8		tay				tay
.1e52	60		rts				rts
.1e53					StackSavePosition:
.1e53	98		tya				tya 								; get position in A
.1e54	a0 01		ldy #$01			ldy 	#1
.1e56	91 0e		sta ($0e),y			sta 	(stackPtr),y 				; write it out.
.1e58	48		pha				pha 								; save to stack
.1e59	c8		iny				iny 								; write line position
.1e5a	a5 00		lda $00				lda 	codePtr
.1e5c	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1e5e	c8		iny				iny
.1e5f	a5 01		lda $01				lda 	codePtr+1
.1e61	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1e63	68		pla				pla
.1e64	a8		tay				tay
.1e65	60		rts				rts
.1e66					StackPopLocals:
.1e66	a0 00		ldy #$00			ldy 	#0 							; check if TOS is a local record
.1e68	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.1e6a	c9 67		cmp #$67			cmp 	#SMLocal
.1e6c	d0 1c		bne $1e8a			bne 	_SPLExit
.1e6e	a0 05		ldy #$05			ldy 	#5 							; copy local address to temp0
.1e70	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.1e72	85 04		sta $04				sta 	temp0
.1e74	c8		iny				iny
.1e75	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.1e77	85 05		sta $05				sta 	temp0+1
.1e79	a0 04		ldy #$04			ldy 	#4 							; start copying back
.1e7b					_SPLLoop:
.1e7b	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.1e7d	88		dey				dey
.1e7e	91 04		sta ($04),y			sta 	(temp0),y
.1e80	c0 00		cpy #$00			cpy 	#0
.1e82	d0 f7		bne $1e7b			bne 	_SPLLoop
.1e84	20 2f 1e	jsr $1e2f			jsr 	StackClose 					; drop frame and try again
.1e87	4c 66 1e	jmp $1e66			jmp 	StackPopLocals
.1e8a					_SPLExit:
.1e8a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: variables/common/variables.asm

.1e8b					VariableAccess:
.1e8b	b1 00		lda ($00),y			lda 	(codePtr),y 				; check 20xx where x is 1..1A representing A-Z.
.1e8d	c9 1a		cmp #$1a			cmp 	#$1A 						; is this A-Z ?
.1e8f	b0 0c		bcs $1e9d			bcs 	_VANotBasic
.1e91	c8		iny				iny
.1e92	0a		asl a				asl 	a 							; x 4
.1e93	0a		asl a				asl 	a
.1e94	95 28		sta $28,x			sta 	esInt0,x 					; set up address
.1e96	a9 08		lda #$08			lda 	#RootVariables >> 8
.1e98	95 30		sta $30,x			sta 	esInt1,x
.1e9a	4c a0 1e	jmp $1ea0			jmp 	_VACheckModifier
.1e9d					_VANotBasic:
.1e9d	4c 8d 19	jmp $198d			jmp 	EHandlerNotImplemented
.1ea0					_VACheckModifier:
.1ea0					_VAExit:
.1ea0	a9 00		lda #$00			lda 	#0 							; clear the upper two bytes of variable/element address.
.1ea2	95 38		sta $38,x			sta 	esInt2,x
.1ea4	95 40		sta $40,x			sta 	esInt3,x
.1ea6	a9 80		lda #$80			lda 	#$80 						; it's a reference to an integer.
.1ea8	95 20		sta $20,x			sta 	esType,x
.1eaa	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: testing/code/99program.asm

>1eab						.align 256
.1f00					BasicProgram:
>1f00	0a					.byte $0a
>1f01	64					.byte $64
>1f02	00					.byte $00
>1f03	b4					.byte $b4
>1f04	17					.byte $17
>1f05	89					.byte $89
>1f06	71					.byte $71
>1f07	c3					.byte $c3
>1f08	7a					.byte $7a
>1f09	80					.byte $80
>1f0a	0a					.byte $0a
>1f0b	65					.byte $65
>1f0c	00					.byte $00
>1f0d	b3					.byte $b3
>1f0e	17					.byte $17
>1f0f	8e					.byte $8e
>1f10	72					.byte $72
>1f11	88					.byte $88
>1f12	70					.byte $70
>1f13	80					.byte $80
>1f14	0e					.byte $0e
>1f15	66					.byte $66
>1f16	00					.byte $00
>1f17	c6					.byte $c6
>1f18	17					.byte $17
>1f19	ac					.byte $ac
>1f1a	60					.byte $60
>1f1b	07					.byte $07
>1f1c	20					.byte $20
>1f1d	4f					.byte $4f
>1f1e	44					.byte $44
>1f1f	44					.byte $44
>1f20	00					.byte $00
>1f21	80					.byte $80
>1f22	13					.byte $13
>1f23	67					.byte $67
>1f24	00					.byte $00
>1f25	c2					.byte $c2
>1f26	c0					.byte $c0
>1f27	c6					.byte $c6
>1f28	17					.byte $17
>1f29	ac					.byte $ac
>1f2a	60					.byte $60
>1f2b	08					.byte $08
>1f2c	20					.byte $20
>1f2d	45					.byte $45
>1f2e	56					.byte $56
>1f2f	45					.byte $45
>1f30	4e					.byte $4e
>1f31	00					.byte $00
>1f32	c0					.byte $c0
>1f33	b8					.byte $b8
>1f34	80					.byte $80
>1f35	06					.byte $06
>1f36	6e					.byte $6e
>1f37	00					.byte $00
>1f38	b9					.byte $b9
>1f39	17					.byte $17
>1f3a	80					.byte $80
>1f3b	0c					.byte $0c
>1f3c	78					.byte $78
>1f3d	00					.byte $00
>1f3e	c6					.byte $c6
>1f3f	60					.byte $60
>1f40	07					.byte $07
>1f41	44					.byte $44
>1f42	4f					.byte $4f
>1f43	4e					.byte $4e
>1f44	45					.byte $45
>1f45	00					.byte $00
>1f46	80					.byte $80
>1f47	00					.byte $00

;******  Return to file: basic.asm


;******  End of listing
