
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -q --m65xx -L asm.out/basic.lst -l asm.out/basic.lbl -o asm.out/basic.prg basic.asm
; Fri Dec 11 20:53:18 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: boot/x16/01constants.inc

=8							DataStackSize = 8
=16							HashTableSize = 16
=$00							ZeroPageStart = $00
=$20							DataStackStart = $20
=$800							DataStart = $800					; must be on a page boundary.
=$1000							CodeBase = $1000
=$9e00							EndMemory = $9E00

;******  Return to file: basic.asm


;******  Processing file: boot/common/02data.inc

>0000					codePtr:.fill 		3 						; code ptr - extra byte for paging.
>0003					tempShort:.fill 	1 						; used for v.short term saving.
>0004					temp0:	.fill 		2
>0006					temp1:	.fill 		2
>0008					temp2:	.fill 		2
>000a					temp3:	.fill 		2
>000c					temp4:	.fill 		2
>000e					StackPtr:.fill 		2						; highest byte allocated, stack works down.
>0010					LowMemory:.fill 	2 						; next byte available working up
>0020					esType:	.fill 		DataStackSize 			; bit 7 any reference, bit 6 byte reference, bit 0 string.
>0028					esInt0:	.fill 		DataStackSize		 	; 32 bit integer, also used for string address
>0030					esInt1:	.fill 		DataStackSize			; (16 bit only)
>0038					esInt2:	.fill 		DataStackSize
>0040					esInt3:	.fill 		DataStackSize
=$28					esStrLow = esInt0 							; String address synonym
=$30					esStrHigh = esInt1
>0800							.align 	256  						; these two must be on one page.
.0800					RootVariables:
>0800							.fill 	26*4
.0868					HashTable:
>0868							.fill 	HashTableSize*2
.0888					Seed32:
>0888							.fill 	4
.088c					Buffer:
>088c							.fill 	20
.08a0					ClockTicks:
>08a0							.fill 	4
.08a4					IToSCount:
>08a4							.fill 	1
.08a5					ChrBuffer:
>08a5							.fill 	2
.08a7					PrintCRFlag:
>08a7							.fill 	1
.08a8					ArrayEnabled:
>08a8							.fill 	1
.08a9					ProcList:
>08a9							.fill 	2

;******  Return to file: basic.asm


;******  Processing file: boot/common/03stdmac.inc


;******  Return to file: basic.asm


;******  Processing file: boot/common/boot.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; initialise 6502 stac
.1002	9a		txs				txs
.1003	4c 64 10	jmp $1064			jmp 	ColdStart

;******  Return to file: basic.asm


;******  Processing file: extern/x16/x16hardware.asm

.1006					XTGetKey:
.1006	8a		txa				txa
.1007	48		pha				pha
.1008	98		tya				tya
.1009	48		pha				pha
.100a	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.100d	85 03		sta $03				sta 	tempShort
.100f	68		pla				pla
.1010	a8		tay				tay
.1011	68		pla				pla
.1012	aa		tax				tax
.1013	a5 03		lda $03				lda 	tempShort
.1015	60		rts				rts
.1016					XTUpdateClock:
.1016	48		pha				pha
.1017	8a		txa				txa
.1018	48		pha				pha
.1019	98		tya				tya
.101a	48		pha				pha
.101b	20 de ff	jsr $ffde			jsr 	$FFDE
.101e	8c a2 08	sty $08a2			sty 	ClockTicks+2
.1021	8e a1 08	stx $08a1			stx 	ClockTicks+1
.1024	8d a0 08	sta $08a0			sta 	ClockTicks
.1027	a9 00		lda #$00			lda 	#0
.1029	8d a3 08	sta $08a3			sta 	ClockTicks+3
.102c	68		pla				pla
.102d	a8		tay				tay
.102e	68		pla				pla
.102f	aa		tax				tax
.1030	68		pla				pla
.1031	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: extern/x16/x16print.asm

.1032					XTPrintAC:
.1032	c9 61		cmp #$61			cmp 	#"a"
.1034	90 1c		bcc $1052			bcc 	XTPrintA
.1036	c9 7b		cmp #$7b			cmp 	#"z"+1
.1038	b0 18		bcs $1052			bcs 	XTPrintA
.103a	48		pha				pha
.103b	49 20		eor #$20			eor 	#$20
.103d	20 52 10	jsr $1052			jsr 	XTPrintA
.1040	68		pla				pla
.1041	60		rts				rts
.1042					XTPrintCR:
.1042	48		pha				pha
.1043	a9 0d		lda #$0d			lda 	#13
.1045	20 52 10	jsr $1052			jsr 	XTPrintA
.1048	68		pla				pla
.1049	60		rts				rts
.104a					XTPrintTab:
.104a	48		pha				pha
.104b	a9 20		lda #$20			lda 	#32
.104d	20 52 10	jsr $1052			jsr 	XTPrintA
.1050	68		pla				pla
.1051	60		rts				rts
.1052					XTPrintA:
.1052	85 03		sta $03				sta 	tempShort
.1054	48		pha				pha
.1055	8a		txa				txa
.1056	48		pha				pha
.1057	98		tya				tya
.1058	48		pha				pha
.1059	a5 03		lda $03				lda 	tempShort
.105b	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.105e	68		pla				pla
.105f	a8		tay				tay
.1060	68		pla				pla
.1061	aa		tax				tax
.1062	68		pla				pla
.1063	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: interface/none/ifdummy.asm

.1064					ColdStart:
.1064	4c 0f 14	jmp $140f			jmp 	Command_RUN
.1067					WarmStart:
.1067	4c 67 10	jmp $1067			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: common/generated/keywords.inc

=$80					KWD_LESSLESSENDGREATERGREATER        = $80 ; 128
=$81					KWD_AND                              = $81 ; 129
=$82					KWD_OR                               = $82 ; 130
=$83					KWD_XOR                              = $83 ; 131
=$84					KWD_GREATER                          = $84 ; 132
=$85					KWD_LESS                             = $85 ; 133
=$86					KWD_GREATEREQUAL                     = $86 ; 134
=$87					KWD_LESSEQUAL                        = $87 ; 135
=$88					KWD_LESSGREATER                      = $88 ; 136
=$89					KWD_EQUAL                            = $89 ; 137
=$8a					KWD_PLUS                             = $8a ; 138
=$8b					KWD_MINUS                            = $8b ; 139
=$8c					KWD_ASTERISK                         = $8c ; 140
=$8d					KWD_SLASH                            = $8d ; 141
=$8e					KWD_PERCENT                          = $8e ; 142
=$8f					KWD_GREATERGREATER                   = $8f ; 143
=$90					KWD_LESSLESS                         = $90 ; 144
=$91					KWD_PLING                            = $91 ; 145
=$92					KWD_QUESTION                         = $92 ; 146
=$93					KWD_DOLLAR                           = $93 ; 147
=$94					KWD_TILDE                            = $94 ; 148
=$95					KWD_LPAREN                           = $95 ; 149
=$96					KWD_AMPERSAND                        = $96 ; 150
=$97					KWD_AT                               = $97 ; 151
=$98					KWD_LEN                              = $98 ; 152
=$99					KWD_SGN                              = $99 ; 153
=$9a					KWD_ABS                              = $9a ; 154
=$9b					KWD_RANDOM                           = $9b ; 155
=$9c					KWD_PAGE                             = $9c ; 156
=$9d					KWD_TRUE                             = $9d ; 157
=$9e					KWD_FALSE                            = $9e ; 158
=$9f					KWD_MIN                              = $9f ; 159
=$a0					KWD_MAX                              = $a0 ; 160
=$a1					KWD_SYS                              = $a1 ; 161
=$a2					KWD_CODE                             = $a2 ; 162
=$a3					KWD_TIMER                            = $a3 ; 163
=$a4					KWD_EVENT                            = $a4 ; 164
=$a5					KWD_GET                              = $a5 ; 165
=$a6					KWD_JOYPERIODX                       = $a6 ; 166
=$a7					KWD_JOYPERIODY                       = $a7 ; 167
=$a8					KWD_JOYPERIODBTN                     = $a8 ; 168
=$a9					KWD_INKEY                            = $a9 ; 169
=$aa					KWD_ALLOC                            = $aa ; 170
=$ab					KWD_CHR                              = $ab ; 171
=$ac					KWD_COMMA                            = $ac ; 172
=$ad					KWD_SEMICOLON                        = $ad ; 173
=$ae					KWD_RPAREN                           = $ae ; 174
=$af					KWD_PLUSPLUS                         = $af ; 175
=$b0					KWD_MINUSMINUS                       = $b0 ; 176
=$b1					KWD_LSQPAREN                         = $b1 ; 177
=$b2					KWD_RSQPAREN                         = $b2 ; 178
=$b3					KWD_IF                               = $b3 ; 179
=$b4					KWD_FOR                              = $b4 ; 180
=$b5					KWD_REPEAT                           = $b5 ; 181
=$b6					KWD_PROC                             = $b6 ; 182
=$b7					KWD_WHILE                            = $b7 ; 183
=$b8					KWD_ENDIF                            = $b8 ; 184
=$b9					KWD_NEXT                             = $b9 ; 185
=$ba					KWD_UNTIL                            = $ba ; 186
=$bb					KWD_ENDPROC                          = $bb ; 187
=$bc					KWD_WEND                             = $bc ; 188
=$bd					KWD_REM                              = $bd ; 189
=$be					KWD_LET                              = $be ; 190
=$bf					KWD_SQUOTE                           = $bf ; 191
=$c0					KWD_COLON                            = $c0 ; 192
=$c1					KWD_THEN                             = $c1 ; 193
=$c2					KWD_ELSE                             = $c2 ; 194
=$c3					KWD_TO                               = $c3 ; 195
=$c4					KWD_STEP                             = $c4 ; 196
=$c5					KWD_VDU                              = $c5 ; 197
=$c6					KWD_PRINT                            = $c6 ; 198
=$c7					KWD_CALL                             = $c7 ; 199
=$c8					KWD_LOCAL                            = $c8 ; 200
=$c9					KWD_GOTO                             = $c9 ; 201
=$ca					KWD_GOSUB                            = $ca ; 202
=$cb					KWD_RETURN                           = $cb ; 203
=$cc					KWD_ASSERT                           = $cc ; 204
=$cd					KWD_STOP                             = $cd ; 205
=$ce					KWD_END                              = $ce ; 206
=$cf					KWD_DIM                              = $cf ; 207
=$d0					KWD_CLEAR                            = $d0 ; 208
=$d1					KWD_LOAD                             = $d1 ; 209
=$d2					KWD_SAVE                             = $d2 ; 210
=$d3					KWD_LIST                             = $d3 ; 211
=$d4					KWD_NEW                              = $d4 ; 212
=$d5					KWD_RUN                              = $d5 ; 213

;******  Return to file: basic.asm


;******  Processing file: common/math/intmacros.inc


;******  Return to file: basic.asm


;******  Processing file: common/utility/stack.inc

=$14					SMGosub = $14 								; gosub marker (4 bytes, marker + position)
=$24					SMRepeat = $24 								; repeat marker (4 bytes, marker + position)
=$34					SMWhile = $34 								; while marker (4 bytes, marker + position)
=$4b					SMFor = $4B 								; for marker (11 bytes, see for.asm)
=$54					SMProcedure = $54 							; procedure marker (4 bytes, marker + position)
=$67					SMLocal = $67 								; local marker (7 bytes, marker, address, data)
=$0f					StackSizeMask = $0F 						; converts marker to bytes required.

;******  Return to file: basic.asm


;******  Processing file: common/commands/assert.asm

.106a					Command_Assert:
.106a	20 96 16	jsr $1696			jsr 	EvaluateBaseDeRef			; evaluate the thing being asserted.
.106d	20 61 1e	jsr $1e61			jsr 	Int32Zero 					; check if zero
.1070	f0 01		beq $1073			beq 	_CAError
.1072	60		rts				rts
.1073					_CAError:
.1073	4c 96 19	jmp $1996			jmp 	EHandlerAssert

;******  Return to file: basic.asm


;******  Processing file: common/commands/clear.asm

.1076					FindEnd:
.1076	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.1078	85 04		sta $04				sta 	temp0
.107a	a9 22		lda #$22			lda 	#(BasicProgram) >> 8
.107c	85 05		sta $05				sta 	1+(temp0)
.107e	98		tya				tya
.107f	48		pha				pha
.1080	a0 00		ldy #$00	_FELoop:ldy 	#0 							; look at offset
.1082	b1 04		lda ($04),y			lda 	(temp0),y
.1084	f0 0c		beq $1092			beq 	_FEExit 					; end if zero
.1086	18		clc				clc 								; add to position.
.1087	65 04		adc $04				adc 	temp0
.1089	85 04		sta $04				sta 	temp0
.108b	90 f3		bcc $1080			bcc 	_FELoop
.108d	e6 05		inc $05				inc 	temp0+1
.108f	4c 80 10	jmp $1080			jmp 	_FELoop
.1092					_FEExit:
.1092	68		pla				pla
.1093	a8		tay				tay
.1094	60		rts				rts
.1095					CommandClear:
.1095	8a		txa				txa
.1096	48		pha				pha
.1097	20 76 10	jsr $1076			jsr 	FindEnd 					; find end of memory
.109a	e6 04		inc $04				inc 	temp0 						; add 1, first free byte
.109c	d0 02		bne $10a0			bne 	_CCSkip
.109e	e6 05		inc $05				inc 	temp0+1
.10a0	a5 04		lda $04		_CCSkip:lda 	temp0 						; copy into low memory
.10a2	85 10		sta $10				sta 	LowMemory
.10a4	a5 05		lda $05				lda 	temp0+1
.10a6	85 11		sta $11				sta 	LowMemory+1
.10a8	a9 00		lda #$00			lda 	#(EndMemory) & $FF
.10aa	85 0e		sta $0e				sta 	StackPtr
.10ac	a9 9e		lda #$9e			lda 	#(EndMemory) >> 8
.10ae	85 0f		sta $0f				sta 	1+(StackPtr)
.10b0	a2 00		ldx #$00			ldx 	#0 							; blank hash table
.10b2	8a		txa				txa
.10b3					_CCErase:
.10b3	9d 68 08	sta $0868,x			sta 	HashTable,x
.10b6	e8		inx				inx
.10b7	e0 20		cpx #$20			cpx 	#HashTableSize*2
.10b9	d0 f8		bne $10b3			bne 	_CCErase
.10bb	a9 01		lda #$01			lda		#1 							; array works.
.10bd	8d a8 08	sta $08a8			sta 	ArrayEnabled
.10c0	68		pla				pla
.10c1	aa		tax				tax
.10c2	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/dim.asm

.10c3					Command_Dim:
.10c3	a9 00		lda #$00			lda 	#0 							; stops the term decoding array dim a(5) would return ref
.10c5	8d a8 08	sta $08a8			sta 	ArrayEnabled 				; to A(5) otherwise :)
.10c8	a9 07		lda #$07			lda 	#7							; get a term
.10ca	aa		tax				tax
.10cb	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX
.10ce	b5 20		lda $20,x			lda 	esType,x 					; get type
.10d0	c9 80		cmp #$80			cmp 	#$80 						; it must be an integer reference.
.10d2	d0 47		bne $111b			bne 	_CDSyntax
.10d4	8d a8 08	sta $08a8			sta 	ArrayEnabled 				; reenable normal array behaviour.
.10d7	b5 28		lda $28,x			lda 	esInt0,x 					; get variable addr -> temp0
.10d9	85 04		sta $04				sta 	temp0
.10db	b5 30		lda $30,x			lda 	esInt1,x
.10dd	85 05		sta $05				sta 	temp0+1
.10df	98		tya				tya
.10e0	48		pha				pha
.10e1	a0 00		ldy #$00			ldy 	#0
.10e3	a5 10		lda $10				lda 	LowMemory
.10e5	91 04		sta ($04),y			sta 	(temp0),y
.10e7	c8		iny				iny
.10e8	a5 11		lda $11				lda 	LowMemory+1
.10ea	91 04		sta ($04),y			sta 	(temp0),y
.10ec	c8		iny				iny
.10ed	a9 00		lda #$00			lda 	#0
.10ef	91 04		sta ($04),y			sta 	(temp0),y
.10f1	c8		iny				iny
.10f2	91 04		sta ($04),y			sta 	(temp0),y
.10f4	68		pla				pla
.10f5	a8		tay				tay
.10f6	20 96 14	jsr $1496			jsr 	CheckLeftParen 				; get left bracket
.10f9	20 9c 16	jsr $169c			jsr 	EvaluateTOSDeref 			; get the size to dimension
.10fc	20 a8 14	jsr $14a8			jsr 	CheckRightParen 			; do the right hand parenthesis
.10ff	b5 40		lda $40,x			lda 	esInt3,x 					; if -ve do not process.
.1101	30 0c		bmi $110f			bmi 	_CDNoSizeCalc
.1103	f6 28		inc $28,x			inc 	esInt0,x 					; increment size by 1 (zero base so dim a(10) is 11 elements)
.1105	d0 02		bne $1109			bne 	_CDNoBump
.1107	f6 30		inc $30,x			inc 	esInt1,x
.1109					_CDNoBump:
.1109	20 4f 1e	jsr $1e4f			jsr 	Int32ShiftLeft 				; x 4 (count => bytes)
.110c	20 4f 1e	jsr $1e4f			jsr 	Int32ShiftLeft
.110f					_CDNoSizeCalc:
.110f	20 1e 11	jsr $111e			jsr 	AllocMemStackCount 			; allocate that many bytes as per TOS.
.1112	b1 00		lda ($00),y			lda 	(codePtr),y
.1114	c8		iny				iny
.1115	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; check if comma follows.
.1117	f0 aa		beq $10c3			beq 	Command_DIM 				; if so do more DIM.
.1119	88		dey				dey
.111a					_CDExit:
.111a	60		rts				rts
.111b					_CDSyntax:
.111b	4c a7 1a	jmp $1aa7			jmp 	EHandlerSyntax
.111e					AllocMemStackCount:
.111e	b5 40		lda $40,x			lda 	esInt3,x 					; if -ve do not advance lowmem pointer
.1120	30 19		bmi $113b			bmi 	_AMSCExit
.1122	d0 18		bne $113c			bne 	AllocError 					; otherwise 2 MSB must be zero, 64k RAM space.
.1124	b5 38		lda $38,x			lda 	esInt2,x
.1126	d0 14		bne $113c			bne 	AllocError
.1128	18		clc				clc
.1129	b5 28		lda $28,x			lda 	esInt0,x 					; add size to pos.
.112b	65 10		adc $10				adc 	LowMemory
.112d	85 10		sta $10				sta 	LowMemory
.112f	b5 30		lda $30,x			lda 	esInt1,x
.1131	65 11		adc $11				adc 	LowMemory+1
.1133	85 11		sta $11				sta 	LowMemory+1
.1135	b0 05		bcs $113c			bcs 	AllocError 					; overflow.
.1137	c5 0f		cmp $0f				cmp 	StackPtr+1 					; got into SP page.
.1139	b0 01		bcs $113c			bcs 	AllocError
.113b					_AMSCExit:
.113b	60		rts				rts
.113c					AllocError:
.113c	4c 05 1a	jmp $1a05			jmp 	EHandlerMemory

;******  Return to file: basic.asm


;******  Processing file: common/commands/for.asm

.113f					Command_FOR:
.113f	a9 4b		lda #$4b			lda 	#SMFor 						; allocate the space.
.1141	20 43 20	jsr $2043			jsr 	StackOpen
.1144	20 c9 12	jsr $12c9			jsr 	Command_LET 				; do the same as LET.
.1147	20 a2 14	jsr $14a2			jsr 	CheckTO 					; check TO something.
.114a	a2 01		ldx #$01			ldx 	#1 							; keep the variable address in stack 0
.114c	20 9c 16	jsr $169c			jsr 	EvaluateTOSDeRef			; get terminal value in stack 1
.114f	98		tya				tya
.1150	48		pha				pha
.1151	a0 04		ldy #$04			ldy 	#4
.1153	a5 28		lda $28				lda		esInt0 						; the address of the index into 4 and 5
.1155	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1157	c8		iny				iny
.1158	a5 30		lda $30				lda		esInt1
.115a	91 0e		sta ($0e),y			sta 	(StackPtr),y
.115c	c8		iny				iny
.115d	a9 01		lda #$01			lda 	#1  						; the default step in 6
.115f	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1161	c8		iny				iny
.1162	a5 29		lda $29				lda		esInt0+1 					; terminal value in 7 to 11.
.1164	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1166	c8		iny				iny
.1167	a5 31		lda $31				lda		esInt1+1
.1169	91 0e		sta ($0e),y			sta 	(StackPtr),y
.116b	c8		iny				iny
.116c	a5 39		lda $39				lda		esInt2+1
.116e	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1170	c8		iny				iny
.1171	a5 41		lda $41				lda		esInt3+1
.1173	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1175	68		pla				pla
.1176	a8		tay				tay
.1177	b1 00		lda ($00),y			lda 	(codePtr),y 				; followed by STEP.
.1179	c9 c4		cmp #$c4			cmp 	#KWD_STEP
.117b	d0 0e		bne $118b			bne 	_CFDone
.117d	c8		iny				iny									; skip over step.
.117e	20 9c 16	jsr $169c			jsr 	EvaluateTOSDeref 			; get step
.1181	98		tya				tya
.1182	48		pha				pha
.1183	b5 28		lda $28,x			lda 	esInt0,x 					; copy it into step (bit lazy here)
.1185	a0 06		ldy #$06			ldy 	#6
.1187	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1189	68		pla				pla
.118a	a8		tay				tay
.118b					_CFDone:
.118b	20 97 20	jsr $2097			jsr 	StackSavePosition 			; save position.
.118e	60		rts				rts
.118f					Command_NEXT:
.118f	a9 4b		lda #$4b			lda 	#SMFor 						; check NEXT
.1191	20 68 20	jsr $2068			jsr 	StackCheck
.1194	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it NEXT <index>
.1196	30 1e		bmi $11b6			bmi 	_CNNoIndex
.1198	c9 60		cmp #$60			cmp 	#$60
.119a	b0 1a		bcs $11b6			bcs 	_CNNoIndex
.119c	a2 00		ldx #$00			ldx 	#0 							; start on stack
.119e	a9 07		lda #$07			lda 	#7  						; get a term
.11a0	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX 			; this is the variable/parameter to localise.
.11a3	98		tya				tya
.11a4	48		pha				pha
.11a5	a0 04		ldy #$04			ldy 	#4 							; check same variable
.11a7	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.11a9	d5 28		cmp $28,x			cmp 	esInt0,x
.11ab	d0 72		bne $121f			bne 	_CNBadIndex
.11ad	c8		iny				iny
.11ae	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.11b0	d5 30		cmp $30,x			cmp 	esInt1,x
.11b2	d0 6b		bne $121f			bne 	_CNBadIndex
.11b4	68		pla				pla
.11b5	a8		tay				tay
.11b6					_CNNoIndex:
.11b6	98		tya				tya
.11b7	48		pha				pha
.11b8	a0 04		ldy #$04			ldy 	#4 							; make temp0 point to the index
.11ba	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.11bc	85 04		sta $04				sta 	temp0
.11be	c8		iny				iny
.11bf	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.11c1	85 05		sta $05				sta 	temp0+1
.11c3	c8		iny				iny
.11c4	a2 00		ldx #$00			ldx 	#0 							; X is the sign of the step.
.11c6	b1 0e		lda ($0e),y			lda 	(StackPtr),y 				; get the step.
.11c8	85 09		sta $09				sta 	temp2+1 					; save for later.
.11ca	10 01		bpl $11cd			bpl 	_CNSignX
.11cc	ca		dex				dex
.11cd					_CNSignX:
.11cd	18		clc				clc 								; add to the LSB
.11ce	a0 00		ldy #$00			ldy 	#0
.11d0	71 04		adc ($04),y			adc 	(temp0),y
.11d2	91 04		sta ($04),y			sta 	(temp0),y
.11d4					_CNPropogate:
.11d4	c8		iny				iny  								; add the sign extended in X to the rest.
.11d5	8a		txa				txa
.11d6	71 04		adc ($04),y			adc 	(temp0),y
.11d8	91 04		sta ($04),y			sta 	(temp0),y
.11da	c8		iny				iny
.11db	8a		txa				txa
.11dc	71 04		adc ($04),y			adc 	(temp0),y
.11de	91 04		sta ($04),y			sta 	(temp0),y
.11e0	c8		iny				iny
.11e1	8a		txa				txa
.11e2	71 04		adc ($04),y			adc 	(temp0),y
.11e4	91 04		sta ($04),y			sta 	(temp0),y
.11e6	18		clc				clc 								; point temp1 to the terminal value.
.11e7	a5 0e		lda $0e				lda 	StackPtr
.11e9	69 07		adc #$07			adc 	#7
.11eb	85 06		sta $06				sta 	temp1
.11ed	a9 00		lda #$00			lda 	#0
.11ef	85 08		sta $08				sta 	temp2 						; clear temp2, which is the OR of all the subtractions.
.11f1	a8		tay				tay 								; and clear the Y register again.
.11f2	65 0f		adc $0f				adc 	StackPtr+1
.11f4	85 07		sta $07				sta 	temp1+1
.11f6	38		sec				sec 								; calculate current - limit oring interim values.
.11f7	20 29 12	jsr $1229			jsr 	_CNCompare
.11fa	20 29 12	jsr $1229			jsr 	_CNCompare
.11fd	20 29 12	jsr $1229			jsr 	_CNCompare
.1200	20 29 12	jsr $1229			jsr 	_CNCompare
.1203	50 02		bvc $1207			bvc 	_CNNoOverflow 				; converts to a signed comparison on the sign bit.
.1205	49 80		eor #$80			eor 	#$80
.1207					_CNNoOverflow:
.1207	a4 09		ldy $09				ldy 	temp2+1						; get step back
.1209	30 17		bmi $1222			bmi 	_CNCheckDownto
.120b	c9 00		cmp #$00			cmp 	#0
.120d	30 0a		bmi $1219			bmi 	_CNLoopRound 				; loop round if < =
.120f	a5 08		lda $08				lda 	temp2
.1211	f0 06		beq $1219			beq 	_CNLoopRound
.1213					_CNLoopExit:
.1213	68		pla				pla
.1214	a8		tay				tay
.1215	20 73 20	jsr $2073			jsr		StackClose 					; delete from stack and continue
.1218	60		rts				rts
.1219					_CNLoopRound:
.1219	68		pla				pla
.121a	a8		tay				tay
.121b	20 87 20	jsr $2087			jsr 	StackLoadPosition			; go back to the loop top
.121e	60		rts				rts
.121f					_CNBadIndex:
.121f	4c a7 19	jmp $19a7			jmp 	EHandlerBadIndex
.1222					_CNCheckDownto:
.1222	c9 00		cmp #$00			cmp 	#0
.1224	10 f3		bpl $1219			bpl 	_CNLoopRound
.1226	4c 13 12	jmp $1213			jmp 	_CNLoopExit
.1229					_CNCompare:
.1229	b1 04		lda ($04),y			lda 	(temp0),y 					; do the subtraction - compare don't care about answer
.122b	f1 06		sbc ($06),y			sbc 	(temp1),y
.122d	05 08		ora $08				ora 	temp2 						; Or into temp2 (does not affect carry)
.122f	85 08		sta $08				sta 	temp2
.1231	c8		iny				iny
.1232	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/gosub.asm

.1233					Command_Gosub:
.1233	20 96 16	jsr $1696			jsr 	EvaluateBaseDeRef			; get the target line #
.1236	a9 14		lda #$14			lda 	#SMGosub 					; gosub marker allocate 4 bytes.
.1238	20 43 20	jsr $2043			jsr 	StackOpen 					; create on stack.
.123b	20 97 20	jsr $2097			jsr 	StackSavePosition 			; save position.
.123e	4c 55 12	jmp $1255			jmp 	GotoTOS 					; and use the GOTO code.
.1241					Command_Return:
.1241	a9 14		lda #$14			lda 	#SMGosub 					; check the stack matches
.1243	20 68 20	jsr $2068			jsr 	StackCheck
.1246	d0 07		bne $124f			bne 	_RTError
.1248	20 87 20	jsr $2087			jsr 	StackLoadPosition 			; load the position back
.124b	20 73 20	jsr $2073			jsr 	StackClose 					; close the frame.
.124e	60		rts				rts
.124f					_RTError:
.124f	4c 1c 1a	jmp $1a1c			jmp 	EHandlerNoGosub

;******  Return to file: basic.asm


;******  Processing file: common/commands/goto.asm

.1252					Command_Goto:
.1252	20 96 16	jsr $1696			jsr 	EvaluateBaseDeRef			; get the target line #
.1255					GotoTOS:
.1255	20 68 12	jsr $1268			jsr 	FindGoto
.1258	90 0b		bcc $1265			bcc 	GotoError 					; not found
.125a	a5 04		lda $04				lda		temp0 						; copy new line address
.125c	85 00		sta $00				sta 	codePtr
.125e	a5 05		lda $05				lda 	temp0+1
.1260	85 01		sta $01				sta 	codePtr+1
.1262	a0 03		ldy #$03			ldy 	#3 							; first token.
.1264	60		rts				rts
.1265					GotoError:
.1265	4c f5 19	jmp $19f5			jmp 	EHandlerLineNumber
.1268					FindGoto:
.1268	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.126a	85 04		sta $04				sta 	temp0
.126c	a9 22		lda #$22			lda 	#(BasicProgram) >> 8
.126e	85 05		sta $05				sta 	1+(temp0)
.1270					_FGLoop:
.1270	a0 00		ldy #$00			ldy 	#0 							; look at link
.1272	b1 04		lda ($04),y			lda 	(temp0),y
.1274	18		clc				clc
.1275	f0 0f		beq $1286			beq 	_FGExit
.1277	c8		iny				iny 								; compare line.low
.1278	b1 04		lda ($04),y			lda 	(temp0),y
.127a	d5 28		cmp $28,x			cmp 	esInt0,x
.127c	d0 09		bne $1287			bne 	_FGNext
.127e	c8		iny				iny 								; compare line.high
.127f	b1 04		lda ($04),y			lda 	(temp0),y
.1281	d5 30		cmp $30,x			cmp 	esInt1,x
.1283	d0 02		bne $1287			bne 	_FGNext
.1285	38		sec				sec
.1286					_FGExit:
.1286	60		rts				rts
.1287					_FGNext:
.1287	a0 00		ldy #$00			ldy 	#0
.1289	18		clc				clc
.128a	b1 04		lda ($04),y			lda 	(temp0),y
.128c	65 04		adc $04				adc 	temp0
.128e	85 04		sta $04				sta 	temp0
.1290	90 de		bcc $1270			bcc 	_FGLoop
.1292	e6 05		inc $05				inc 	temp0+1
.1294	4c 70 12	jmp $1270			jmp 	_FGLoop

;******  Return to file: basic.asm


;******  Processing file: common/commands/if.asm

.1297					Command_IF:
.1297	20 96 16	jsr $1696			jsr 	EvaluateBaseDeRef			; get the target address
.129a	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by THEN ?
.129c	c9 c1		cmp #$c1			cmp 	#KWD_THEN
.129e	d0 15		bne $12b5			bne 	StructureIF
.12a0	c8		iny				iny 								; skip THEN
.12a1	20 61 1e	jsr $1e61			jsr 	Int32Zero 					; is it true ?
.12a4	f0 0c		beq $12b2			beq 	_IfFalse
.12a6	b1 00		lda ($00),y			lda 	(codePtr),y 				; if THEN <const> do GOTO.
.12a8	30 04		bmi $12ae			bmi 	_CIFExit
.12aa	c9 70		cmp #$70			cmp 	#$70
.12ac	b0 01		bcs $12af			bcs 	_CIFGoto
.12ae					_CIFExit:
.12ae	60		rts				rts 								; otherwise carry on.
.12af					_CIFGoto:
.12af	4c 52 12	jmp $1252			jmp 	Command_GOTO
.12b2					_IfFalse:
.12b2	4c 30 14	jmp $1430			jmp 	CommandNextLine
.12b5					StructureIF:
.12b5	20 61 1e	jsr $1e61			jsr 	Int32Zero 					; is it true ?
.12b8	f0 01		beq $12bb			beq 	_SIFSkip 					; if non-zero then skip to ELSE/ENDIF
.12ba	60		rts				rts 								; else continue.
.12bb					_SIFSkip:
.12bb	a9 c2		lda #$c2			lda	 	#KWD_ELSE 					; test failed, go to ELSE or ENDIF whichever comes first.
.12bd	a2 b8		ldx #$b8			ldx 	#KWD_ENDIF
.12bf	4c f5 1f	jmp $1ff5			jmp		ScanForward
.12c2					Command_ELSE:
.12c2	a2 b8		ldx #$b8			ldx 	#KWD_ENDIF
.12c4	8a		txa				txa
.12c5	4c f5 1f	jmp $1ff5			jmp		ScanForward
.12c8					Command_ENDIF:
.12c8	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/let.asm

.12c9					Command_LET:
.12c9	a2 00		ldx #$00			ldx 	#0 							; start on stack
.12cb	a9 04		lda #$04			lda 	#4  						; this means ! ? and $ binary operators only work.
.12cd	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX 			; this is the LHS
.12d0	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.12d2	10 2f		bpl $1303			bpl 	_CLSyntax 					; if not, syntax error.
.12d4	20 9c 14	jsr $149c			jsr 	CheckEquals 				; check equals follows.
.12d7	e8		inx				inx 								; get the right hand side.
.12d8	20 9c 16	jsr $169c			jsr 	EvaluateTOSDeRef
.12db	ca		dex				dex
.12dc	b5 28		lda $28,x			lda 	esInt0,x 					; copy target address to temp0
.12de	85 04		sta $04				sta 	temp0
.12e0	b5 30		lda $30,x			lda 	esInt1,x
.12e2	85 05		sta $05				sta 	temp0+1
.12e4	b5 20		lda $20,x			lda 	esType,x 					; what sort of reference ?
.12e6	0a		asl a				asl 	a 							; will now be $00 integer $80 byte $02 string.
.12e7	f0 22		beq $130b			beq 	_CLIntCopy
.12e9	30 1b		bmi $1306			bmi 	_CLByteCopy
.12eb	b5 29		lda $29,x			lda 	esInt0+1,x 					; source -> temp1
.12ed	85 06		sta $06				sta 	temp1
.12ef	b5 31		lda $31,x			lda 	esInt1+1,x
.12f1	85 07		sta $07				sta 	temp1+1
.12f3	98		tya				tya
.12f4	48		pha				pha
.12f5	a0 00		ldy #$00			ldy 	#0
.12f7					_CLStringCopy:
.12f7	b1 06		lda ($06),y			lda 	(temp1),y
.12f9	91 04		sta ($04),y			sta 	(temp0),y
.12fb	f0 03		beq $1300			beq 	_CLCopyExit 				; copied trailing NULL
.12fd	c8		iny				iny
.12fe	d0 f7		bne $12f7			bne 	_CLStringCopy 				; it could run riot.
.1300					_CLCopyExit:
.1300	68		pla				pla
.1301	a8		tay				tay
.1302	60		rts				rts
.1303					_CLSyntax:
.1303	4c a7 1a	jmp $1aa7			jmp 	EHandlerSyntax
.1306					_CLByteCopy:
.1306	b5 29		lda $29,x			lda 	esInt0+1,x 					; get the byte to write.
.1308	81 04		sta ($04,x)			sta 	(temp0,x)					; write, taking advantage of X = 0
.130a	60		rts				rts
.130b					_CLIntCopy:
.130b	e8		inx				inx
.130c	20 10 13	jsr $1310			jsr 	CopyTOSToTemp0
.130f	60		rts				rts
.1310					CopyTOSToTemp0:
.1310	98		tya				tya
.1311	48		pha				pha
.1312	a0 00		ldy #$00			ldy 	#0
.1314	b5 28		lda $28,x			lda 	esInt0,x
.1316	91 04		sta ($04),y			sta 	(temp0),y
.1318	c8		iny				iny
.1319	b5 30		lda $30,x			lda 	esInt1,x
.131b	91 04		sta ($04),y			sta 	(temp0),y
.131d	c8		iny				iny
.131e	b5 38		lda $38,x			lda 	esInt2,x
.1320	91 04		sta ($04),y			sta 	(temp0),y
.1322	c8		iny				iny
.1323	b5 40		lda $40,x			lda 	esInt3,x
.1325	91 04		sta ($04),y			sta 	(temp0),y
.1327	68		pla				pla
.1328	a8		tay				tay
.1329	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/new.asm

.132a					Command_New:
.132a	a9 00		lda #$00			lda 	#0 							; clear program
.132c	8d 00 22	sta $2200			sta 	BasicProgram
.132f	4c 95 10	jmp $1095			jmp 	CommandClear				; clear variables etc.

;******  Return to file: basic.asm


;******  Processing file: common/commands/print.asm

.1332					Command_Print:
.1332					_CPRLoop:
.1332	a9 00		lda #$00			lda 	#0 							; zero the print CRFlag
.1334					_CPRSetFlag:
.1334	8d a7 08	sta $08a7			sta 	PrintCRFlag
.1337	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token.
.1339	c9 80		cmp #$80			cmp 	#$80						; if EOL exit.
.133b	f0 5d		beq $139a			beq 	_CPRExit
.133d	c9 c0		cmp #$c0			cmp 	#KWD_COLON 					; if colon exit
.133f	f0 59		beq $139a			beq 	_CPRExit
.1341	c9 60		cmp #$60			cmp 	#$60 						; if $60  it is a string.
.1343	f0 38		beq $137d			beq 	_CPRString
.1345	c9 00		cmp #$00			cmp 	#$00 						; if -ve go to token
.1347	30 04		bmi $134d			bmi 	_CPRToken
.1349	c9 70		cmp #$70			cmp 	#$70 						; is it a number, if so print as decimal.
.134b	b0 14		bcs $1361			bcs 	_CPRDecimal
.134d					_CPRToken:
.134d	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the token ID and skip it.
.134f	c8		iny				iny
.1350	c9 ad		cmp #$ad			cmp 	#KWD_SEMICOLON 				; semicolon goes to set flag which is now non zero
.1352	f0 e0		beq $1334			beq 	_CPRSetFlag
.1354	c9 bf		cmp #$bf			cmp 	#KWD_SQUOTE 				; single quote is CR.
.1356	f0 34		beq $138c			beq 	_CPRNewLine
.1358	c9 96		cmp #$96			cmp 	#KWD_AMPERSAND 				; &x means print in hex
.135a	f0 09		beq $1365			beq 	_CPRHexaDecimal
.135c	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; comma is tab (possibly space)
.135e	f0 32		beq $1392			beq 	_CPRTab
.1360	88		dey				dey 								; undo the skip.
.1361					_CPRDecimal:
.1361	a9 8a		lda #$8a			lda 	#10+128
.1363	d0 3e		bne $13a3			bne 	_CPRPrintInteger
.1365					_CPRHexaDecimal:
.1365	a9 10		lda #$10			lda 	#16
.1367	d0 3a		bne $13a3			bne 	_CPRPrintInteger
.1369					_CPRStringExpr:
.1369	68		pla				pla 								; chuck the base.
.136a	8a		txa				txa
.136b	48		pha				pha
.136c	98		tya				tya
.136d	48		pha				pha
.136e	b4 28		ldy $28,x			ldy 	esInt0,x
.1370	b5 30		lda $30,x			lda 	esInt1,x
.1372	aa		tax				tax
.1373	20 0b 15	jsr $150b			jsr 	PrintXYString
.1376	68		pla				pla
.1377	a8		tay				tay
.1378	68		pla				pla
.1379	aa		tax				tax
.137a	4c 32 13	jmp $1332			jmp 	_CPRLoop
.137d					_CPRString:
.137d	c8		iny				iny 								; move to start of string.
.137e	c8		iny				iny
.137f					_CPRStringLoop:
.137f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character and bump
.1381	c8		iny				iny
.1382	c9 00		cmp #$00			cmp 	#0 							; end of string, loop back.
.1384	f0 ac		beq $1332			beq 	_CPRLoop
.1386	20 52 10	jsr $1052			jsr 	XTPrintA 					; print it and try next character.
.1389	4c 7f 13	jmp $137f			jmp 	_CPRStringLoop
.138c					_CPRNewLine:
.138c	20 42 10	jsr $1042			jsr 	XTPrintCR
.138f	4c 32 13	jmp $1332			jmp 	_CPRLoop
.1392					_CPRTab:
.1392	20 4a 10	jsr $104a			jsr 	XTPrintTab
.1395	a9 01		lda #$01			lda 	#1
.1397	4c 34 13	jmp $1334			jmp 	_CPRSetFlag
.139a					_CPRExit:
.139a	ad a7 08	lda $08a7			lda 	PrintCRFlag 				; check flag.
.139d	d0 03		bne $13a2			bne 	_CPRNoNL
.139f	20 42 10	jsr $1042			jsr 	XTPrintCR
.13a2					_CPRNoNL:
.13a2	60		rts				rts
.13a3					_CPRPrintInteger:
.13a3	48		pha				pha 								; save base on stack
.13a4	20 96 16	jsr $1696			jsr 	EvaluateBaseDeref 			; evaluate whatever it is.
.13a7	b5 20		lda $20,x			lda 	esType,x 					; is it a string expression ?
.13a9	4a		lsr a				lsr 	a
.13aa	b0 bd		bcs $1369			bcs 	_CPRStringExpr
.13ac	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.13ae	85 04		sta $04				sta 	temp0
.13b0	a9 08		lda #$08			lda 	#(buffer) >> 8
.13b2	85 05		sta $05				sta 	1+(temp0)
.13b4	68		pla				pla
.13b5	20 96 1d	jsr $1d96			jsr 	Int32ToString 				; convert in the buffer.
.13b8	8a		txa				txa
.13b9	48		pha				pha
.13ba	a2 00		ldx #$00			ldx 	#0
.13bc					_CPROutBuffer:
.13bc	bd 8c 08	lda $088c,x			lda 	buffer,x
.13bf	f0 06		beq $13c7			beq 	_CPROBExit
.13c1	20 52 10	jsr $1052			jsr 	XTPrintA
.13c4	e8		inx				inx
.13c5	d0 f5		bne $13bc			bne 	_CPROutBuffer
.13c7					_CPROBExit:
.13c7	68		pla				pla
.13c8	aa		tax				tax
.13c9	4c 32 13	jmp $1332			jmp 	_CPRLoop

;******  Return to file: basic.asm


;******  Processing file: common/commands/rem.asm

.13cc					Command_Rem:
.13cc					Command_Rem2:
.13cc	b1 00		lda ($00),y			lda 	(codePtr),y
.13ce	c9 80		cmp #$80			cmp 	#$80 						; end of line.
.13d0	f0 0a		beq $13dc			beq 	_RemExit
.13d2	c9 c0		cmp #$c0			cmp 	#KWD_COLON
.13d4	f0 06		beq $13dc			beq 	_RemExit
.13d6	20 dd 13	jsr $13dd			jsr 	AdvancePointer
.13d9	4c cc 13	jmp $13cc			jmp 	Command_Rem
.13dc					_RemExit:
.13dc	60		rts				rts
.13dd					AdvancePointer:
.13dd	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token
.13df	c9 01		cmp #$01			cmp 	#$01 						; quoted string
.13e1	f0 02		beq $13e5			beq 	_APString
.13e3	c8		iny				iny 								; advance and return.
.13e4	60		rts				rts
.13e5					_APString:
.13e5	98		tya				tya 								; and length to position
.13e6	c8		iny				iny
.13e7	18		clc				clc
.13e8	71 00		adc ($00),y			adc 	(codePtr),y
.13ea	a8		tay				tay
.13eb	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/repeat.asm

.13ec					Command_Repeat:
.13ec	a9 24		lda #$24			lda 	#SMRepeat 					; repeat marker allocate 4 bytes.
.13ee	20 43 20	jsr $2043			jsr 	StackOpen 					; create on stack.
.13f1	20 97 20	jsr $2097			jsr 	StackSavePosition 			; save position.
.13f4	60		rts				rts
.13f5					Command_Until:
.13f5	a9 24		lda #$24			lda 	#SMRepeat 					; check the stack matches
.13f7	20 68 20	jsr $2068			jsr 	StackCheck
.13fa	d0 10		bne $140c			bne 	_CUError
.13fc	20 96 16	jsr $1696			jsr 	EvaluateBaseDeRef			; get the conditional
.13ff	20 61 1e	jsr $1e61			jsr 	Int32Zero
.1402	f0 04		beq $1408			beq 	_CULoopBack
.1404	20 73 20	jsr $2073			jsr 	StackClose 					; close the frame.
.1407	60		rts				rts
.1408					_CULoopBack:
.1408	20 87 20	jsr $2087			jsr 	StackLoadPosition			; go back until true
.140b	60		rts				rts
.140c					_CUError:
.140c	4c 4c 1a	jmp $1a4c			jmp 	EHandlerNoRepeat

;******  Return to file: basic.asm


;******  Processing file: common/commands/run.asm

.140f					Command_Run:
.140f	20 95 10	jsr $1095			jsr 	CommandClear 				; clear variables, memory pointers, hash table.
.1412	20 05 1f	jsr $1f05			jsr 	BuildProcedureList 			; build procedure cache.
.1415	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.1417	85 00		sta $00				sta 	codePtr
.1419	a9 22		lda #$22			lda 	#(BasicProgram) >> 8
.141b	85 01		sta $01				sta 	1+(codePtr)
.141d	a0 00		ldy #$00			ldy 	#0 							; check if off end of program.
.141f	b1 00		lda ($00),y			lda 	(codePtr),y
.1421	f0 28		beq $144b			beq 	Command_End
.1423	a0 03		ldy #$03			ldy 	#3 							; start at this offset.
.1425					CommandNextCommand:
.1425	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first token ... see if it is a token.
.1427	10 1b		bpl $1444			bpl 	CommandTryLet				; if not, try LET as a default.
.1429	c8		iny				iny 								; advance past it.
.142a	20 d3 17	jsr $17d3			jsr 	ExecuteCommand 				; execute the command
.142d	4c 25 14	jmp $1425			jmp 	CommandNextCommand
.1430					CommandNextLine:
.1430	a0 00		ldy #$00			ldy 	#0 							; get offset and add
.1432	b1 00		lda ($00),y			lda 	(codePtr),y
.1434	18		clc				clc
.1435	65 00		adc $00				adc 	codePtr
.1437	85 00		sta $00				sta 	codePtr
.1439	90 02		bcc $143d			bcc 	_CSLExit
.143b	e6 01		inc $01				inc 	codePtr+1
.143d					_CSLExit:
.143d	b1 00		lda ($00),y			lda 	(codePtr),y 				; reached end of code ?
.143f	f0 0a		beq $144b			beq 	Command_End
.1441	a0 03		ldy #$03			ldy 	#3 							; 3rd position next line.
.1443	60		rts				rts
.1444					CommandTryLet:
.1444	20 c9 12	jsr $12c9			jsr 	Command_LET
.1447	4c 25 14	jmp $1425			jmp 	CommandNextCommand
.144a					Command_Colon:
.144a	60		rts				rts
.144b					Command_End:
.144b	4c 67 10	jmp $1067			jmp 	WarmStart
.144e					Command_Stop:
.144e	4c 9f 1a	jmp $1a9f			jmp 	EHandlerStop

;******  Return to file: basic.asm


;******  Processing file: common/commands/vdu.asm

.1451					Command_Vdu:
.1451	20 96 16	jsr $1696			jsr 	EvaluateBaseDeRef			; evaluate the thing being asserted.
.1454	b5 28		lda $28,x			lda 	esInt0,x 					; get the byte
.1456	20 52 10	jsr $1052			jsr 	XTPrintA 					; and print it
.1459	b1 00		lda ($00),y			lda 	(codePtr),y 				; if comma follows
.145b	c8		iny				iny
.145c	c9 ac		cmp #$ac			cmp 	#KWD_COMMA
.145e	f0 f1		beq $1451			beq 	Command_Vdu 				; loop back roun.
.1460	88		dey				dey
.1461	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/while.asm

.1462					Command_While:
.1462	a9 34		lda #$34			lda 	#SMWhile 					; gosub marker allocate 4 bytes.
.1464	20 43 20	jsr $2043			jsr 	StackOpen 					; create on stack.
.1467	88		dey				dey
.1468	20 97 20	jsr $2097			jsr 	StackSavePosition 			; save position before the WHILE.
.146b	c8		iny				iny
.146c	20 96 16	jsr $1696			jsr 	EvaluateBaseDeRef			; get the conditional
.146f	20 61 1e	jsr $1e61			jsr 	Int32Zero
.1472	f0 01		beq $1475			beq 	_CWFail
.1474	60		rts				rts
.1475					_CWFail:
.1475	20 73 20	jsr $2073			jsr 	StackClose 					; close the just opened position.
.1478	a9 bc		lda #$bc			lda 	#KWD_WEND 					; scan forward past WEND.
.147a	aa		tax				tax
.147b	20 f5 1f	jsr $1ff5			jsr 	ScanForward
.147e	60		rts				rts
.147f					Command_Wend:
.147f	a9 34		lda #$34			lda 	#SMWhile 					; check the stack matches
.1481	20 68 20	jsr $2068			jsr 	StackCheck
.1484	d0 07		bne $148d			bne 	_CWError
.1486	20 87 20	jsr $2087			jsr 	StackLoadPosition			; go back until true
.1489	20 73 20	jsr $2073			jsr 	StackClose 					; close the frame.
.148c	60		rts				rts
.148d					_CWError:
.148d	4c 64 1a	jmp $1a64			jmp 	EHandlerNoWhile

;******  Return to file: basic.asm


;******  Processing file: common/errors/checksyntax.asm

.1490					CheckComma:
.1490	48		pha				pha
.1491	a9 ac		lda #$ac			lda 	#KWD_COMMA
.1493	4c ae 14	jmp $14ae			jmp 	CheckSyntax
.1496					CheckLeftParen:
.1496	48		pha				pha
.1497	a9 95		lda #$95			lda 	#KWD_LPAREN
.1499	4c ae 14	jmp $14ae			jmp 	CheckSyntax
.149c					CheckEquals:
.149c	48		pha				pha
.149d	a9 89		lda #$89			lda 	#KWD_EQUAL
.149f	4c ae 14	jmp $14ae			jmp 	CheckSyntax
.14a2					CheckTO:
.14a2	48		pha				pha
.14a3	a9 c3		lda #$c3			lda 	#KWD_TO
.14a5	4c ae 14	jmp $14ae			jmp 	CheckSyntax
.14a8					CheckRightParen:
.14a8	48		pha				pha
.14a9	a9 ae		lda #$ae			lda 	#KWD_RPAREN
.14ab	4c ae 14	jmp $14ae			jmp 	CheckSyntax
.14ae					CheckSyntax:
.14ae	d1 00		cmp ($00),y			cmp 	(codePtr),y
.14b0	d0 03		bne $14b5			bne 	_CSFail
.14b2	c8		iny				iny
.14b3	68		pla				pla
.14b4	60		rts				rts
.14b5					_CSFail:
.14b5	4c a7 1a	jmp $1aa7			jmp 	EHandlerSyntax
.14b8					NoOp1:
.14b8					NoOp2:
.14b8					NoOp3:
.14b8					NoOp6:
.14b8					NoOp7:
.14b8					NoOp8:
.14b8					NoOp9:
.14b8	4c a7 1a	jmp $1aa7			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/errors/errorhandler.asm

.14bb					ErrorHandler:
.14bb	84 0a		sty $0a				sty 	temp3
.14bd	68		pla				pla 								; line addr into XY.
.14be	a8		tay				tay
.14bf	68		pla				pla
.14c0	aa		tax				tax
.14c1	c8		iny				iny
.14c2	d0 01		bne $14c5			bne 	_EHNoBump
.14c4	e8		inx				inx
.14c5					_EHNoBump:
.14c5	20 0b 15	jsr $150b			jsr 	PrintXYString 				; print it
.14c8	a0 00		ldy #$00			ldy 	#0 							; if offset = 0 (e.g. not in program)
.14ca	b1 00		lda ($00),y			lda 	(codePtr),y
.14cc	f0 30		beq $14fe			beq 	_GoWarm 					; no line #
.14ce	20 06 15	jsr $1506			jsr 	PrintSpace
.14d1	a9 40		lda #$40			lda 	#'@'
.14d3	20 32 10	jsr $1032			jsr 	XTPrintAC
.14d6	20 06 15	jsr $1506			jsr 	PrintSpace
.14d9	a2 00		ldx #$00			ldx 	#0 							; set up for ITOA conversion
.14db	c8		iny				iny
.14dc	b1 00		lda ($00),y			lda 	(codePtr),y
.14de	95 28		sta $28,x			sta 	esInt0,x
.14e0	c8		iny				iny
.14e1	b1 00		lda ($00),y			lda 	(codePtr),y
.14e3	95 30		sta $30,x			sta 	esInt1,x
.14e5	8a		txa				txa
.14e6	95 38		sta $38,x			sta 	esInt2,x
.14e8	95 40		sta $40,x			sta 	esInt3,x
.14ea	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.14ec	85 04		sta $04				sta 	temp0
.14ee	a9 08		lda #$08			lda 	#(buffer) >> 8
.14f0	85 05		sta $05				sta 	1+(temp0)
.14f2	a9 0a		lda #$0a			lda 	#10 						; convert base 10.
.14f4	20 96 1d	jsr $1d96			jsr 	Int32ToString
.14f7	a2 08		ldx #$08			ldx 	#buffer >> 8
.14f9	a0 8c		ldy #$8c			ldy 	#buffer & $FF
.14fb	20 0b 15	jsr $150b			jsr 	PrintXYString
.14fe					_GoWarm:
.14fe	a5 0a		lda $0a				lda 	temp3
.1500	4c 67 10	jmp $1067			jmp 	WarmStart
.1503					InstructionUndefined:
.1503	4c 7a 1a	jmp $1a7a			jmp 	EHandlerNotImplemented
.1506					PrintSpace:
.1506	a9 20		lda #$20			lda 	#32
.1508	4c 32 10	jmp $1032			jmp 	XTPrintAC
.150b					PrintXYString:
.150b	48		pha				pha
.150c	84 04		sty $04				sty 	temp0
.150e	86 05		stx $05				stx 	temp0+1
.1510	a0 00		ldy #$00			ldy 	#0
.1512					_PXYSLoop:
.1512	b1 04		lda ($04),y			lda 	(temp0),y
.1514	20 32 10	jsr $1032			jsr 	XTPrintAC
.1517	c8		iny				iny
.1518	b1 04		lda ($04),y			lda 	(temp0),y
.151a	d0 f6		bne $1512			bne 	_PXYSLoop
.151c	a4 04		ldy $04				ldy 	temp0
.151e	a6 05		ldx $05				ldx 	temp0+1
.1520	68		pla				pla
.1521	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary1.asm

.1522					BinaryAdd:
.1522	20 5e 17	jsr $175e			jsr		DeRefBoth
.1525	20 2b 1d	jsr $1d2b			jsr 	Int32Add
.1528	a9 00		lda #$00			lda 	#0
.152a	95 20		sta $20,x			sta 	esType,x
.152c	60		rts				rts
.152d					BinarySub:
.152d	20 5e 17	jsr $175e			jsr		DeRefBoth
.1530	20 45 1d	jsr $1d45			jsr 	Int32Sub
.1533	a9 00		lda #$00			lda 	#0
.1535	95 20		sta $20,x			sta 	esType,x
.1537	60		rts				rts
.1538					BinaryMult:
.1538	20 5e 17	jsr $175e			jsr		DeRefBoth
.153b	20 5f 1d	jsr $1d5f			jsr 	Int32Multiply
.153e	a9 00		lda #$00			lda 	#0
.1540	95 20		sta $20,x			sta 	esType,x
.1542	60		rts				rts
.1543					BinaryDivide:
.1543	20 5e 17	jsr $175e			jsr		DeRefBoth
.1546	20 5f 15	jsr $155f			jsr		CheckDivisorNonZero
.1549	20 48 1c	jsr $1c48			jsr 	Int32SDivide
.154c	a9 00		lda #$00			lda 	#0
.154e	95 20		sta $20,x			sta 	esType,x
.1550	60		rts				rts
.1551					BinaryModulus:
.1551	20 5e 17	jsr $175e			jsr		DeRefBoth
.1554	20 5f 15	jsr $155f			jsr 	CheckDivisorNonZero
.1557	20 b7 1c	jsr $1cb7			jsr		Int32Modulus
.155a	a9 00		lda #$00			lda 	#0
.155c	95 20		sta $20,x			sta 	esType,x
.155e	60		rts				rts
.155f					CheckDivisorNonZero:
.155f	e8		inx				inx
.1560	20 61 1e	jsr $1e61			jsr 	Int32Zero
.1563	f0 02		beq $1567			beq 	_BDivZero
.1565	ca		dex				dex
.1566	60		rts				rts
.1567					_BDivZero:
.1567	4c e3 19	jmp $19e3			jmp 	EHandlerDivideZero
.156a					BinaryXor:
.156a	20 5e 17	jsr $175e			jsr		DeRefBoth
.156d	20 fc 1b	jsr $1bfc			jsr 	Int32Xor
.1570	a9 00		lda #$00			lda 	#0
.1572	95 20		sta $20,x			sta 	esType,x
.1574	60		rts				rts
.1575					BinaryOr:
.1575	20 5e 17	jsr $175e			jsr		DeRefBoth
.1578	20 e3 1b	jsr $1be3			jsr 	Int32Or
.157b	a9 00		lda #$00			lda 	#0
.157d	95 20		sta $20,x			sta 	esType,x
.157f	60		rts				rts
.1580					BinaryAnd:
.1580	20 5e 17	jsr $175e			jsr		DeRefBoth
.1583	20 ca 1b	jsr $1bca			jsr 	Int32And
.1586	a9 00		lda #$00			lda 	#0
.1588	95 20		sta $20,x			sta 	esType,x
.158a	60		rts				rts
.158b					BinaryShiftLeft:
.158b	20 5e 17	jsr $175e			jsr		DeRefBoth
.158e	20 b8 15	jsr $15b8			jsr 	CheckShiftParam2
.1591	d0 21		bne $15b4			bne 	BinaryShiftZero
.1593					BSLLoop:
.1593	d6 29		dec $29,x			dec 	esInt0+1,x
.1595	30 18		bmi $15af			bmi 	BinaryShiftExit
.1597	20 4f 1e	jsr $1e4f			jsr 	Int32ShiftLeft
.159a	4c 93 15	jmp $1593			jmp 	BSLLoop
.159d					BinaryShiftRight:
.159d	20 5e 17	jsr $175e			jsr		DeRefBoth
.15a0	20 b8 15	jsr $15b8			jsr 	CheckShiftParam2
.15a3	d0 0f		bne $15b4			bne 	BinaryShiftZero
.15a5					BSRLoop:
.15a5	d6 29		dec $29,x			dec 	esInt0+1,x
.15a7	30 06		bmi $15af			bmi 	BinaryShiftExit
.15a9	20 58 1e	jsr $1e58			jsr 	Int32ShiftRight
.15ac	4c a5 15	jmp $15a5			jmp 	BSRLoop
.15af					BinaryShiftExit:
.15af	a9 00		lda #$00			lda 	#0
.15b1	95 20		sta $20,x			sta 	esType,x
.15b3	60		rts				rts
.15b4					BinaryShiftZero:
.15b4	20 3a 1e	jsr $1e3a			jsr 	Int32False
.15b7	60		rts				rts
.15b8					CheckShiftParam2:
.15b8	b5 29		lda $29,x			lda 	esInt0+1,x 					; if value >= 32 then result is zero
.15ba	29 e0		and #$e0			and 	#$E0
.15bc	15 31		ora $31,x			ora 	esInt1+1,x
.15be	15 39		ora $39,x			ora 	esInt2+1,x
.15c0	15 41		ora $41,x			ora 	esInt3+1,x
.15c2	60		rts				rts
.15c3					IndirectWord:
.15c3	20 5e 17	jsr $175e			jsr		DeRefBoth
.15c6	20 2b 1d	jsr $1d2b			jsr 	Int32Add
.15c9	a9 80		lda #$80			lda 	#$80 						; make it a reference
.15cb	95 20		sta $20,x			sta 	esType,x
.15cd	60		rts				rts
.15ce					IndirectByte:
.15ce	20 5e 17	jsr $175e			jsr		DeRefBoth
.15d1	20 2b 1d	jsr $1d2b			jsr 	Int32Add
.15d4	a9 c0		lda #$c0			lda 	#$C0 						; type is set to byte reference.
.15d6	95 20		sta $20,x			sta 	esType,x
.15d8	60		rts				rts
.15d9					IndirectString:
.15d9	20 5e 17	jsr $175e			jsr		DeRefBoth
.15dc	20 2b 1d	jsr $1d2b			jsr 	Int32Add
.15df	a9 81		lda #$81			lda 	#$81 						; type is set to string reference.
.15e1	95 20		sta $20,x			sta 	esType,x
.15e3	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary2.asm

.15e4					Binary_Equal:
.15e4	20 14 16	jsr $1614			jsr 	TestEqual
.15e7	b0 04		bcs $15ed			bcs 	CompTrue
.15e9					CompFalse:
.15e9	20 3a 1e	jsr $1e3a			jsr 	Int32False
.15ec	60		rts				rts
.15ed					CompTrue
.15ed	20 36 1e	jsr $1e36			jsr 	Int32True
.15f0	60		rts				rts
.15f1					Binary_NotEqual:
.15f1	20 14 16	jsr $1614			jsr 	TestEqual
.15f4	90 f7		bcc $15ed			bcc 	CompTrue
.15f6	b0 f1		bcs $15e9			bcs 	CompFalse
.15f8					Binary_Less:
.15f8	20 2b 16	jsr $162b			jsr 	TestLess
.15fb	b0 f0		bcs $15ed			bcs 	CompTrue
.15fd	90 ea		bcc $15e9			bcc 	CompFalse
.15ff					Binary_GreaterEqual:
.15ff	20 2b 16	jsr $162b			jsr 	TestLess
.1602	90 e9		bcc $15ed			bcc 	CompTrue
.1604	b0 e3		bcs $15e9			bcs 	CompFalse
.1606					Binary_LessEqual:
.1606	20 28 16	jsr $1628			jsr 	TestLessSwap
.1609	90 e2		bcc $15ed			bcc 	CompTrue
.160b	b0 dc		bcs $15e9			bcs 	CompFalse
.160d					Binary_Greater:
.160d	20 28 16	jsr $1628			jsr 	TestLessSwap
.1610	b0 db		bcs $15ed			bcs 	CompTrue
.1612	90 d5		bcc $15e9			bcc 	CompFalse
.1614					TestEqual:
.1614	20 42 16	jsr $1642			jsr 	TypeCheck
.1617	c9 00		cmp #$00			cmp 	#0
.1619	f0 0a		beq $1625			beq 	_TEInteger
.161b	20 6b 16	jsr $166b			jsr 	StringCompare
.161e	c9 00		cmp #$00			cmp 	#0
.1620	38		sec				sec
.1621	f0 01		beq $1624			beq 	_TEZero
.1623	18		clc				clc
.1624					_TEZero
.1624	60		rts				rts
.1625					_TEInteger:
.1625	4c 15 1c	jmp $1c15			jmp 	Int32Equal
.1628					TestLessSwap:
.1628	20 4f 16	jsr $164f			jsr 	SwapTopStack
.162b					TestLess:
.162b	20 42 16	jsr $1642			jsr 	TypeCheck
.162e	c9 00		cmp #$00			cmp 	#0
.1630	f0 0d		beq $163f			beq 	_TLInteger
.1632	20 6b 16	jsr $166b			jsr 	StringCompare
.1635	c9 00		cmp #$00			cmp 	#0
.1637	38		sec				sec
.1638	30 01		bmi $163b			bmi 	_TELess
.163a	18		clc				clc
.163b					_TELess:
.163b	60		rts				rts
.163c	4c 7a 1a	jmp $1a7a			jmp 	EHandlerNotImplemented
.163f					_TLInteger:
.163f	4c 2f 1c	jmp $1c2f			jmp 	Int32Less
.1642					TypeCheck:
.1642	20 5e 17	jsr $175e			jsr 	DerefBoth
.1645	b5 20		lda $20,x			lda 	esType,x
.1647	d5 21		cmp $21,x			cmp 	esType+1,x
.1649	d0 01		bne $164c			bne 	_TCMismatch
.164b	60		rts				rts
.164c					_TCMismatch:
.164c	4c b7 1a	jmp $1ab7			jmp 	EHandlerTypeMismatch
.164f					SwapTopStack:
.164f	a9 06		lda #$06			lda 	#6
.1651	85 03		sta $03				sta 	tempShort
.1653	8a		txa				txa
.1654	48		pha				pha
.1655					_TLSLoop:
.1655	b5 20		lda $20,x			lda 	esType,x
.1657	48		pha				pha
.1658	b5 21		lda $21,x			lda 	esType+1,x
.165a	95 20		sta $20,x			sta 	esType,x
.165c	68		pla				pla
.165d	95 21		sta $21,x			sta 	esType+1,x
.165f	8a		txa				txa
.1660	18		clc				clc
.1661	69 08		adc #$08			adc 	#DataStackSize
.1663	aa		tax				tax
.1664	c6 03		dec $03				dec 	tempShort
.1666	d0 ed		bne $1655			bne 	_TLSLoop
.1668	68		pla				pla
.1669	aa		tax				tax
.166a	60		rts				rts
.166b					StringCompare:
.166b	b5 28		lda $28,x			lda 	esInt0,x 					; copy addresses.
.166d	85 04		sta $04				sta 	temp0
.166f	b5 30		lda $30,x			lda 	esInt1,x
.1671	85 05		sta $05				sta 	temp0+1
.1673	b5 29		lda $29,x			lda 	esInt0+1,x
.1675	85 06		sta $06				sta 	temp1
.1677	b5 31		lda $31,x			lda 	esInt1+1,x
.1679	85 07		sta $07				sta 	temp1+1
.167b	84 03		sty $03				sty 	tempShort
.167d	a0 ff		ldy #$ff			ldy 	#255
.167f	c8		iny		_SCLoop:iny
.1680	b1 04		lda ($04),y			lda 	(temp0),y 					; check match return +ve/-ve if fail.
.1682	38		sec				sec
.1683	f1 06		sbc ($06),y			sbc 	(temp1),y
.1685	d0 04		bne $168b			bne 	_SCExit
.1687	b1 04		lda ($04),y			lda 	(temp0),y 					; matched zero, then exit with zero
.1689	d0 f4		bne $167f			bne 	_SCLoop
.168b					_SCExit:
.168b	a4 03		ldy $03				ldy 	tempShort
.168d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/evaluate.asm

.168e					EvaluateTerm:
.168e	a9 0f		lda #$0f			lda 	#15
.1690	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX
.1693	4c 63 17	jmp $1763			jmp 	DeRefTop
.1696					EvaluateBaseDeRef:
.1696	20 a2 16	jsr $16a2			jsr 	EvaluateBase
.1699	4c 63 17	jmp $1763			jmp 	DeRefTop
.169c					EvaluateTOSDeRef:
.169c	20 a4 16	jsr $16a4			jsr 	EvaluateTOS
.169f	4c 63 17	jmp $1763			jmp 	DeRefTop
.16a2					EvaluateBase:
.16a2	a2 00		ldx #$00			ldx 	#0 							; reset Stack index
.16a4					EvaluateTOS:
.16a4	a9 00		lda #$00			lda 	#0 							; start from lowest level.
.16a6					EvaluateLevelAX:
.16a6	48		pha				pha 								; save level on stack
.16a7	a9 00		lda #$00			lda 	#0 							; erase the current stack level
.16a9	95 28		sta $28,x			sta 	esInt0,x
.16ab	95 30		sta $30,x			sta 	esInt1,x
.16ad	95 38		sta $38,x			sta 	esInt2,x
.16af	95 40		sta $40,x			sta 	esInt3,x
.16b1	95 20		sta $20,x			sta 	esType,x 					; default to integer.
.16b3	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next token/element.
.16b5	30 59		bmi $1710			bmi 	EBNotVariable 				; if $80-$FF it is a token.
.16b7	c9 70		cmp #$70			cmp 	#$70 						; if $70-$7F it is a constant
.16b9	90 06		bcc $16c1			bcc 	_EBNotConstant
.16bb					_EBConstant:
.16bb	20 a2 17	jsr $17a2			jsr 	ExtractConstant
.16be	4c e4 16	jmp $16e4			jmp 	EBHaveTerm
.16c1					_EBNotConstant:
.16c1	c9 60		cmp #$60			cmp 	#$60 						; 60 is a string.
.16c3	f0 06		beq $16cb			beq 	_EBHaveString
.16c5	20 17 21	jsr $2117			jsr 	VariableAccess
.16c8	4c e4 16	jmp $16e4			jmp 	EBHaveTerm
.16cb					_EBHaveString:
.16cb	98		tya				tya 								; put codePtr + 2 in the address, it's a string.
.16cc	18		clc				clc
.16cd	69 02		adc #$02			adc 	#2
.16cf	65 00		adc $00				adc 	codePtr
.16d1	95 28		sta $28,x			sta 	esInt0,x
.16d3	a5 01		lda $01				lda 	codePtr+1
.16d5	69 00		adc #$00			adc 	#0
.16d7	95 30		sta $30,x			sta 	esInt1,x
.16d9	f6 20		inc $20,x			inc 	esType,x 					; make the type a string.
.16db	98		tya				tya 								; position in A
.16dc	c8		iny				iny 								; point to offset and add it
.16dd	18		clc				clc
.16de	71 00		adc ($00),y			adc 	(codePtr),y
.16e0	a8		tay				tay
.16e1	4c e4 16	jmp $16e4			jmp 	EBHaveTerm 				; do the term code.
.16e4					EBHaveTerm:
.16e4	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next element.
.16e6	10 26		bpl $170e			bpl 	_EBPopExit 					; needs to be a token to continue.
.16e8	84 03		sty $03				sty 	tempShort
.16ea	a8		tay				tay
.16eb	b9 48 1a	lda $1a48,y			lda 	KeywordTypes-$80,y 			; get the type of the keyword.
.16ee	a4 03		ldy $03				ldy 	tempShort
.16f0	c9 10		cmp #$10			cmp 	#16 						; not a binary operator.
.16f2	b0 1a		bcs $170e			bcs 	_EBPopExit
.16f4	85 03		sta $03				sta 	tempShort 					; save level of new operator.
.16f6	68		pla				pla 								; restore current level.
.16f7	c5 03		cmp $03				cmp 	tempShort 					; if current >= operator then exit
.16f9	b0 14		bcs $170f			bcs 	_EBExit
.16fb	48		pha				pha 								; push level on stack.
.16fc	b1 00		lda ($00),y			lda		(codePtr),y					; get the token ID and skip
.16fe	c8		iny				iny
.16ff	48		pha				pha 								; put that on the stack.
.1700	e8		inx				inx 								; do the term in the next stack level.
.1701	a5 03		lda $03				lda 	tempShort 					; get the level of the operator.
.1703	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX
.1706	ca		dex				dex
.1707	68		pla				pla 								; get token ID
.1708	20 d3 17	jsr $17d3			jsr 	ExecuteCommand 				; execute command A.
.170b	4c e4 16	jmp $16e4			jmp 	EBHaveTerm 					; keep going round
.170e					_EBPopExit:
.170e	68		pla				pla
.170f					_EBExit:
.170f	60		rts				rts
.1710					EBNotVariable:
.1710	84 03		sty $03				sty 	tempShort 					; get the type
.1712	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.1714	a8		tay				tay
.1715	b9 48 1a	lda $1a48,y			lda 	KeywordTypes-$80,y
.1718	a4 03		ldy $03				ldy 	tempShort
.171a	29 40		and #$40			and 	#$40 						; check unary function
.171c	d0 37		bne $1755			bne 	_EBExecUnaryFunction
.171e	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.1720	c8		iny				iny
.1721	c9 8b		cmp #$8b			cmp 	#KWD_MINUS
.1723	f0 0f		beq $1734			beq 	_EBNegate
.1725	c9 91		cmp #$91			cmp 	#KWD_PLING
.1727	f0 14		beq $173d			beq 	_EBUnaryReference
.1729	c9 92		cmp #$92			cmp 	#KWD_QUESTION
.172b	f0 10		beq $173d			beq 	_EBUnaryReference
.172d	c9 93		cmp #$93			cmp 	#KWD_DOLLAR
.172f	f0 0c		beq $173d			beq 	_EBUnaryReference
.1731					_EBError:
.1731	4c a7 1a	jmp $1aa7			jmp 	EHandlerSyntax
.1734					_EBNegate:
.1734	20 8e 16	jsr $168e			jsr 	EvaluateTerm
.1737	20 f4 1d	jsr $1df4			jsr 	Int32Negate
.173a	4c e4 16	jmp $16e4			jmp 	EBHaveTerm
.173d					_EBUnaryReference:
.173d	48		pha				pha 								; save keyword
.173e	20 8e 16	jsr $168e			jsr 	EvaluateTerm 				; get the address to case.
.1741	68		pla				pla
.1742	49 91		eor #$91			eor 	#KWD_PLING 					; is it pling, then will now be zero.
.1744	f0 08		beq $174e			beq 	_EBSetType
.1746	49 02		eor #$02			eor 	#KWD_DOLLAR^KWD_PLING 		; if was dollar will now be zero
.1748	f0 02		beq $174c			beq 	_EBSetString
.174a	a9 41		lda #$41			lda 	#$41 						; will end up as $C0
.174c					_EBSetString:
.174c	49 01		eor #$01			eor 	#$01 						; will end up as $81
.174e					_EBSetType:
.174e	09 80		ora #$80			ora 	#$80 						; make it a reference.
.1750	95 20		sta $20,x			sta 	esType,x
.1752	4c e4 16	jmp $16e4			jmp 	EBHaveTerm
.1755					_EBExecUnaryFunction:
.1755	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the function token.
.1757	c8		iny				iny
.1758	20 d3 17	jsr $17d3			jsr 	ExecuteCommand 				; and do it.
.175b	4c e4 16	jmp $16e4			jmp 	EBHaveTerm
.175e					DeRefBoth:
.175e	e8		inx				inx
.175f	20 63 17	jsr $1763			jsr 	DeRefTop
.1762	ca		dex				dex
.1763					DeRefTop:
.1763	b5 20		lda $20,x			lda 	esType,x 					; is it a reference ?
.1765	10 3a		bpl $17a1			bpl 	_DRTExit
.1767	29 7f		and #$7f			and 	#$7F 						; clear the reference bit and write back.
.1769	95 20		sta $20,x			sta 	esType,x
.176b	4a		lsr a				lsr 	a 							; if string, exit. Strings are always references
.176c	b0 33		bcs $17a1			bcs 	_DRTExit
.176e	b5 28		lda $28,x			lda 	esInt0,x 					; copy address over.
.1770	85 04		sta $04				sta 	temp0
.1772	b5 30		lda $30,x			lda 	esInt1,x
.1774	85 05		sta $05				sta 	temp0+1
.1776	98		tya				tya
.1777	48		pha				pha
.1778	a0 00		ldy #$00			ldy 	#0
.177a	b1 04		lda ($04),y			lda 	(temp0),y
.177c	95 28		sta $28,x			sta 	esInt0,x
.177e	b5 20		lda $20,x			lda 	esType,x 					; is it now zero, e.g. it's a !
.1780	f0 0c		beq $178e			beq 	_DRTPling
.1782	98		tya				tya 								; clear upper 3 bytes
.1783	95 30		sta $30,x			sta 	esInt1,x
.1785	95 38		sta $38,x			sta 	esInt2,x
.1787	95 40		sta $40,x			sta 	esInt3,x
.1789	95 20		sta $20,x			sta 	esType,x
.178b	4c 9f 17	jmp $179f			jmp	 	_DRTExit2
.178e					_DRTPling:
.178e	94 20		sty $20,x			sty 	esType,x 					; make it an integer
.1790	c8		iny				iny
.1791	b1 04		lda ($04),y			lda 	(temp0),y 					; copy 4 bytes.
.1793	95 30		sta $30,x			sta 	esInt1,x
.1795	c8		iny				iny
.1796	b1 04		lda ($04),y			lda 	(temp0),y
.1798	95 38		sta $38,x			sta 	esInt2,x
.179a	c8		iny				iny
.179b	b1 04		lda ($04),y			lda 	(temp0),y
.179d	95 40		sta $40,x			sta 	esInt3,x
.179f					_DRTExit2:
.179f	68		pla				pla
.17a0	a8		tay				tay
.17a1					_DRTExit:
.17a1	60		rts				rts
.17a2					ExtractConstant:
.17a2	a9 00		lda #$00			lda 	#0 							; count of number of hex digits read.
.17a4	85 03		sta $03				sta 	tempShort 					; use tempShort for that
.17a6	8a		txa				txa
.17a7	48		pha				pha
.17a8					_EBConstLoop:
.17a8	e6 03		inc $03				inc 	tempShort 					; bump the hex digit count.
.17aa	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character.
.17ac	29 f0		and #$f0			and 	#$F0 						; check it is 70-7F
.17ae	c9 70		cmp #$70			cmp 	#$70
.17b0	d0 1e		bne $17d0			bne 	_EBConstEnd
.17b2	a5 03		lda $03				lda 	tempShort 					; check LSB of digit count
.17b4	4a		lsr a				lsr 	a
.17b5	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the digit and bump
.17b7	c8		iny				iny
.17b8	90 06		bcc $17c0			bcc		_EBConstHigh 				; goes in upper byte.
.17ba	29 0f		and #$0f			and 	#$0F
.17bc	95 28		sta $28,x			sta 	esInt0,x 					; and write it out.
.17be	10 e8		bpl $17a8			bpl 	_EBConstLoop 				; try next one.
.17c0					_EBConstHigh:
.17c0	0a		asl a				asl 	a
.17c1	0a		asl a				asl 	a
.17c2	0a		asl a				asl 	a
.17c3	0a		asl a				asl 	a
.17c4	15 28		ora $28,x			ora 	esInt0,x 					; put into upper 4 bits
.17c6	95 28		sta $28,x			sta 	esInt0,x
.17c8	8a		txa				txa 								; move to next slot in data stack.
.17c9	18		clc				clc
.17ca	69 08		adc #$08			adc 	#DataStackSize
.17cc	aa		tax				tax
.17cd	4c a8 17	jmp $17a8			jmp 	_EBConstLoop
.17d0					_EBConstEnd:
.17d0	68		pla				pla
.17d1	aa		tax				tax
.17d2	60		rts				rts
.17d3					ExecuteCommand:
.17d3	85 03		sta $03				sta 	tempShort  					; needs making 65C02 specific.
.17d5	8a		txa				txa
.17d6	48		pha				pha
.17d7	a6 03		ldx $03				ldx 	tempShort
.17d9	bd 9e 1a	lda $1a9e,x			lda 	TokenVectorLow-$80,x
.17dc	85 04		sta $04				sta 	temp0
.17de	bd f4 1a	lda $1af4,x			lda 	TokenVectorHigh-$80,x
.17e1	85 05		sta $05				sta 	temp0+1
.17e3	68		pla				pla
.17e4	aa		tax				tax
.17e5	6c 04 00	jmp ($0004)			jmp 	(temp0)

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/unary.asm

.17e8					UnaryPage:
.17e8	20 ff 17	jsr $17ff			jsr 	UnaryFalse 					; set all to zero/int
.17eb	a9 00		lda #$00			lda 	#BasicProgram & $FF
.17ed	95 28		sta $28,x			sta 	esInt0,x
.17ef	a9 22		lda #$22			lda 	#BasicProgram >> 8
.17f1	95 30		sta $30,x			sta 	esInt1,x
.17f3	60		rts				rts
.17f4					UnaryParenthesis:
.17f4	20 a4 16	jsr $16a4			jsr 	EvaluateTOS					; evaluate expression
.17f7	20 a8 14	jsr $14a8			jsr 	CheckRightParen				; check for )
.17fa	60		rts				rts
.17fb					UnaryTrue:
.17fb	20 36 1e	jsr $1e36			jsr 	Int32True
.17fe	60		rts				rts
.17ff					UnaryFalse:
.17ff	20 3a 1e	jsr $1e3a			jsr 	Int32False
.1802	60		rts				rts
.1803					UnaryAbs:
.1803	20 8e 16	jsr $168e			jsr 	EvaluateTerm				; work out value required and dispatch
.1806	20 ef 1d	jsr $1def			jsr		Int32Absolute
.1809	a9 00		lda #$00			lda 	#0
.180b	95 20		sta $20,x			sta 	esType,x
.180d	60		rts				rts
.180e					UnarySys:
.180e	20 8e 16	jsr $168e			jsr 	EvaluateTerm				; address to call
.1811	b5 28		lda $28,x			lda 	esInt0,x 					; copy call address
.1813	85 04		sta $04				sta 	temp0
.1815	b5 30		lda $30,x			lda 	esInt1,x
.1817	85 05		sta $05				sta 	temp0+1
.1819	8a		txa				txa
.181a	48		pha				pha
.181b	98		tya				tya
.181c	48		pha				pha
.181d	ad 00 08	lda $0800			lda 	('A'-'A')*4+RootVariables 	; load AXY
.1820	ae 5c 08	ldx $085c			ldx 	('X'-'A')*4+RootVariables
.1823	ac 60 08	ldy $0860			ldy 	('Y'-'A')*4+RootVariables
.1826	20 48 18	jsr $1848			jsr 	_USCall						; call code
.1829	8d 00 08	sta $0800			sta 	('A'-'A')*4+RootVariables 	; save AXY
.182c	8e 5c 08	stx $085c			stx 	('X'-'A')*4+RootVariables
.182f	8c 60 08	sty $0860			sty 	('Y'-'A')*4+RootVariables
.1832	68		pla				pla
.1833	a8		tay				tay
.1834	68		pla				pla
.1835	aa		tax				tax
.1836	ad 00 08	lda $0800			lda 	('A'-'A')*4+RootVariables 	; return A.
.1839	95 28		sta $28,x			sta 	esInt0,x
.183b	a9 00		lda #$00			lda 	#0
.183d	95 30		sta $30,x			sta 	esInt1,x
.183f	95 38		sta $38,x			sta 	esInt2,x
.1841	95 40		sta $40,x			sta 	esInt3,x
.1843	a9 00		lda #$00			lda 	#0
.1845	95 20		sta $20,x			sta 	esType,x
.1847	60		rts				rts
.1848	6c 04 00	jmp ($0004)	_USCall:jmp 	(temp0)
.184b					UnarySgn1:
.184b	20 8e 16	jsr $168e			jsr 	EvaluateTerm				; work out value required and dispatch
.184e	20 27 1e	jsr $1e27			jsr 	Int32Sign
.1851	a9 00		lda #$00			lda 	#0
.1853	95 20		sta $20,x			sta 	esType,x
.1855	60		rts				rts
.1856					UnaryNot:
.1856	20 8e 16	jsr $168e			jsr 	EvaluateTerm				; work out value required and dispatch
.1859	20 0e 1e	jsr $1e0e			jsr 	Int32Not
.185c	a9 00		lda #$00			lda 	#0
.185e	95 20		sta $20,x			sta 	esType,x
.1860	60		rts				rts
.1861					UnaryMin:
.1861	38		sec				sec 								; min indicated with CS
.1862	b0 01		bcs $1865			bcs 	UnaryMax+1
.1864					UnaryMax:
.1864	18		clc				clc 								; max is CC.
.1865	08		php				php 								; save what we're doing.
.1866	20 96 14	jsr $1496			jsr 	CheckLeftParen 				; check for (, required here
.1869	20 9c 16	jsr $169c			jsr 	EvaluateTOSDeRef			; evaluate expression
.186c	e8		inx				inx
.186d	20 90 14	jsr $1490			jsr 	CheckComma
.1870	20 9c 16	jsr $169c			jsr 	EvaluateTOSDeRef
.1873	20 5e 17	jsr $175e			jsr 	DerefBoth 					; dereference them.
.1876	ca		dex				dex
.1877	20 a8 14	jsr $14a8			jsr 	CheckRightParen
.187a	20 2f 1c	jsr $1c2f			jsr 	Int32Less 					; is p1 < p2, CS if true.
.187d	a9 00		lda #$00			lda 	#0 							; put into A, now 1 if <, 0 if >
.187f	69 00		adc #$00			adc 	#0
.1881	28		plp				plp
.1882	69 00		adc #$00			adc 	#0 							; toggle bit 0 for Min.
.1884	4a		lsr a				lsr 	a 							; put into carry
.1885	90 03		bcc $188a			bcc 	_UMinMaxExit 				; if clear just exit.
.1887	20 4f 16	jsr $164f			jsr 	SwapTopStack 				; swap two values over.
.188a					_UMinMaxExit:
.188a	a9 00		lda #$00			lda 	#0
.188c	95 20		sta $20,x			sta 	esType,x
.188e	60		rts				rts
.188f					UTypeError:
.188f	4c b7 1a	jmp $1ab7			jmp 	EHandlerTypeMismatch
.1892					UnaryRefToValue:
.1892	a9 0f		lda #$0f			lda 	#15
.1894	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX 			; get a term.
.1897	b5 20		lda $20,x			lda 	esType,x
.1899	10 f4		bpl $188f			bpl 	UTypeError 					; not a reference
.189b	29 7f		and #$7f			and 	#$7F 						; clear reference bit.
.189d	95 20		sta $20,x			sta 	esType,x 					; overwrite type
.189f	a9 00		lda #$00			lda 	#0
.18a1	95 20		sta $20,x			sta 	esType,x
.18a3	60		rts				rts
.18a4					UnaryHexMarker:
.18a4	4c 8e 16	jmp $168e			jmp 	EvaluateTerm
.18a7					UnaryRandom:
.18a7	20 6a 1e	jsr $1e6a			jsr 	Int32Random 				; random #
.18aa	a9 00		lda #$00			lda 	#0
.18ac	95 20		sta $20,x			sta 	esType,x
.18ae	60		rts				rts
.18af					UnaryLen:
.18af	20 8e 16	jsr $168e			jsr 	EvaluateTerm				; work out value required and dispatch
.18b2	b5 28		lda $28,x			lda 	esInt0,x 					; copy addr to temp0
.18b4	85 04		sta $04				sta 	temp0
.18b6	b5 30		lda $30,x			lda 	esInt1,x
.18b8	85 05		sta $05				sta 	temp0+1
.18ba	20 ff 17	jsr $17ff			jsr 	UnaryFalse 					; sets return to int zero.
.18bd	98		tya				tya
.18be	48		pha				pha
.18bf	a0 00		ldy #$00			ldy 	#0
.18c1					_ULCheck:
.18c1	b1 04		lda ($04),y			lda 	(temp0),y
.18c3	f0 03		beq $18c8			beq 	_ULFound
.18c5	c8		iny				iny
.18c6	d0 f9		bne $18c1			bne 	_ULCheck
.18c8					_ULFound:
.18c8	94 28		sty $28,x			sty 	esInt0,x 					; update result
.18ca	68		pla				pla
.18cb	a8		tay				tay
.18cc	60		rts				rts
.18cd	60		rts				rts
.18ce					UnaryChr:
.18ce	20 8e 16	jsr $168e			jsr 	EvaluateTerm				; work out value required and dereference
.18d1	b5 28		lda $28,x			lda 	esInt0,x 					; get char code
.18d3	8d a5 08	sta $08a5			sta 	ChrBuffer 					; put into buffer.
.18d6	a9 00		lda #$00			lda 	#0
.18d8	8d a6 08	sta $08a6			sta 	ChrBuffer+1 				; make ASCIIZ
.18db	a9 a5		lda #$a5			lda 	#ChrBuffer & $FF 			; set address
.18dd	95 28		sta $28,x			sta 	esInt0,x
.18df	a9 08		lda #$08			lda 	#ChrBuffer >> 8
.18e1	95 30		sta $30,x			sta 	esInt1,x
.18e3	f6 20		inc $20,x			inc 	esType,x 					; makes it a string
.18e5	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/alloc.asm

.18e6					Unary_Alloc:
.18e6	20 8e 16	jsr $168e			jsr 	EvaluateTerm				; memory to allocate
.18e9	a5 10		lda $10				lda 	LowMemory 					; push low memory ons tack.
.18eb	48		pha				pha
.18ec	a5 11		lda $11				lda 	LowMemory+1
.18ee	48		pha				pha
.18ef	20 1e 11	jsr $111e			jsr 	AllocMemStackCount 			; allocate memory (in DIM code)
.18f2	68		pla				pla 								; update stack entry
.18f3	95 30		sta $30,x			sta 	esInt1,x
.18f5	68		pla				pla
.18f6	95 28		sta $28,x			sta 	esInt0,x
.18f8	a9 00		lda #$00			lda 	#0
.18fa	95 38		sta $38,x			sta 	esInt2,x
.18fc	95 40		sta $40,x			sta 	esInt3,x
.18fe	95 20		sta $20,x			sta 	esType,x
.1900	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/event.asm

.1901					Event_Function:
.1901	20 96 14	jsr $1496			jsr 	CheckLeftParen 				; check for (
.1904	a9 04		lda #$04			lda 	#4  						; this means ! ? and $ binary operators only work.
.1906	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX 			; this is the event variable.
.1909	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.190b	10 5d		bpl $196a			bpl 	_EFSyntax 					; if not, syntax error.
.190d	20 90 14	jsr $1490			jsr 	CheckComma
.1910	e8		inx				inx
.1911	20 9c 16	jsr $169c			jsr 	EvaluateTOSDeRef 			; get the rate
.1914	ca		dex				dex
.1915	20 a8 14	jsr $14a8			jsr 	CheckRightParen 			; closing bracket.
.1918	20 16 10	jsr $1016			jsr 	XTUpdateClock
.191b	98		tya				tya
.191c	48		pha				pha
.191d	b5 28		lda $28,x			lda 	esInt0,x 					; point temp0 to the variable
.191f	85 04		sta $04				sta 	temp0
.1921	b5 30		lda $30,x			lda 	esInt1,x
.1923	85 05		sta $05				sta 	temp0+1
.1925	a0 00		ldy #$00			ldy 	#0 							; check if zero, if so initialise/return FLASE
.1927	b1 04		lda ($04),y			lda 	(temp0),y
.1929	c8		iny				iny
.192a	11 04		ora ($04),y			ora 	(temp0),y
.192c	f0 1b		beq $1949			beq 	_EFInitialise
.192e	a0 00		ldy #$00			ldy 	#0 							; calc timer - variable
.1930	ad a0 08	lda $08a0			lda 	ClockTicks
.1933	d1 04		cmp ($04),y			cmp 	(temp0),y
.1935	c8		iny				iny
.1936	ad a1 08	lda $08a1			lda 	ClockTicks+1
.1939	f1 04		sbc ($04),y			sbc 	(temp0),y
.193b	10 06		bpl $1943			bpl 	_EFFire						; if >= reset and return TRUE
.193d	20 3a 1e	jsr $1e3a			jsr 	Int32False					; otherwise just return FALSE
.1940	4c 67 19	jmp $1967			jmp 	_EFExit
.1943					_EFFire:
.1943	20 36 1e	jsr $1e36			jsr 	Int32True
.1946	4c 4c 19	jmp $194c			jmp 	_EFResetTimer
.1949					_EFInitialise:
.1949	20 3a 1e	jsr $1e3a			jsr 	Int32False 					; return FALSE
.194c					_EFResetTimer:
.194c	a0 00		ldy #$00			ldy 	#0 							; reset the variable to clock + rate.
.194e	18		clc				clc
.194f	ad a0 08	lda $08a0			lda 	ClockTicks
.1952	75 29		adc $29,x			adc 	esInt0+1,x
.1954	91 04		sta ($04),y			sta 	(temp0),y
.1956	c8		iny				iny
.1957	ad a1 08	lda $08a1			lda 	ClockTicks+1
.195a	75 31		adc $31,x			adc 	esInt1+1,x
.195c	91 04		sta ($04),y			sta 	(temp0),y
.195e	88		dey				dey									; check zero
.195f	11 04		ora ($04),y			ora 	(temp0),y
.1961	d0 04		bne $1967			bne 	_EFExit
.1963	a9 01		lda #$01			lda 	#1 							; if so set it to 1.
.1965	91 04		sta ($04),y			sta 	(temp0),y
.1967					_EFExit:
.1967	68		pla				pla
.1968	a8		tay				tay
.1969	60		rts				rts
.196a					_EFSyntax:
.196a	4c a7 1a	jmp $1aa7			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/functions/keyboard.asm

.196d					Unary_Inkey:
.196d	20 06 10	jsr $1006			jsr 	XTGetKey
.1970	95 28		sta $28,x			sta 	esInt0,x
.1972	4c 49 1e	jmp $1e49			jmp 	Int32Set8Bit
.1975					Unary_Get:
.1975	20 6d 19	jsr $196d			jsr 	Unary_Inkey
.1978	b5 28		lda $28,x			lda 	esInt0,x
.197a	f0 f9		beq $1975			beq 	Unary_Get
.197c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/timer.asm

.197d					Unary_Timer:
.197d	20 16 10	jsr $1016			jsr 	XTUpdateClock
.1980	ad a0 08	lda $08a0			lda 	ClockTicks
.1983	95 28		sta $28,x			sta 	esInt0,x
.1985	ad a1 08	lda $08a1			lda 	ClockTicks+1
.1988	95 30		sta $30,x			sta 	esInt1,x
.198a	ad a2 08	lda $08a2			lda 	ClockTicks+2
.198d	95 38		sta $38,x			sta 	esInt2,x
.198f	a9 00		lda #$00			lda 	#0
.1991	95 40		sta $40,x			sta 	esInt3,x
.1993	95 20		sta $20,x			sta 	esType,x
.1995	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/generated/errors.asm

.1996					EHandlerAssert:
.1996	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1999	41 73 73 65 72 74 20 46			.text "Assert Failed",0
>19a1	61 69 6c 65 64 00
.19a7					EHandlerBadIndex:
.19a7	20 bb 14	jsr $14bb		jsr	ErrorHandler
>19aa	57 72 6f 6e 67 20 4e 45			.text "Wrong NEXT index",0
>19b2	58 54 20 69 6e 64 65 78 00
.19bb					EHandlerBadProc:
.19bb	20 bb 14	jsr $14bb		jsr	ErrorHandler
>19be	55 6e 6b 6e 6f 77 6e 20			.text "Unknown Procedure",0
>19c6	50 72 6f 63 65 64 75 72 65 00
.19d0					EHandlerClosure:
.19d0	20 bb 14	jsr $14bb		jsr	ErrorHandler
>19d3	53 74 72 75 63 74 75 72			.text "Structure Error",0
>19db	65 20 45 72 72 6f 72 00
.19e3					EHandlerDivideZero:
.19e3	20 bb 14	jsr $14bb		jsr	ErrorHandler
>19e6	44 69 76 69 64 65 20 62			.text "Divide by Zero",0
>19ee	79 20 5a 65 72 6f 00
.19f5					EHandlerLineNumber:
.19f5	20 bb 14	jsr $14bb		jsr	ErrorHandler
>19f8	55 6e 6b 6e 6f 77 6e 20			.text "Unknown line",0
>1a00	6c 69 6e 65 00
.1a05					EHandlerMemory:
.1a05	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1a08	49 6e 73 75 66 66 69 63			.text "Insufficient Memory",0
>1a10	69 65 6e 74 20 4d 65 6d 6f 72 79 00
.1a1c					EHandlerNoGosub:
.1a1c	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1a1f	52 65 74 75 72 6e 20 77			.text "Return without Gosub",0
>1a27	69 74 68 6f 75 74 20 47 6f 73 75 62 00
.1a34					EHandlerNoProc:
.1a34	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1a37	45 6e 64 50 72 6f 63 20			.text "EndProc without Proc",0
>1a3f	77 69 74 68 6f 75 74 20 50 72 6f 63 00
.1a4c					EHandlerNoRepeat:
.1a4c	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1a4f	55 6e 74 69 6c 20 77 69			.text "Until without Repeat",0
>1a57	74 68 6f 75 74 20 52 65 70 65 61 74 00
.1a64					EHandlerNoWhile:
.1a64	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1a67	57 65 6e 64 20 77 69 74			.text "Wend without While",0
>1a6f	68 6f 75 74 20 57 68 69 6c 65 00
.1a7a					EHandlerNotImplemented:
.1a7a	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1a7d	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>1a85	65 6d 65 6e 74 65 64 00
.1a8d					EHandlerParameters:
.1a8d	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1a90	42 61 64 20 50 61 72 61			.text "Bad Parameters",0
>1a98	6d 65 74 65 72 73 00
.1a9f					EHandlerStop:
.1a9f	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1aa2	53 74 6f 70 00				.text "Stop",0
.1aa7					EHandlerSyntax:
.1aa7	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1aaa	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>1ab2	72 72 6f 72 00
.1ab7					EHandlerTypeMismatch:
.1ab7	20 bb 14	jsr $14bb		jsr	ErrorHandler
>1aba	54 79 70 65 20 4d 69 73			.text "Type Mismatch",0
>1ac2	6d 61 74 63 68 00

;******  Return to file: basic.asm


;******  Processing file: common/generated/keytypes.asm

.1ac8					KeywordTypes:
>1ac8	81					.byte $81 ; $80 <<end>>
>1ac9	01					.byte $01 ; $81 and
>1aca	01					.byte $01 ; $82 or
>1acb	01					.byte $01 ; $83 xor
>1acc	02					.byte $02 ; $84 >
>1acd	02					.byte $02 ; $85 <
>1ace	02					.byte $02 ; $86 >=
>1acf	02					.byte $02 ; $87 <=
>1ad0	02					.byte $02 ; $88 <>
>1ad1	02					.byte $02 ; $89 =
>1ad2	03					.byte $03 ; $8a +
>1ad3	03					.byte $03 ; $8b -
>1ad4	04					.byte $04 ; $8c *
>1ad5	04					.byte $04 ; $8d /
>1ad6	04					.byte $04 ; $8e %
>1ad7	04					.byte $04 ; $8f >>
>1ad8	04					.byte $04 ; $90 <<
>1ad9	05					.byte $05 ; $91 !
>1ada	05					.byte $05 ; $92 ?
>1adb	05					.byte $05 ; $93 $
>1adc	40					.byte $40 ; $94 ~
>1add	40					.byte $40 ; $95 (
>1ade	40					.byte $40 ; $96 &
>1adf	40					.byte $40 ; $97 @
>1ae0	40					.byte $40 ; $98 len
>1ae1	40					.byte $40 ; $99 sgn
>1ae2	40					.byte $40 ; $9a abs
>1ae3	40					.byte $40 ; $9b random
>1ae4	40					.byte $40 ; $9c page
>1ae5	40					.byte $40 ; $9d true
>1ae6	40					.byte $40 ; $9e false
>1ae7	40					.byte $40 ; $9f min
>1ae8	40					.byte $40 ; $a0 max
>1ae9	40					.byte $40 ; $a1 sys
>1aea	40					.byte $40 ; $a2 code
>1aeb	40					.byte $40 ; $a3 timer
>1aec	40					.byte $40 ; $a4 event
>1aed	40					.byte $40 ; $a5 get
>1aee	40					.byte $40 ; $a6 joy.x
>1aef	40					.byte $40 ; $a7 joy.y
>1af0	40					.byte $40 ; $a8 joy.btn
>1af1	40					.byte $40 ; $a9 inkey
>1af2	40					.byte $40 ; $aa alloc
>1af3	40					.byte $40 ; $ab chr
>1af4	81					.byte $81 ; $ac ,
>1af5	81					.byte $81 ; $ad ;
>1af6	81					.byte $81 ; $ae )
>1af7	81					.byte $81 ; $af ++
>1af8	81					.byte $81 ; $b0 --
>1af9	81					.byte $81 ; $b1 [
>1afa	81					.byte $81 ; $b2 ]
>1afb	82					.byte $82 ; $b3 if
>1afc	82					.byte $82 ; $b4 for
>1afd	82					.byte $82 ; $b5 repeat
>1afe	82					.byte $82 ; $b6 proc
>1aff	82					.byte $82 ; $b7 while
>1b00	80					.byte $80 ; $b8 endif
>1b01	80					.byte $80 ; $b9 next
>1b02	80					.byte $80 ; $ba until
>1b03	80					.byte $80 ; $bb endproc
>1b04	80					.byte $80 ; $bc wend
>1b05	81					.byte $81 ; $bd rem
>1b06	81					.byte $81 ; $be let
>1b07	81					.byte $81 ; $bf '
>1b08	81					.byte $81 ; $c0 :
>1b09	81					.byte $81 ; $c1 then
>1b0a	81					.byte $81 ; $c2 else
>1b0b	81					.byte $81 ; $c3 to
>1b0c	81					.byte $81 ; $c4 step
>1b0d	81					.byte $81 ; $c5 vdu
>1b0e	81					.byte $81 ; $c6 print
>1b0f	81					.byte $81 ; $c7 call
>1b10	81					.byte $81 ; $c8 local
>1b11	81					.byte $81 ; $c9 goto
>1b12	81					.byte $81 ; $ca gosub
>1b13	81					.byte $81 ; $cb return
>1b14	81					.byte $81 ; $cc assert
>1b15	81					.byte $81 ; $cd stop
>1b16	81					.byte $81 ; $ce end
>1b17	81					.byte $81 ; $cf dim
>1b18	81					.byte $81 ; $d0 clear
>1b19	81					.byte $81 ; $d1 load
>1b1a	81					.byte $81 ; $d2 save
>1b1b	81					.byte $81 ; $d3 list
>1b1c	81					.byte $81 ; $d4 new
>1b1d	81					.byte $81 ; $d5 run

;******  Return to file: basic.asm


;******  Processing file: common/generated/vectors.asm

.1b1e					TokenVectorLow:
>1b1e	30					.byte CommandNextLine & $FF            ; <<end>>
>1b1f	80					.byte BinaryAnd & $FF                  ; and
>1b20	75					.byte BinaryOr & $FF                   ; or
>1b21	6a					.byte BinaryXor & $FF                  ; xor
>1b22	0d					.byte Binary_Greater & $FF             ; >
>1b23	f8					.byte Binary_Less & $FF                ; <
>1b24	ff					.byte Binary_GreaterEqual & $FF        ; >=
>1b25	06					.byte Binary_LessEqual & $FF           ; <=
>1b26	f1					.byte Binary_NotEqual & $FF            ; <>
>1b27	e4					.byte Binary_Equal & $FF               ; =
>1b28	22					.byte BinaryAdd & $FF                  ; +
>1b29	2d					.byte BinarySub & $FF                  ; -
>1b2a	38					.byte BinaryMult & $FF                 ; *
>1b2b	43					.byte BinaryDivide & $FF               ; /
>1b2c	51					.byte BinaryModulus & $FF              ; %
>1b2d	9d					.byte BinaryShiftRight & $FF           ; >>
>1b2e	8b					.byte BinaryShiftLeft & $FF            ; <<
>1b2f	c3					.byte IndirectWord & $FF               ; !
>1b30	ce					.byte IndirectByte & $FF               ; ?
>1b31	d9					.byte IndirectString & $FF             ; $
>1b32	56					.byte UnaryNot & $FF                   ; ~
>1b33	f4					.byte UnaryParenthesis & $FF           ; (
>1b34	a4					.byte UnaryHexMarker & $FF             ; &
>1b35	92					.byte UnaryRefToValue & $FF            ; @
>1b36	af					.byte UnaryLen & $FF                   ; len
>1b37	4b					.byte UnarySgn1 & $FF                  ; sgn
>1b38	03					.byte UnaryAbs & $FF                   ; abs
>1b39	a7					.byte UnaryRandom & $FF                ; random
>1b3a	e8					.byte UnaryPage & $FF                  ; page
>1b3b	fb					.byte UnaryTrue & $FF                  ; true
>1b3c	ff					.byte UnaryFalse & $FF                 ; false
>1b3d	61					.byte UnaryMin & $FF                   ; min
>1b3e	64					.byte UnaryMax & $FF                   ; max
>1b3f	0e					.byte UnarySys & $FF                   ; sys
>1b40	03					.byte InstructionUndefined & $FF       ; code
>1b41	7d					.byte Unary_Timer & $FF                ; timer
>1b42	01					.byte Event_Function & $FF             ; event
>1b43	75					.byte Unary_Get & $FF                  ; get
>1b44	03					.byte InstructionUndefined & $FF       ; joy.x
>1b45	03					.byte InstructionUndefined & $FF       ; joy.y
>1b46	03					.byte InstructionUndefined & $FF       ; joy.btn
>1b47	6d					.byte Unary_Inkey & $FF                ; inkey
>1b48	e6					.byte Unary_Alloc & $FF                ; alloc
>1b49	ce					.byte UnaryChr & $FF                   ; chr
>1b4a	b8					.byte NoOp1 & $FF                      ; ,
>1b4b	b8					.byte NoOp2 & $FF                      ; ;
>1b4c	b8					.byte NoOp3 & $FF                      ; )
>1b4d	03					.byte InstructionUndefined & $FF       ; ++
>1b4e	03					.byte InstructionUndefined & $FF       ; --
>1b4f	03					.byte InstructionUndefined & $FF       ; [
>1b50	03					.byte InstructionUndefined & $FF       ; ]
>1b51	97					.byte Command_IF & $FF                 ; if
>1b52	3f					.byte Command_FOR & $FF                ; for
>1b53	ec					.byte Command_Repeat & $FF             ; repeat
>1b54	b8					.byte NoOp6 & $FF                      ; proc
>1b55	62					.byte Command_While & $FF              ; while
>1b56	c8					.byte Command_ENDIF & $FF              ; endif
>1b57	8f					.byte Command_NEXT & $FF               ; next
>1b58	f5					.byte Command_Until & $FF              ; until
>1b59	a2					.byte Command_EndProc & $FF            ; endproc
>1b5a	7f					.byte Command_Wend & $FF               ; wend
>1b5b	cc					.byte Command_Rem & $FF                ; rem
>1b5c	c9					.byte Command_LET & $FF                ; let
>1b5d	cc					.byte Command_Rem2 & $FF               ; '
>1b5e	4a					.byte Command_Colon & $FF              ; :
>1b5f	b8					.byte NoOp7 & $FF                      ; then
>1b60	c2					.byte Command_ELSE & $FF               ; else
>1b61	b8					.byte NoOp8 & $FF                      ; to
>1b62	b8					.byte NoOp9 & $FF                      ; step
>1b63	51					.byte Command_Vdu & $FF                ; vdu
>1b64	32					.byte Command_Print & $FF              ; print
>1b65	9e					.byte Command_Call & $FF               ; call
>1b66	b6					.byte Command_Local & $FF              ; local
>1b67	52					.byte Command_Goto & $FF               ; goto
>1b68	33					.byte Command_Gosub & $FF              ; gosub
>1b69	41					.byte Command_Return & $FF             ; return
>1b6a	6a					.byte Command_Assert & $FF             ; assert
>1b6b	4e					.byte Command_Stop & $FF               ; stop
>1b6c	4b					.byte Command_End & $FF                ; end
>1b6d	c3					.byte Command_Dim & $FF                ; dim
>1b6e	95					.byte CommandClear & $FF               ; clear
>1b6f	03					.byte InstructionUndefined & $FF       ; load
>1b70	03					.byte InstructionUndefined & $FF       ; save
>1b71	03					.byte InstructionUndefined & $FF       ; list
>1b72	2a					.byte Command_New & $FF                ; new
>1b73	0f					.byte Command_Run & $FF                ; run
.1b74					TokenVectorHigh:
>1b74	14					.byte CommandNextLine >> 8             ; <<end>>
>1b75	15					.byte BinaryAnd >> 8                   ; and
>1b76	15					.byte BinaryOr >> 8                    ; or
>1b77	15					.byte BinaryXor >> 8                   ; xor
>1b78	16					.byte Binary_Greater >> 8              ; >
>1b79	15					.byte Binary_Less >> 8                 ; <
>1b7a	15					.byte Binary_GreaterEqual >> 8         ; >=
>1b7b	16					.byte Binary_LessEqual >> 8            ; <=
>1b7c	15					.byte Binary_NotEqual >> 8             ; <>
>1b7d	15					.byte Binary_Equal >> 8                ; =
>1b7e	15					.byte BinaryAdd >> 8                   ; +
>1b7f	15					.byte BinarySub >> 8                   ; -
>1b80	15					.byte BinaryMult >> 8                  ; *
>1b81	15					.byte BinaryDivide >> 8                ; /
>1b82	15					.byte BinaryModulus >> 8               ; %
>1b83	15					.byte BinaryShiftRight >> 8            ; >>
>1b84	15					.byte BinaryShiftLeft >> 8             ; <<
>1b85	15					.byte IndirectWord >> 8                ; !
>1b86	15					.byte IndirectByte >> 8                ; ?
>1b87	15					.byte IndirectString >> 8              ; $
>1b88	18					.byte UnaryNot >> 8                    ; ~
>1b89	17					.byte UnaryParenthesis >> 8            ; (
>1b8a	18					.byte UnaryHexMarker >> 8              ; &
>1b8b	18					.byte UnaryRefToValue >> 8             ; @
>1b8c	18					.byte UnaryLen >> 8                    ; len
>1b8d	18					.byte UnarySgn1 >> 8                   ; sgn
>1b8e	18					.byte UnaryAbs >> 8                    ; abs
>1b8f	18					.byte UnaryRandom >> 8                 ; random
>1b90	17					.byte UnaryPage >> 8                   ; page
>1b91	17					.byte UnaryTrue >> 8                   ; true
>1b92	17					.byte UnaryFalse >> 8                  ; false
>1b93	18					.byte UnaryMin >> 8                    ; min
>1b94	18					.byte UnaryMax >> 8                    ; max
>1b95	18					.byte UnarySys >> 8                    ; sys
>1b96	15					.byte InstructionUndefined >> 8        ; code
>1b97	19					.byte Unary_Timer >> 8                 ; timer
>1b98	19					.byte Event_Function >> 8              ; event
>1b99	19					.byte Unary_Get >> 8                   ; get
>1b9a	15					.byte InstructionUndefined >> 8        ; joy.x
>1b9b	15					.byte InstructionUndefined >> 8        ; joy.y
>1b9c	15					.byte InstructionUndefined >> 8        ; joy.btn
>1b9d	19					.byte Unary_Inkey >> 8                 ; inkey
>1b9e	18					.byte Unary_Alloc >> 8                 ; alloc
>1b9f	18					.byte UnaryChr >> 8                    ; chr
>1ba0	14					.byte NoOp1 >> 8                       ; ,
>1ba1	14					.byte NoOp2 >> 8                       ; ;
>1ba2	14					.byte NoOp3 >> 8                       ; )
>1ba3	15					.byte InstructionUndefined >> 8        ; ++
>1ba4	15					.byte InstructionUndefined >> 8        ; --
>1ba5	15					.byte InstructionUndefined >> 8        ; [
>1ba6	15					.byte InstructionUndefined >> 8        ; ]
>1ba7	12					.byte Command_IF >> 8                  ; if
>1ba8	11					.byte Command_FOR >> 8                 ; for
>1ba9	13					.byte Command_Repeat >> 8              ; repeat
>1baa	14					.byte NoOp6 >> 8                       ; proc
>1bab	14					.byte Command_While >> 8               ; while
>1bac	12					.byte Command_ENDIF >> 8               ; endif
>1bad	11					.byte Command_NEXT >> 8                ; next
>1bae	13					.byte Command_Until >> 8               ; until
>1baf	1e					.byte Command_EndProc >> 8             ; endproc
>1bb0	14					.byte Command_Wend >> 8                ; wend
>1bb1	13					.byte Command_Rem >> 8                 ; rem
>1bb2	12					.byte Command_LET >> 8                 ; let
>1bb3	13					.byte Command_Rem2 >> 8                ; '
>1bb4	14					.byte Command_Colon >> 8               ; :
>1bb5	14					.byte NoOp7 >> 8                       ; then
>1bb6	12					.byte Command_ELSE >> 8                ; else
>1bb7	14					.byte NoOp8 >> 8                       ; to
>1bb8	14					.byte NoOp9 >> 8                       ; step
>1bb9	14					.byte Command_Vdu >> 8                 ; vdu
>1bba	13					.byte Command_Print >> 8               ; print
>1bbb	1e					.byte Command_Call >> 8                ; call
>1bbc	1e					.byte Command_Local >> 8               ; local
>1bbd	12					.byte Command_Goto >> 8                ; goto
>1bbe	12					.byte Command_Gosub >> 8               ; gosub
>1bbf	12					.byte Command_Return >> 8              ; return
>1bc0	10					.byte Command_Assert >> 8              ; assert
>1bc1	14					.byte Command_Stop >> 8                ; stop
>1bc2	14					.byte Command_End >> 8                 ; end
>1bc3	10					.byte Command_Dim >> 8                 ; dim
>1bc4	10					.byte CommandClear >> 8                ; clear
>1bc5	15					.byte InstructionUndefined >> 8        ; load
>1bc6	15					.byte InstructionUndefined >> 8        ; save
>1bc7	15					.byte InstructionUndefined >> 8        ; list
>1bc8	13					.byte Command_New >> 8                 ; new
>1bc9	14					.byte Command_Run >> 8                 ; run

;******  Return to file: basic.asm


;******  Processing file: common/math/int32binary.asm

.1bca					Int32And:
.1bca	b5 28		lda $28,x			lda 	esInt0,x
.1bcc	35 29		and $29,x			and 	esInt0+1,x
.1bce	95 28		sta $28,x			sta 	esInt0,x
.1bd0	b5 30		lda $30,x			lda 	esInt1,x
.1bd2	35 31		and $31,x			and 	esInt1+1,x
.1bd4	95 30		sta $30,x			sta 	esInt1,x
.1bd6	b5 38		lda $38,x			lda 	esInt2,x
.1bd8	35 39		and $39,x			and 	esInt2+1,x
.1bda	95 38		sta $38,x			sta 	esInt2,x
.1bdc	b5 40		lda $40,x			lda 	esInt3,x
.1bde	35 41		and $41,x			and 	esInt3+1,x
.1be0	95 40		sta $40,x			sta 	esInt3,x
.1be2	60		rts				rts
.1be3					Int32Or:
.1be3	b5 28		lda $28,x			lda 	esInt0,x
.1be5	15 29		ora $29,x			ora 	esInt0+1,x
.1be7	95 28		sta $28,x			sta 	esInt0,x
.1be9	b5 30		lda $30,x			lda 	esInt1,x
.1beb	15 31		ora $31,x			ora 	esInt1+1,x
.1bed	95 30		sta $30,x			sta 	esInt1,x
.1bef	b5 38		lda $38,x			lda 	esInt2,x
.1bf1	15 39		ora $39,x			ora 	esInt2+1,x
.1bf3	95 38		sta $38,x			sta 	esInt2,x
.1bf5	b5 40		lda $40,x			lda 	esInt3,x
.1bf7	15 41		ora $41,x			ora 	esInt3+1,x
.1bf9	95 40		sta $40,x			sta 	esInt3,x
.1bfb	60		rts				rts
.1bfc					Int32Xor:
.1bfc	b5 28		lda $28,x			lda 	esInt0,x
.1bfe	55 29		eor $29,x			eor 	esInt0+1,x
.1c00	95 28		sta $28,x			sta 	esInt0,x
.1c02	b5 30		lda $30,x			lda 	esInt1,x
.1c04	55 31		eor $31,x			eor 	esInt1+1,x
.1c06	95 30		sta $30,x			sta 	esInt1,x
.1c08	b5 38		lda $38,x			lda 	esInt2,x
.1c0a	55 39		eor $39,x			eor 	esInt2+1,x
.1c0c	95 38		sta $38,x			sta 	esInt2,x
.1c0e	b5 40		lda $40,x			lda 	esInt3,x
.1c10	55 41		eor $41,x			eor 	esInt3+1,x
.1c12	95 40		sta $40,x			sta 	esInt3,x
.1c14	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32compare.asm

.1c15					Int32Equal:
.1c15	b5 28		lda $28,x			lda 	esInt0,x
.1c17	d5 29		cmp $29,x			cmp 	esInt0+1,x
.1c19	d0 2b		bne $1c46			bne 	Int32CFail
.1c1b	b5 30		lda $30,x			lda 	esInt1,x
.1c1d	d5 31		cmp $31,x			cmp 	esInt1+1,x
.1c1f	d0 25		bne $1c46			bne 	Int32CFail
.1c21	b5 38		lda $38,x			lda 	esInt2,x
.1c23	d5 39		cmp $39,x			cmp 	esInt2+1,x
.1c25	d0 1f		bne $1c46			bne 	Int32CFail
.1c27	b5 40		lda $40,x			lda 	esInt3,x
.1c29	d5 41		cmp $41,x			cmp 	esInt3+1,x
.1c2b	d0 19		bne $1c46			bne 	Int32CFail
.1c2d					Int32CSucceed:
.1c2d	38		sec				sec
.1c2e	60		rts				rts
.1c2f					Int32Less:
.1c2f	38		sec				sec
.1c30	b5 28		lda $28,x			lda		esInt0,x
.1c32	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1c34	b5 30		lda $30,x			lda		esInt1,x
.1c36	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1c38	b5 38		lda $38,x			lda		esInt2,x
.1c3a	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1c3c	b5 40		lda $40,x			lda		esInt3,x
.1c3e	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1c40	50 02		bvc $1c44			bvc 	_I32LNoOverflow
.1c42	49 80		eor #$80			eor 	#$80
.1c44					_I32LNoOverflow
.1c44	30 e7		bmi $1c2d			bmi 	Int32CSucceed
.1c46					Int32CFail:
.1c46	18		clc				clc
.1c47	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32divide.asm

.1c48					Int32SDivide:
.1c48	98		tya				tya  								; save Y, which is the count of negations
.1c49	48		pha				pha
.1c4a	a0 00		ldy #$00			ldy 	#0 							; zero count
.1c4c	20 64 1c	jsr $1c64			jsr 	_Int32SRemSign 				; unsign TOS
.1c4f	e8		inx				inx 								; unsign TOS+1
.1c50	20 64 1c	jsr $1c64			jsr 	_Int32SRemSign
.1c53	ca		dex				dex
.1c54	98		tya				tya 								; save sign count on stack
.1c55	48		pha				pha
.1c56	20 6d 1c	jsr $1c6d			jsr 	Int32UDivide 				; unsigned division
.1c59	68		pla				pla 								; get sign count back
.1c5a	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.1c5c	f0 03		beq $1c61			beq 	_I32SNoNeg
.1c5e	20 f4 1d	jsr $1df4			jsr 	Int32Negate
.1c61					_I32SNoNeg:
.1c61	68		pla				pla 								; restoe Y and exit
.1c62	a8		tay				tay
.1c63	60		rts				rts
.1c64					_Int32SRemSign:
.1c64	b5 40		lda $40,x			lda 	esInt3,x 					; is it -ve
.1c66	10 04		bpl $1c6c			bpl 	_Int32SRSExit
.1c68	c8		iny				iny 								; increment the sign count
.1c69	20 f4 1d	jsr $1df4			jsr 	Int32Negate 				; negate the value.
.1c6c					_Int32SRSExit:
.1c6c	60		rts				rts
.1c6d					Int32UDivide:
.1c6d	e8		inx				inx 								; clear A
.1c6e	e8		inx				inx
.1c6f	20 3a 1e	jsr $1e3a			jsr 	Int32False
.1c72	ca		dex				dex
.1c73	ca		dex				dex
.1c74	98		tya				tya 								; save Y on the stack
.1c75	48		pha				pha
.1c76	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.1c78					_Int32UDLoop:
.1c78	16 28		asl $28,x			asl 	esInt0,x					; shift QA left. First Q
.1c7a	36 30		rol $30,x			rol 	esInt1,x
.1c7c	36 38		rol $38,x			rol 	esInt2,x
.1c7e	36 40		rol $40,x			rol 	esInt3,x
.1c80	36 2a		rol $2a,x			rol 	esInt0+2,x 					; then A.
.1c82	36 32		rol $32,x			rol 	esInt1+2,x
.1c84	36 3a		rol $3a,x			rol 	esInt2+2,x
.1c86	36 42		rol $42,x			rol 	esInt3+2,x
.1c88	38		sec				sec 								; calculate A-M saving result on the stack
.1c89	b5 2a		lda $2a,x			lda 	esInt0+2,x
.1c8b	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1c8d	48		pha				pha
.1c8e	b5 32		lda $32,x			lda 	esInt1+2,x
.1c90	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1c92	48		pha				pha
.1c93	b5 3a		lda $3a,x			lda 	esInt2+2,x
.1c95	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1c97	48		pha				pha
.1c98	b5 42		lda $42,x			lda 	esInt3+2,x
.1c9a	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1c9c	90 10		bcc $1cae			bcc		_Int32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.1c9e	95 42		sta $42,x			sta 	esInt3+2,x 					; write result back to A
.1ca0	68		pla				pla
.1ca1	95 3a		sta $3a,x			sta 	esInt2+2,x
.1ca3	68		pla				pla
.1ca4	95 32		sta $32,x			sta 	esInt1+2,x
.1ca6	68		pla				pla
.1ca7	95 2a		sta $2a,x			sta 	esInt0+2,x
.1ca9	f6 28		inc $28,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.1cab	4c b1 1c	jmp $1cb1			jmp 	_Int32Next 					; do the next iteration
.1cae					_Int32NoSubtract:
.1cae	68		pla				pla
.1caf	68		pla				pla
.1cb0	68		pla				pla
.1cb1					_Int32Next:
.1cb1	88		dey				dey 								; do this 32 times.
.1cb2	d0 c4		bne $1c78			bne 	_Int32UDLoop
.1cb4	68		pla				pla 								; restore Y and exit
.1cb5	a8		tay				tay
.1cb6	60		rts				rts
.1cb7					Int32Modulus:
.1cb7	20 6d 1c	jsr $1c6d			jsr 	Int32UDivide 				; do the division.
.1cba	b5 42		lda $42,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.1cbc	95 40		sta $40,x			sta 	esInt3,x
.1cbe	b5 3a		lda $3a,x			lda 	esInt2+2,x
.1cc0	95 38		sta $38,x			sta 	esInt2,x
.1cc2	b5 32		lda $32,x			lda 	esInt1+2,x
.1cc4	95 30		sta $30,x			sta 	esInt1,x
.1cc6	b5 2a		lda $2a,x			lda 	esInt0+2,x
.1cc8	95 28		sta $28,x			sta 	esInt0,x
.1cca	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32fromstr.asm

.1ccb					Int32FromString:
.1ccb	85 03		sta $03				sta 	tempShort 					; save base
.1ccd	98		tya				tya
.1cce	48		pha				pha
.1ccf	a0 00		ldy #$00			ldy 	#0 							; set index into string being read
.1cd1	b1 04		lda ($04),y			lda 	(temp0),y 					; look at first character
.1cd3	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.1cd5	d0 01		bne $1cd8			bne 	_I32FSNotNegative
.1cd7	c8		iny				iny 								; if so consume it.
.1cd8					_I32FSNotNegative:
.1cd8	a5 03		lda $03				lda 	tempShort 					; get the base back.
.1cda	c0 00		cpy #$00			cpy 	#0 							; if we read a -ve (e.g. Y != 0)
.1cdc	f0 02		beq $1ce0			beq 	_I32FSNN2
.1cde	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.1ce0					_I32FSNN2:
.1ce0	48		pha				pha 								; save base + final sign on stack.
.1ce1	20 3a 1e	jsr $1e3a			jsr 	Int32False 					; zero the return value.
.1ce4					I32FSMainLoop:
.1ce4	68		pla				pla 								; get the base back into tempshort
.1ce5	48		pha				pha
.1ce6	29 7f		and #$7f			and 	#$7F
.1ce8	85 03		sta $03				sta 	tempShort
.1cea	b1 04		lda ($04),y			lda 	(temp0),y 					; look at next character.
.1cec	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.1cee	90 02		bcc $1cf2			bcc 	_I32FSNotLC
.1cf0	e9 20		sbc #$20			sbc 	#32
.1cf2					_I32FSNotLC:
.1cf2	38		sec				sec 								; subtract 48 (ASCII "0")
.1cf3	e9 30		sbc #$30			sbc 	#"0"
.1cf5	90 26		bcc $1d1d			bcc 	_I32FSDone 					; nothing more to do.
.1cf7	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.1cf9	90 06		bcc $1d01			bcc 	_I32FSValidate
.1cfb	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.1cfd	90 1e		bcc $1d1d			bcc 	_I32FSDone
.1cff	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.1d01					_I32FSValidate:
.1d01	c5 03		cmp $03				cmp 	tempShort 					; compare against the base.
.1d03	b0 18		bcs $1d1d			bcs 	_I32FSDone 					; sorry, too large for this base.
.1d05	48		pha				pha 								; save the new digit value.
.1d06	e8		inx				inx 								; put base into next slot.
.1d07	a5 03		lda $03				lda 	tempShort
.1d09	20 49 1e	jsr $1e49			jsr 	Int32Set8Bit
.1d0c	ca		dex				dex
.1d0d	20 5f 1d	jsr $1d5f			jsr 	Int32Multiply 				; multiply current by the base
.1d10	e8		inx				inx
.1d11	68		pla				pla  								; put additive into next slot
.1d12	20 49 1e	jsr $1e49			jsr 	Int32Set8Bit
.1d15	ca		dex				dex
.1d16	20 2b 1d	jsr $1d2b			jsr 	Int32Add 					; and add it
.1d19	c8		iny				iny 								; look at next character
.1d1a	4c e4 1c	jmp $1ce4			jmp 	I32FSMainLoop 				; and go round again.
.1d1d					_I32FSDone:
.1d1d	68		pla				pla 								; get base/final sign back
.1d1e	10 04		bpl $1d24			bpl 	_I32FSNN3
.1d20	88		dey				dey 								; one fewer character to allow for the - prefix.
.1d21	20 f4 1d	jsr $1df4			jsr 	Int32Negate 				; negate the result.
.1d24					_I32FSNN3:
.1d24	84 03		sty $03				sty 	tempShort 					; save the count of characters read
.1d26	68		pla				pla
.1d27	a8		tay				tay
.1d28	a5 03		lda $03				lda 	tempShort 					; get the count of characters read into A and exit
.1d2a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32math.asm

.1d2b					Int32Add:
.1d2b	18		clc				clc
.1d2c	b5 28		lda $28,x			lda 	esInt0,x
.1d2e	75 29		adc $29,x			adc 	esInt0+1,x
.1d30	95 28		sta $28,x			sta 	esInt0,x
.1d32	b5 30		lda $30,x			lda 	esInt1,x
.1d34	75 31		adc $31,x			adc 	esInt1+1,x
.1d36	95 30		sta $30,x			sta 	esInt1,x
.1d38	b5 38		lda $38,x			lda 	esInt2,x
.1d3a	75 39		adc $39,x			adc 	esInt2+1,x
.1d3c	95 38		sta $38,x			sta 	esInt2,x
.1d3e	b5 40		lda $40,x			lda 	esInt3,x
.1d40	75 41		adc $41,x			adc 	esInt3+1,x
.1d42	95 40		sta $40,x			sta 	esInt3,x
.1d44	60		rts				rts
.1d45					Int32Sub:
.1d45	38		sec				sec
.1d46	b5 28		lda $28,x			lda 	esInt0,x
.1d48	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1d4a	95 28		sta $28,x			sta 	esInt0,x
.1d4c	b5 30		lda $30,x			lda 	esInt1,x
.1d4e	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1d50	95 30		sta $30,x			sta 	esInt1,x
.1d52	b5 38		lda $38,x			lda 	esInt2,x
.1d54	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1d56	95 38		sta $38,x			sta 	esInt2,x
.1d58	b5 40		lda $40,x			lda 	esInt3,x
.1d5a	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1d5c	95 40		sta $40,x			sta 	esInt3,x
.1d5e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32multiply.asm

.1d5f					Int32Multiply:
.1d5f	e8		inx				inx 								; copy 2nd -> 3rd
.1d60	20 85 1d	jsr $1d85			jsr 	Int32CopyUp
.1d63	ca		dex				dex
.1d64	20 85 1d	jsr $1d85			jsr 	Int32CopyUp 				; copy 1st -> 2nd
.1d67	20 3a 1e	jsr $1e3a			jsr 	Int32False 					; zero 1st.
.1d6a					_I32Loop:
.1d6a	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.1d6c	29 01		and #$01			and 	#1
.1d6e	f0 03		beq $1d73			beq 	_I32NoAdd 					; if set
.1d70	20 2b 1d	jsr $1d2b			jsr 	Int32Add 					; add 2nd to 1st.
.1d73					_I32NoAdd:
.1d73	e8		inx				inx 								; shift 2nd left
.1d74	20 4f 1e	jsr $1e4f			jsr 	Int32ShiftLeft
.1d77	e8		inx				inx  								; shift 3rd right
.1d78	20 58 1e	jsr $1e58			jsr 	Int32ShiftRight
.1d7b	20 61 1e	jsr $1e61			jsr 	Int32Zero 					; check if zero.
.1d7e	08		php				php 								; save status bits
.1d7f	ca		dex				dex 	 							; point back to 1st
.1d80	ca		dex				dex
.1d81	28		plp				plp 								; get status bits
.1d82	d0 e6		bne $1d6a			bne 	_I32Loop 					; if non-zero keep going.
.1d84	60		rts				rts
.1d85					Int32CopyUp:
.1d85	b5 28		lda $28,x			lda 	esInt0,x
.1d87	95 29		sta $29,x			sta 	esInt0+1,x
.1d89	b5 30		lda $30,x			lda 	esInt1,x
.1d8b	95 31		sta $31,x			sta 	esInt1+1,x
.1d8d	b5 38		lda $38,x			lda 	esInt2,x
.1d8f	95 39		sta $39,x			sta 	esInt2+1,x
.1d91	b5 40		lda $40,x			lda 	esInt3,x
.1d93	95 41		sta $41,x			sta 	esInt3+1,x
.1d95	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32tostr.asm

.1d96					Int32ToString:
.1d96	48		pha				pha 								; save base
.1d97	85 03		sta $03				sta 	tempShort 					; save target base.
.1d99	a9 00		lda #$00			lda 	#0
.1d9b	8d a4 08	sta $08a4			sta 	IToSCount 					; clear character count.
.1d9e	98		tya				tya
.1d9f	48		pha				pha
.1da0	a5 03		lda $03				lda 	tempShort 					; check if we are signed conversion
.1da2	10 10		bpl $1db4			bpl 	_I32TSUnsigned
.1da4	48		pha				pha 								; save base on stack.
.1da5	b5 40		lda $40,x			lda 	esInt3,x 					; is it actually negative
.1da7	10 08		bpl $1db1			bpl 	_I32TSNoFlip
.1da9	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.1dab	20 e0 1d	jsr $1de0			jsr 	I32WriteCharacter
.1dae	20 f4 1d	jsr $1df4			jsr 	Int32Negate 				; negate the value.
.1db1					_I32TSNoFlip:
.1db1	68		pla				pla 								; get the base back
.1db2	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.1db4					_I32TSUnsigned:
.1db4	20 bb 1d	jsr $1dbb			jsr 	I32DivideWrite 				; recursive code to output string.
.1db7	68		pla				pla
.1db8	a8		tay				tay
.1db9	68		pla				pla
.1dba	60		rts				rts
.1dbb					I32DivideWrite:
.1dbb	48		pha				pha 								; save the divisor/base
.1dbc	e8		inx				inx 								; write in the dividing position.
.1dbd	20 49 1e	jsr $1e49			jsr 	Int32Set8Bit
.1dc0	ca		dex				dex
.1dc1	20 6d 1c	jsr $1c6d			jsr 	Int32UDivide 				; divide number by base.
.1dc4	68		pla				pla 								; get the base into Y
.1dc5	a8		tay				tay
.1dc6	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.1dc8	48		pha				pha
.1dc9	20 61 1e	jsr $1e61			jsr 	Int32Zero 					; is the result zero ?
.1dcc	f0 04		beq $1dd2			beq 	_I32NoRecurse 				; if so, don't recurse.
.1dce	98		tya				tya 								; put base into A
.1dcf	20 bb 1d	jsr $1dbb			jsr 	I32DivideWrite 				; and jsr the dividor recursively.
.1dd2					_I32NoRecurse:
.1dd2	68		pla				pla 								; get the remainder back
.1dd3	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.1dd5	90 02		bcc $1dd9			bcc 	_I32NotHex
.1dd7	69 06		adc #$06			adc 	#7-1
.1dd9					_I32NotHex:
.1dd9	18		clc				clc 								; make it ASCII
.1dda	69 30		adc #$30			adc 	#48
.1ddc	20 e0 1d	jsr $1de0			jsr 	I32WriteCharacter 			; write the character out
.1ddf	60		rts				rts 								; and exit.
.1de0					I32WriteCharacter:
.1de0	ac a4 08	ldy $08a4			ldy 	IToSCount 					; get position
.1de3	91 04		sta ($04),y			sta 	(temp0),y 					; write out with trailing 0
.1de5	c8		iny				iny
.1de6	a9 00		lda #$00			lda 	#0
.1de8	91 04		sta ($04),y			sta 	(temp0),y
.1dea	ee a4 08	inc $08a4			inc 	IToSCount 					; bump count
.1ded	60		rts				rts
.1dee	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32unary.asm

.1def					Int32Absolute:
.1def	b5 40		lda $40,x			lda 	esInt3,x 					; use negate code if -ve.
.1df1	30 01		bmi $1df4			bmi 	Int32Negate
.1df3	60		rts				rts
.1df4					Int32Negate:
.1df4	38		sec				sec
.1df5	a9 00		lda #$00			lda 	#0
.1df7	f5 28		sbc $28,x			sbc 	esInt0,x
.1df9	95 28		sta $28,x			sta 	esInt0,x
.1dfb	a9 00		lda #$00			lda 	#0
.1dfd	f5 30		sbc $30,x			sbc 	esInt1,x
.1dff	95 30		sta $30,x			sta 	esInt1,x
.1e01	a9 00		lda #$00			lda 	#0
.1e03	f5 38		sbc $38,x			sbc 	esInt2,x
.1e05	95 38		sta $38,x			sta 	esInt2,x
.1e07	a9 00		lda #$00			lda 	#0
.1e09	f5 40		sbc $40,x			sbc 	esInt3,x
.1e0b	95 40		sta $40,x			sta 	esInt3,x
.1e0d	60		rts				rts
.1e0e					Int32Not:
.1e0e	b5 28		lda $28,x			lda 	esInt0,x
.1e10	49 ff		eor #$ff			eor 	#$FF
.1e12	95 28		sta $28,x			sta 	esInt0,x
.1e14	b5 30		lda $30,x			lda 	esInt1,x
.1e16	49 ff		eor #$ff			eor 	#$FF
.1e18	95 30		sta $30,x			sta 	esInt1,x
.1e1a	b5 38		lda $38,x			lda 	esInt2,x
.1e1c	49 ff		eor #$ff			eor 	#$FF
.1e1e	95 38		sta $38,x			sta 	esInt2,x
.1e20	b5 40		lda $40,x			lda 	esInt3,x
.1e22	49 ff		eor #$ff			eor 	#$FF
.1e24	95 40		sta $40,x			sta 	esInt3,x
.1e26	60		rts				rts
.1e27					Int32Sign:
.1e27	b5 40		lda $40,x			lda 	esInt3,x					; look at MSB
.1e29	30 0b		bmi $1e36			bmi 	Int32True 					; if set return -1 (true)
.1e2b	20 61 1e	jsr $1e61			jsr 	Int32Zero 					; is it zero ?
.1e2e	f0 0a		beq $1e3a			beq 	Int32False 					; if zero return 0 (false)
.1e30	20 3a 1e	jsr $1e3a			jsr 	Int32False 					; > 0 return 1
.1e33	f6 28		inc $28,x			inc 	esInt0,x
.1e35	60		rts				rts
.1e36					Int32True:
.1e36	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.1e38	d0 02		bne $1e3c			bne 	Int32WriteAll
.1e3a					Int32False:
.1e3a	a9 00		lda #$00			lda 	#0
.1e3c					Int32WriteAll:
.1e3c	95 28		sta $28,x			sta 	esInt0,x
.1e3e					Int32Write123:
.1e3e	95 30		sta $30,x			sta 	esInt1,x
.1e40	95 38		sta $38,x			sta 	esInt2,x
.1e42	95 40		sta $40,x			sta 	esInt3,x
.1e44	a9 00		lda #$00			lda 	#$00						; and make it an integer
.1e46	95 20		sta $20,x			sta 	esType,x
.1e48	60		rts				rts
.1e49					Int32Set8Bit:
.1e49	95 28		sta $28,x			sta 	esInt0,x
.1e4b	a9 00		lda #$00			lda 	#0
.1e4d	f0 ef		beq $1e3e			beq		Int32Write123
.1e4f					Int32ShiftLeft:
.1e4f	16 28		asl $28,x			asl 	esInt0,x
.1e51	36 30		rol $30,x			rol	 	esInt1,x
.1e53	36 38		rol $38,x			rol	 	esInt2,x
.1e55	36 40		rol $40,x			rol	 	esInt3,x
.1e57	60		rts				rts
.1e58					Int32ShiftRight:
.1e58	56 40		lsr $40,x			lsr 	esInt3,x
.1e5a	76 38		ror $38,x			ror 	esInt2,x
.1e5c	76 30		ror $30,x			ror 	esInt1,x
.1e5e	76 28		ror $28,x			ror 	esInt0,x
.1e60	60		rts				rts
.1e61					Int32Zero:
.1e61	b5 28		lda $28,x			lda 	esInt0,x
.1e63	15 30		ora $30,x			ora 	esInt1,x
.1e65	15 38		ora $38,x			ora 	esInt2,x
.1e67	15 40		ora $40,x			ora 	esInt3,x
.1e69	60		rts				rts
.1e6a					Int32Random:
.1e6a	98		tya				tya
.1e6b	48		pha				pha
.1e6c	a0 07		ldy #$07			ldy 	#7
.1e6e	ad 88 08	lda $0888			lda 	Seed32+0
.1e71	d0 03		bne $1e76			bne 	_Random1
.1e73	a8		tay				tay
.1e74	a9 aa		lda #$aa			lda		#$AA
.1e76					_Random1:
.1e76	0a		asl a				asl 	a
.1e77	2e 89 08	rol $0889			rol 	Seed32+1
.1e7a	2e 8a 08	rol $088a			rol 	Seed32+2
.1e7d	2e 8b 08	rol $088b			rol 	Seed32+3
.1e80	90 02		bcc $1e84			bcc 	_Random2
.1e82	49 c5		eor #$c5			eor 	#$C5
.1e84					_Random2:
.1e84	88		dey				dey
.1e85	d0 ef		bne $1e76			bne 	_Random1
.1e87	8d 88 08	sta $0888			sta 	Seed32+0
.1e8a	95 28		sta $28,x			sta 	esInt0,x
.1e8c	ad 89 08	lda $0889			lda 	Seed32+1
.1e8f	95 30		sta $30,x			sta 	esInt1,x
.1e91	ad 8a 08	lda $088a			lda 	Seed32+2
.1e94	95 38		sta $38,x			sta 	esInt2,x
.1e96	ad 8b 08	lda $088b			lda 	Seed32+3
.1e99	95 40		sta $40,x			sta 	esInt3,x
.1e9b	68		pla				pla
.1e9c	a8		tay				tay
.1e9d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/procedures/call.asm

.1e9e					Command_Call:
>1e9e	db						.byte 	$DB
.1e9f	4c 7a 1a	jmp $1a7a			jmp 	EHandlerNotImplemented

;******  Return to file: basic.asm


;******  Processing file: common/procedures/endproc.asm

.1ea2					Command_EndProc:
.1ea2	20 aa 20	jsr $20aa			jsr 	StackPopLocals 				; restore local variables.
.1ea5	a9 54		lda #$54			lda 	#SMProcedure				; check TOS is PROC
.1ea7	20 68 20	jsr $2068			jsr 	StackCheck
.1eaa	d0 07		bne $1eb3			bne 	_EPError
.1eac	20 87 20	jsr $2087			jsr 	StackLoadPosition 			; restore position and drop
.1eaf	20 73 20	jsr $2073			jsr 	StackClose
.1eb2	60		rts				rts
.1eb3					_EPError:
.1eb3	4c 34 1a	jmp $1a34			jmp 	EHandlerNoProc

;******  Return to file: basic.asm


;******  Processing file: common/procedures/local.asm

.1eb6					Command_Local:
.1eb6	20 cf 1e	jsr $1ecf			jsr 	GetLocalTerm 				; get a local variable.
.1eb9	98		tya				tya
.1eba	48		pha				pha
.1ebb	a0 00		ldy #$00			ldy 	#0 							; erase the variable.
.1ebd	98		tya				tya
.1ebe					_CLClear:
.1ebe	91 04		sta ($04),y			sta 	(temp0),y
.1ec0	c8		iny				iny
.1ec1	c0 04		cpy #$04			cpy 	#4
.1ec3	d0 f9		bne $1ebe			bne 	_CLClear
.1ec5	68		pla				pla
.1ec6	a8		tay				tay
.1ec7	b1 00		lda ($00),y			lda 	(codePtr),y					; check comma
.1ec9	c8		iny				iny
.1eca	c9 ac		cmp #$ac			cmp 	#KWD_COMMA
.1ecc	f0 e8		beq $1eb6			beq 	Command_Local
.1ece	60		rts				rts
.1ecf					GetLocalTerm:
.1ecf	8a		txa				txa
.1ed0	48		pha				pha
.1ed1	a2 00		ldx #$00			ldx 	#0 							; start on stack
.1ed3	a9 07		lda #$07			lda 	#7  						; get a term
.1ed5	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX 			; this is the variable/parameter to localise.
.1ed8	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.1eda	10 26		bpl $1f02			bpl 	_GLTSyntax 					; if not, syntax error.
.1edc	98		tya				tya
.1edd	48		pha				pha
.1ede	a9 67		lda #$67			lda 	#SMLocal 					; create stack frame.
.1ee0	20 43 20	jsr $2043			jsr 	StackOpen
.1ee3	a0 05		ldy #$05			ldy 	#5
.1ee5	b5 28		lda $28,x			lda 	esInt0,x 					; copy address to temp0 and to stack+5,stack+6
.1ee7	85 04		sta $04				sta 	temp0
.1ee9	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1eeb	b5 30		lda $30,x			lda 	esInt1,x
.1eed	85 05		sta $05				sta 	temp0+1
.1eef	c8		iny				iny
.1ef0	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1ef2	a0 00		ldy #$00			ldy 	#0 							; now copy data into stack1-4
.1ef4					_GLTCopy:
.1ef4	b1 04		lda ($04),y			lda 	(temp0),y
.1ef6	c8		iny				iny
.1ef7	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1ef9	c0 04		cpy #$04			cpy 	#4
.1efb	d0 f7		bne $1ef4			bne 	_GLTCopy
.1efd	68		pla				pla
.1efe	a8		tay				tay
.1eff	68		pla				pla
.1f00	aa		tax				tax
.1f01	60		rts				rts
.1f02					_GLTSyntax:
.1f02	4c a7 1a	jmp $1aa7			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/procedures/scanproc.asm

.1f05					BuildProcedureList:
.1f05	a9 00		lda #$00			lda 	#0 							; first link is zero
.1f07	8d a9 08	sta $08a9			sta 	ProcList
.1f0a	8d aa 08	sta $08aa			sta 	ProcList+1
.1f0d	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.1f0f	85 00		sta $00				sta 	codePtr
.1f11	a9 22		lda #$22			lda 	#(BasicProgram) >> 8
.1f13	85 01		sta $01				sta 	1+(codePtr)
.1f15					_BPLLoop:
.1f15	a0 00		ldy #$00			ldy 	#0 							; check at the end ?
.1f17	b1 00		lda ($00),y			lda 	(codePtr),y
.1f19	f0 1e		beq $1f39			beq	 	_BPLExit
.1f1b	a0 03		ldy #$03			ldy 	#3 							; look at first token.
.1f1d	b1 00		lda ($00),y			lda 	(codePtr),y
.1f1f	c9 b6		cmp #$b6			cmp 	#KWD_PROC					; if it is PROC
.1f21	d0 06		bne $1f29			bne 	_BPLNext
.1f23	20 3a 1f	jsr $1f3a			jsr 	ScanParameters 				; find the parameters
.1f26	20 7c 1f	jsr $1f7c			jsr 	CacheProcedure 				; cache it.
.1f29					_BPLNext:
.1f29	a0 00		ldy #$00			ldy 	#0 							; next line.
.1f2b	b1 00		lda ($00),y			lda 	(codePtr),y
.1f2d	18		clc				clc
.1f2e	65 00		adc $00				adc 	codePtr
.1f30	85 00		sta $00				sta 	codePtr
.1f32	90 e1		bcc $1f15			bcc 	_BPLLoop
.1f34	e6 01		inc $01				inc 	codePtr+1
.1f36	4c 15 1f	jmp $1f15			jmp 	_BPLLoop
.1f39					_BPLExit:
.1f39	60		rts				rts
.1f3a					ScanParameters:
.1f3a	98		tya				tya
.1f3b	48		pha				pha
.1f3c	a9 01		lda #$01			lda 	#1
.1f3e	8d 8c 08	sta $088c			sta 	Buffer 						; 'next free' in the buffer, start recording at Buffer+1
.1f41					_SPFindOpen:
.1f41	b1 00		lda ($00),y			lda 	(codePtr),y					; get next
.1f43	c8		iny				iny
.1f44	c9 95		cmp #$95			cmp 	#KWD_LPAREN 				; ( token ?
.1f46	d0 f9		bne $1f41			bne 	_SPFindOpen
.1f48					_SPGrabParams:
.1f48	b1 00		lda ($00),y			lda 	(codePtr),y 				; found ) ?
.1f4a	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN
.1f4c	f0 28		beq $1f76			beq 	_SPExit
.1f4e	a2 00		ldx #$00			ldx 	#0 							; start on stack
.1f50	a9 07		lda #$07			lda 	#7  						; get a term
.1f52	20 a6 16	jsr $16a6			jsr 	EvaluateLevelAX 			; this is the variable/parameter to localise.
.1f55	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.1f57	10 20		bpl $1f79			bpl 	SPSyntax 					; if not, syntax error.
.1f59	ae 8c 08	ldx $088c			ldx 	Buffer 						; write into Buffer in Hi-Lo order.
.1f5c	a5 30		lda $30				lda		esInt1
.1f5e	9d 8c 08	sta $088c,x			sta 	Buffer,x
.1f61	a5 28		lda $28				lda		esInt0
.1f63	9d 8d 08	sta $088d,x			sta 	Buffer+1,x
.1f66	e8		inx				inx
.1f67	e8		inx				inx
.1f68	8e 8c 08	stx $088c			stx 	Buffer
.1f6b	b1 00		lda ($00),y			lda 	(codePtr),y 				; found , ?
.1f6d	c8		iny				iny
.1f6e	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; if so, get next.
.1f70	f0 d6		beq $1f48			beq 	_SPGrabParams
.1f72	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN 				; if not )
.1f74	d0 03		bne $1f79			bne 	SPSyntax					; syntax error.
.1f76					_SPExit:
.1f76	68		pla				pla
.1f77	a8		tay				tay
.1f78	60		rts				rts
.1f79					SPSyntax:
.1f79	4c a7 1a	jmp $1aa7			jmp 	EHandlerSyntax
.1f7c					CacheProcedure:
.1f7c	a5 10		lda $10				lda 	LowMemory 					; push low memory (current addr) on the stack
.1f7e	48		pha				pha
.1f7f	a5 11		lda $11				lda 	LowMemory+1
.1f81	48		pha				pha
.1f82	ad a9 08	lda $08a9			lda 	ProcList 					; write out the previous entry
.1f85	20 e6 1f	jsr $1fe6			jsr 	CacheWrite
.1f88	ad aa 08	lda $08aa			lda 	ProcList+1
.1f8b	20 e6 1f	jsr $1fe6			jsr 	CacheWrite
.1f8e	68		pla				pla 								; write this one out as the current head of the linked procedure list.
.1f8f	8d aa 08	sta $08aa			sta 	ProcList+1
.1f92	68		pla				pla
.1f93	8d a9 08	sta $08a9			sta 	ProcList
.1f96	a2 00		ldx #$00			ldx 	#0 							; total
.1f98	a0 03		ldy #$03			ldy 	#3 	 						; after the 'PROC'-1
.1f9a					_CPCalculateHash:
.1f9a	c8		iny				iny 								; next
.1f9b	8a		txa				txa 								; add to count.
.1f9c	18		clc				clc
.1f9d	71 00		adc ($00),y			adc 	(codePtr),y
.1f9f	aa		tax				tax
.1fa0	b1 00		lda ($00),y			lda 	(codePtr),y 				; end of name (e.g. $00-$2F)
.1fa2	c9 30		cmp #$30			cmp 	#$30
.1fa4	b0 f4		bcs $1f9a			bcs 	_CPCalculateHash
.1fa6	98		tya				tya
.1fa7	48		pha				pha
.1fa8	8a		txa				txa
.1fa9	20 e6 1f	jsr $1fe6			jsr 	CacheWrite 					; write the hash out.
.1fac	a5 00		lda $00				lda 	codePtr 					; write code position of line out in lo/high
.1fae	20 e6 1f	jsr $1fe6			jsr 	CacheWrite
.1fb1	a5 01		lda $01				lda 	codePtr+1
.1fb3	20 e6 1f	jsr $1fe6			jsr 	cacheWrite
.1fb6	68		pla				pla
.1fb7	a8		tay				tay
.1fb8	c8		iny				iny
.1fb9	20 96 14	jsr $1496			jsr 	CheckLeftParen 				; should be a (
.1fbc					_CPScanEnd:
.1fbc	b1 00		lda ($00),y			lda 	(codePtr),y 				; look for ) or EOL or :
.1fbe	c8		iny				iny
.1fbf	c9 c0		cmp #$c0			cmp 	#KWD_COLON
.1fc1	f0 b6		beq $1f79			beq		SPSyntax
.1fc3	c9 80		cmp #$80			cmp 	#$80
.1fc5	f0 b2		beq $1f79			beq 	SPSyntax
.1fc7	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN
.1fc9	d0 f1		bne $1fbc			bne 	_CPScanEnd
.1fcb					_CPScanFoundR:
.1fcb	98		tya				tya 								; put as element 4, offset to the code
.1fcc	20 e6 1f	jsr $1fe6			jsr 	CacheWrite
.1fcf	a2 00		ldx #$00			ldx 	#0 							; copy the buffer out.
.1fd1					_CPCopyBuffer:
.1fd1	ec 8c 08	cpx $088c			cpx 	Buffer
.1fd4	f0 0a		beq $1fe0			beq 	_CPDoneCopy
.1fd6	bd 8d 08	lda $088d,x			lda 	Buffer+1,x
.1fd9	20 e6 1f	jsr $1fe6			jsr 	CacheWrite
.1fdc	e8		inx				inx
.1fdd	4c d1 1f	jmp $1fd1			jmp 	_CPCopyBuffer
.1fe0					_CPDoneCopy:
.1fe0	a9 00		lda #$00			lda 	#0 							; write trailing zero to parameter address list.
.1fe2	20 e6 1f	jsr $1fe6			jsr 	CacheWrite
.1fe5	60		rts				rts
.1fe6					CacheWrite:
.1fe6	84 03		sty $03				sty 	tempShort
.1fe8	a0 00		ldy #$00			ldy 	#0
.1fea	91 10		sta ($10),y			sta 	(LowMemory),y
.1fec	e6 10		inc $10				inc 	LowMemory
.1fee	d0 02		bne $1ff2			bne 	_CWSkip
.1ff0	e6 11		inc $11				inc 	LowMemory+1
.1ff2					_CWSkip:
.1ff2	a4 03		ldy $03				ldy 	tempShort
.1ff4	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/utility/scanner.asm

.1ff5					ScanForward:
.1ff5	85 0a		sta $0a				sta 	temp3 						; save tokens to search in temp3/temp3+1
.1ff7	86 0b		stx $0b				stx 	temp3+1
.1ff9	a9 00		lda #$00			lda 	#0 							; temp2 counts structure levels.
.1ffb	85 08		sta $08				sta 	temp2
.1ffd	b1 00		lda ($00),y	_SFLoop:lda 	(codePtr),y 				; look at the high token.
.1fff	c9 80		cmp #$80			cmp 	#$80
.2001	f0 13		beq $2016			beq 	_SFNextLine 				; if $80 go to next line.
.2003	b0 17		bcs $201c			bcs  	_SFFoundCommand				; if -ve its a token
.2005	c9 60		cmp #$60			cmp 	#$60 						; if $60 it's a string.
.2007	f0 04		beq $200d			beq 	_SFSkipString
.2009					_SFNextToken:
.2009	c8		iny				iny
.200a	4c fd 1f	jmp $1ffd			jmp 	_SFLoop
.200d					_SFSkipString:
.200d	98		tya				tya
.200e	c8		iny				iny
.200f	18		clc				clc
.2010	71 00		adc ($00),y			adc 	(codePtr),y
.2012	a8		tay				tay
.2013	4c fd 1f	jmp $1ffd			jmp 	_SFLoop
.2016					_SFNextLine:
.2016	20 30 14	jsr $1430			jsr 	CommandNextLine
.2019	4c fd 1f	jmp $1ffd			jmp 	_SFLoop
.201c					_SFFoundCommand:
.201c	a5 08		lda $08				lda 	temp2 						; structure level is non-zero then don't check
.201e	d0 0a		bne $202a			bne 	_SFNoCheck
.2020	b1 00		lda ($00),y			lda 	(codePtr),y  				; get the token.
.2022	c5 0a		cmp $0a				cmp 	temp3 						; if it matches either, then we win.
.2024	f0 18		beq $203e			beq 	_SFFoundEnd
.2026	c5 0b		cmp $0b				cmp 	temp3+1
.2028	f0 14		beq $203e			beq 	_SFFoundEnd
.202a					_SFNoCheck:
.202a	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the token
.202c	aa		tax				tax 								; get its type
.202d	bd 48 1a	lda $1a48,x			lda 	KeywordTypes-$80,x
.2030	10 d7		bpl $2009			bpl		_SFNextToken 				; not a command
.2032	38		sec				sec
.2033	e9 81		sbc #$81			sbc 	#$81 						; this is now -1 if close, 0 normal, 1 open.
.2035	18		clc				clc
.2036	65 08		adc $08				adc 	temp2 						; add to structure level
.2038	85 08		sta $08				sta 	temp2
.203a	30 04		bmi $2040			bmi		_SFBalance
.203c	10 cb		bpl $2009			bpl 	_SFNextToken
.203e					_SFFoundEnd:
.203e	c8		iny				iny									; skip over the token
.203f	60		rts				rts
.2040					_SFBalance:
.2040	4c d0 19	jmp $19d0			jmp 	EHandlerClosure

;******  Return to file: basic.asm


;******  Processing file: common/utility/stack.asm

.2043					StackOpen:
.2043	85 03		sta $03				sta 	tempShort 					; save it
.2045	29 0f		and #$0f			and 	#StackSizeMask 				; bytes to subtract.
.2047	49 ff		eor #$ff			eor 	#$FF 						; add to stack pointer, 2's complement
.2049	38		sec				sec
.204a	65 0e		adc $0e				adc 	StackPtr
.204c	85 0e		sta $0e				sta 	StackPtr
.204e	a5 0f		lda $0f				lda 	StackPtr+1
.2050	69 ff		adc #$ff			adc 	#$FF
.2052	85 0f		sta $0f				sta 	StackPtr+1
.2054	98		tya				tya
.2055	48		pha				pha
.2056	a0 00		ldy #$00			ldy 	#0 							; write marker at offset 0
.2058	a5 03		lda $03				lda 	tempShort
.205a	91 0e		sta ($0e),y			sta 	(StackPtr),y
.205c	68		pla				pla
.205d	a8		tay				tay
.205e	a5 11		lda $11				lda 	LowMemory+1 				; check memory available
.2060	c5 0f		cmp $0f				cmp 	StackPtr+1
.2062	b0 01		bcs $2065			bcs		_SOMemory
.2064	60		rts				rts
.2065					_SOMemory:
.2065	4c 05 1a	jmp $1a05			jmp 	EHandlerMemory
.2068					StackCheck:
.2068	84 03		sty $03				sty 	tempShort
.206a	a0 00		ldy #$00			ldy 	#0 							; eor with marker
.206c	51 0e		eor ($0e),y			eor 	(StackPtr),y
.206e	a4 03		ldy $03				ldy 	tempShort
.2070	c9 00		cmp #$00			cmp 	#0 							; set Z flag
.2072	60		rts				rts
.2073					StackClose:
.2073	98		tya				tya
.2074	48		pha				pha
.2075	a0 00		ldy #$00			ldy 	#0
.2077	b1 0e		lda ($0e),y			lda 	(StackPtr),y 				; get type back
.2079	29 0f		and #$0f			and 	#StackSizeMask 				; bytes to add
.207b	18		clc				clc
.207c	65 0e		adc $0e				adc 	StackPtr
.207e	85 0e		sta $0e				sta 	StackPtr
.2080	90 02		bcc $2084			bcc 	_SCSkip
.2082	e6 0f		inc $0f				inc 	StackPtr+1
.2084					_SCSkip:
.2084	68		pla				pla
.2085	a8		tay				tay
.2086	60		rts				rts
.2087					StackLoadPosition:
.2087	a0 03		ldy #$03			ldy 	#3 							; read in codePtr from 3,2
.2089	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.208b	85 01		sta $01				sta 	codePtr+1
.208d	88		dey				dey
.208e	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.2090	85 00		sta $00				sta 	codePtr
.2092	88		dey				dey
.2093	b1 0e		lda ($0e),y			lda 	(stackPtr),y 				; restore offset in line
.2095	a8		tay				tay
.2096	60		rts				rts
.2097					StackSavePosition:
.2097	98		tya				tya 								; get position in A
.2098	a0 01		ldy #$01			ldy 	#1
.209a	91 0e		sta ($0e),y			sta 	(stackPtr),y 				; write it out.
.209c	48		pha				pha 								; save to stack
.209d	c8		iny				iny 								; write line position
.209e	a5 00		lda $00				lda 	codePtr
.20a0	91 0e		sta ($0e),y			sta 	(stackPtr),y
.20a2	c8		iny				iny
.20a3	a5 01		lda $01				lda 	codePtr+1
.20a5	91 0e		sta ($0e),y			sta 	(stackPtr),y
.20a7	68		pla				pla
.20a8	a8		tay				tay
.20a9	60		rts				rts
.20aa					StackPopLocals:
.20aa	a0 00		ldy #$00			ldy 	#0 							; check if TOS is a local record
.20ac	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20ae	c9 67		cmp #$67			cmp 	#SMLocal
.20b0	d0 1c		bne $20ce			bne 	_SPLExit
.20b2	a0 05		ldy #$05			ldy 	#5 							; copy local address to temp0
.20b4	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20b6	85 04		sta $04				sta 	temp0
.20b8	c8		iny				iny
.20b9	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20bb	85 05		sta $05				sta 	temp0+1
.20bd	a0 04		ldy #$04			ldy 	#4 							; start copying back
.20bf					_SPLLoop:
.20bf	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20c1	88		dey				dey
.20c2	91 04		sta ($04),y			sta 	(temp0),y
.20c4	c0 00		cpy #$00			cpy 	#0
.20c6	d0 f7		bne $20bf			bne 	_SPLLoop
.20c8	20 73 20	jsr $2073			jsr 	StackClose 					; drop frame and try again
.20cb	4c aa 20	jmp $20aa			jmp 	StackPopLocals
.20ce					_SPLExit:
.20ce	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: variables/common/varcreate.asm

.20cf					VariableCreate:
.20cf	a5 10		lda $10				lda 	LowMemory 					; copy LowMemory to temp0 adding 9 as you go
.20d1	85 04		sta $04				sta 	temp0 						; 9 is the size of a variable record.
.20d3	18		clc				clc
.20d4	69 09		adc #$09			adc 	#9
.20d6	85 10		sta $10				sta 	LowMemory
.20d8	a5 11		lda $11				lda 	LowMemory+1
.20da	85 05		sta $05				sta 	temp0+1
.20dc	69 00		adc #$00			adc 	#0
.20de	85 11		sta $11				sta 	LowMemory+1
.20e0	c5 0f		cmp $0f				cmp 	StackPtr+1 					; caught up with high memory ?
.20e2	b0 30		bcs $2114			bcs 	_CVMemoryError
.20e4	a0 00		ldy #$00			ldy 	#0 							; copy the current link from hash table into the 'next' links
.20e6	b1 06		lda ($06),y			lda 	(temp1),y 					; from the hash table, inserting it into the front.
.20e8	91 04		sta ($04),y			sta 	(temp0),y 					; (offset 0 & 1)
.20ea	c8		iny				iny
.20eb	b1 06		lda ($06),y			lda 	(temp1),y
.20ed	91 04		sta ($04),y			sta 	(temp0),y
.20ef	c8		iny				iny
.20f0	a5 08		lda $08				lda 	temp2 						; write full 8 bit hash into offset 2
.20f2	91 04		sta ($04),y			sta 	(temp0),y
.20f4	c8		iny				iny
.20f5	18		clc				clc 								; write variable name address into offset 3,4 (codePtr + y)
.20f6	a5 0a		lda $0a				lda 	temp3
.20f8	91 04		sta ($04),y			sta 	(temp0),y
.20fa	c8		iny				iny
.20fb	a5 0b		lda $0b				lda 	temp3+1
.20fd	91 04		sta ($04),y			sta 	(temp0),y
.20ff					_CVClear:
.20ff	c8		iny				iny
.2100	a9 00		lda #$00			lda 	#$00
.2102	91 04		sta ($04),y			sta 	(temp0),y
.2104	c0 08		cpy #$08			cpy 	#8
.2106	d0 f7		bne $20ff			bne 	_CVClear
.2108	a0 00		ldy #$00			ldy 	#0 							; put the address of the record as the new link head
.210a	a5 04		lda $04				lda 	temp0
.210c	91 06		sta ($06),y			sta 	(temp1),y
.210e	c8		iny				iny
.210f	a5 05		lda $05				lda 	temp0+1
.2111	91 06		sta ($06),y			sta 	(temp1),y
.2113	60		rts				rts
.2114					_CVMemoryError:
.2114	4c 05 1a	jmp $1a05			jmp 	EHandlerMemory

;******  Return to file: basic.asm


;******  Processing file: variables/common/variables.asm

.2117					VariableAccess:
.2117	b1 00		lda ($00),y			lda 	(codePtr),y 				; check 20xx where x is 1..1A representing A-Z.
.2119	c9 1a		cmp #$1a			cmp 	#$1A 						; is this A-Z ?
.211b	b0 0b		bcs $2128			bcs 	_VANotBasic
.211d	0a		asl a				asl 	a 							; x 4
.211e	0a		asl a				asl 	a
.211f	95 28		sta $28,x			sta 	esInt0,x 					; set up address
.2121	a9 08		lda #$08			lda 	#RootVariables >> 8
.2123	95 30		sta $30,x			sta 	esInt1,x
.2125	4c 66 21	jmp $2166			jmp 	VACheckModifier
.2128					_VANotBasic:
.2128	0a		asl a				asl 	a 							; calculate hash as 2 x first byte + second byte
.2129	c8		iny				iny
.212a	18		clc				clc
.212b	71 00		adc ($00),y			adc 	(codePtr),y
.212d	88		dey				dey
.212e	85 08		sta $08				sta 	temp2 						; 8 bit hash in temp2.
.2130	29 0f		and #$0f			and 	#HashTableSize-1 			; force into hash range
.2132	0a		asl a				asl 	a 							; double, word addresses in table and CLC
.2133	69 68		adc #$68			adc 	#HashTable & $FF 			; make temp1 point to the hash table first link.
.2135	85 06		sta $06				sta 	temp1
.2137	a9 08		lda #$08			lda 	#HashTable >> 8
.2139	85 07		sta $07				sta 	temp1+1
.213b	84 09		sty $09				sty 	temp2+1 					; Y is the offset of the first character.
.213d	98		tya				tya
.213e	18		clc				clc
.213f	65 00		adc $00				adc 	codePtr 					; temp3 is the address of that variable name.
.2141	85 0a		sta $0a				sta 	temp3
.2143	a5 01		lda $01				lda		codePtr+1
.2145	69 00		adc #$00			adc 	#0
.2147	85 0b		sta $0b				sta 	temp3+1
.2149	8a		txa				txa
.214a	48		pha				pha
.214b	98		tya				tya
.214c	48		pha				pha
.214d	20 7d 21	jsr $217d			jsr 	VariableSearch 				; does it exist already ?
.2150	b0 03		bcs $2155			bcs 	_VAExists
.2152	20 cf 20	jsr $20cf			jsr 	VariableCreate 				; no, create it.
.2155					_VAExists:
.2155	68		pla				pla
.2156	a8		tay				tay
.2157	68		pla				pla
.2158	aa		tax				tax
.2159	18		clc				clc
.215a	a5 04		lda $04				lda 	temp0 						; add 5 to temp0, which is the offset in the record
.215c	69 05		adc #$05			adc 	#5 							; of the actual variable data and copy into the stack
.215e	95 28		sta $28,x			sta 	esInt0,x
.2160	a5 05		lda $05				lda 	temp0+1
.2162	69 00		adc #$00			adc 	#0
.2164	95 30		sta $30,x			sta 	esInt1,x
.2166					VACheckModifier:
.2166	b1 00		lda ($00),y			lda 	(codePtr),y
.2168	c8		iny				iny
.2169	c9 30		cmp #$30			cmp 	#$30
.216b	b0 f9		bcs $2166			bcs 	VACheckModifier
.216d	ad a8 08	lda $08a8			lda 	arrayEnabled 				; arrays in operation
.2170	f0 00		beq $2172			beq 	_VAExit
.2172					_VAExit:
.2172	a9 00		lda #$00			lda 	#0 							; clear the upper two bytes of variable/element address.
.2174	95 38		sta $38,x			sta 	esInt2,x
.2176	95 40		sta $40,x			sta 	esInt3,x
.2178	a9 80		lda #$80			lda 	#$80 						; it's a reference to an integer.
.217a	95 20		sta $20,x			sta 	esType,x
.217c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: variables/common/varsearch.asm

.217d					VariableSearch:
.217d	a5 06		lda $06				lda 	temp1 						; put the first hash link address into temp0
.217f	85 04		sta $04				sta 	temp0
.2181	a5 07		lda $07				lda 	temp1+1
.2183	85 05		sta $05				sta 	temp0+1
.2185					_VSLoop:
.2185	a0 01		ldy #$01			ldy 	#1 							; look at MSB of link to follow
.2187	b1 04		lda ($04),y			lda 	(temp0),y
.2189	f0 29		beq $21b4			beq 	_VSFail						; if zero, end of linked list, so exit with CC
.218b	aa		tax				tax 								; follow the link.
.218c	88		dey				dey
.218d	b1 04		lda ($04),y			lda 	(temp0),y
.218f	85 04		sta $04				sta 	temp0
.2191	86 05		stx $05				stx 	temp0+1
.2193	a0 02		ldy #$02			ldy 	#2 							; check the hashes match
.2195	b1 04		lda ($04),y			lda 	(temp0),y
.2197	c5 08		cmp $08				cmp 	temp2 						; no, they don't, go around.
.2199	d0 ea		bne $2185			bne 	_VSLoop
.219b	c8		iny				iny 								; copy the varname address into temp4
.219c	b1 04		lda ($04),y			lda 	(temp0),y
.219e	85 0c		sta $0c				sta 	temp4
.21a0	c8		iny				iny
.21a1	b1 04		lda ($04),y			lda 	(temp0),y
.21a3	85 0d		sta $0d				sta 	temp4+1
.21a5	a0 00		ldy #$00			ldy 	#0 							; now compare them.
.21a7					_VSCompareName:
.21a7	b1 0c		lda ($0c),y			lda 	(temp4),y
.21a9	d1 0a		cmp ($0a),y			cmp 	(temp3),y
.21ab	d0 d8		bne $2185			bne 	_VSLoop 					; different, go around
.21ad	c8		iny				iny
.21ae	c9 30		cmp #$30			cmp 	#$30 						; reached end marker
.21b0	b0 f5		bcs $21a7			bcs 	_VSCompareName
.21b2	38		sec				sec 								; and we match.
.21b3	60		rts				rts
.21b4	18		clc		_VSFail:clc
.21b5	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: testing/code/99program.asm

>21b6						.align 256
.2200					BasicProgram:
>2200	0b					.byte $0b
>2201	e8					.byte $e8
>2202	03					.byte $03
>2203	c7					.byte $c7
>2204	3f					.byte $3f
>2205	41					.byte $41
>2206	32					.byte $32
>2207	1b					.byte $1b
>2208	95					.byte $95
>2209	ae					.byte $ae
>220a	80					.byte $80
>220b	0b					.byte $0b
>220c	f2					.byte $f2
>220d	03					.byte $03
>220e	c7					.byte $c7
>220f	3f					.byte $3f
>2210	41					.byte $41
>2211	32					.byte $32
>2212	1c					.byte $1c
>2213	95					.byte $95
>2214	ae					.byte $ae
>2215	80					.byte $80
>2216	05					.byte $05
>2217	fc					.byte $fc
>2218	03					.byte $03
>2219	cd					.byte $cd
>221a	80					.byte $80
>221b	0b					.byte $0b
>221c	06					.byte $06
>221d	04					.byte $04
>221e	b6					.byte $b6
>221f	3f					.byte $3f
>2220	41					.byte $41
>2221	32					.byte $32
>2222	1b					.byte $1b
>2223	95					.byte $95
>2224	ae					.byte $ae
>2225	80					.byte $80
>2226	0c					.byte $0c
>2227	10					.byte $10
>2228	04					.byte $04
>2229	c6					.byte $c6
>222a	60					.byte $60
>222b	07					.byte $07
>222c	50					.byte $50
>222d	52					.byte $52
>222e	43					.byte $43
>222f	31					.byte $31
>2230	00					.byte $00
>2231	80					.byte $80
>2232	05					.byte $05
>2233	1a					.byte $1a
>2234	04					.byte $04
>2235	bb					.byte $bb
>2236	80					.byte $80
>2237	04					.byte $04
>2238	24					.byte $24
>2239	04					.byte $04
>223a	80					.byte $80
>223b	0b					.byte $0b
>223c	2e					.byte $2e
>223d	04					.byte $04
>223e	b6					.byte $b6
>223f	3f					.byte $3f
>2240	41					.byte $41
>2241	32					.byte $32
>2242	1c					.byte $1c
>2243	95					.byte $95
>2244	ae					.byte $ae
>2245	80					.byte $80
>2246	0c					.byte $0c
>2247	38					.byte $38
>2248	04					.byte $04
>2249	c6					.byte $c6
>224a	60					.byte $60
>224b	07					.byte $07
>224c	50					.byte $50
>224d	52					.byte $52
>224e	43					.byte $43
>224f	32					.byte $32
>2250	00					.byte $00
>2251	80					.byte $80
>2252	05					.byte $05
>2253	42					.byte $42
>2254	04					.byte $04
>2255	bb					.byte $bb
>2256	80					.byte $80
>2257	00					.byte $00

;******  Return to file: basic.asm


;******  End of listing
