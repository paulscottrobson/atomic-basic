
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -q --m65xx -L asm.out\basic.lst -l asm.out\basic.lbl -o asm.out\basic.prg basic.asm
; Thu Dec 17 21:10:52 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: boot/x16/01constants.inc

=8							DataStackSize = 8
=16							HashTableSize = 16
=$00							ZeroPageStart = $00
=$20							DataStackStart = $20
=$800							DataStart = $800					; must be on a page boundary.
=$1000							CodeBase = $1000
=$9e00							EndMemory = $9E00

;******  Return to file: basic.asm


;******  Processing file: boot/common/02data.inc

>0000					codePtr:.fill 		3 						; code ptr - extra byte for paging.
>0003					tempShort:.fill 	1 						; used for v.short term saving.
>0004					temp0:	.fill 		2
>0006					temp1:	.fill 		2
>0008					temp2:	.fill 		2
>000a					temp3:	.fill 		2
>000c					temp4:	.fill 		2
>000e					StackPtr:.fill 		2						; highest byte allocated, stack works down.
>0010					LowMemory:.fill 	2 						; next byte available working up
>0020					esType:	.fill 		DataStackSize 			; bit 7 any reference, bit 6 byte reference, bit 0 string.
>0028					esInt0:	.fill 		DataStackSize		 	; 32 bit integer, also used for string address
>0030					esInt1:	.fill 		DataStackSize			; (16 bit only)
>0038					esInt2:	.fill 		DataStackSize
>0040					esInt3:	.fill 		DataStackSize
=$28					esStrLow = esInt0 							; String address synonym
=$30					esStrHigh = esInt1
>0800							.align 	256  						; these two must be on one page.
.0800					RootVariables:
>0800							.fill 	26*4
.0868					HashTable:
>0868							.fill 	HashTableSize*2
.0888					Seed32:
>0888							.fill 	4
.088c					Buffer:
>088c							.fill 	20
.08a0					ClockTicks:
>08a0							.fill 	4
.08a4					IToSCount:
>08a4							.fill 	1
.08a5					ChrBuffer:
>08a5							.fill 	2
.08a7					PrintCRFlag:
>08a7							.fill 	1
.08a8					ArrayEnabled:
>08a8							.fill 	1
.08a9					ProcTable:
>08a9							.fill 	2
.08ab					ParamCount:
>08ab							.fill 	1
.08ac					VariableAutoCreate:
>08ac							.fill 	1
.08ad					AsmToken:
>08ad							.fill 	2
.08af					AsmMode:
>08af							.fill 	1
.08b0					AsmOpcode:
>08b0							.fill 	1
.08b1					AsmType:
>08b1							.fill 	1
=$800					aVariable = ('A'-'A')*4+RootVariables
=$838					oVariable = ('O'-'A')*4+RootVariables
=$83c					pVariable = ('P'-'A')*4+RootVariables
=$85c					xVariable = ('X'-'A')*4+RootVariables
=$860					yVariable = ('Y'-'A')*4+RootVariables

;******  Return to file: basic.asm


;******  Processing file: boot/common/03stdmac.inc


;******  Return to file: basic.asm


;******  Processing file: boot/common/boot.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; initialise 6502 stac
.1002	9a		txs				txs
.1003	4c 06 10	jmp $1006			jmp 	ColdStart

;******  Return to file: basic.asm


;******  Processing file: interface/none/ifdummy.asm

.1006					ColdStart:
.1006	4c a1 13	jmp $13a1			jmp 	Command_RUN
.1009					WarmStart:
.1009	4c 09 10	jmp $1009			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: common/generated/keywords.inc

=$80					KWD_LESSLESSENDGREATERGREATER        = $80 ; 128
=$81					KWD_AND                              = $81 ; 129
=$82					KWD_OR                               = $82 ; 130
=$83					KWD_XOR                              = $83 ; 131
=$84					KWD_GREATER                          = $84 ; 132
=$85					KWD_LESS                             = $85 ; 133
=$86					KWD_GREATEREQUAL                     = $86 ; 134
=$87					KWD_LESSEQUAL                        = $87 ; 135
=$88					KWD_LESSGREATER                      = $88 ; 136
=$89					KWD_EQUAL                            = $89 ; 137
=$8a					KWD_PLUS                             = $8a ; 138
=$8b					KWD_MINUS                            = $8b ; 139
=$8c					KWD_ASTERISK                         = $8c ; 140
=$8d					KWD_SLASH                            = $8d ; 141
=$8e					KWD_PERCENT                          = $8e ; 142
=$8f					KWD_GREATERGREATER                   = $8f ; 143
=$90					KWD_LESSLESS                         = $90 ; 144
=$91					KWD_PLING                            = $91 ; 145
=$92					KWD_QUESTION                         = $92 ; 146
=$93					KWD_DOLLAR                           = $93 ; 147
=$94					KWD_TILDE                            = $94 ; 148
=$95					KWD_LPAREN                           = $95 ; 149
=$96					KWD_AMPERSAND                        = $96 ; 150
=$97					KWD_AT                               = $97 ; 151
=$98					KWD_LEN                              = $98 ; 152
=$99					KWD_SGN                              = $99 ; 153
=$9a					KWD_ABS                              = $9a ; 154
=$9b					KWD_RANDOM                           = $9b ; 155
=$9c					KWD_PAGE                             = $9c ; 156
=$9d					KWD_TRUE                             = $9d ; 157
=$9e					KWD_FALSE                            = $9e ; 158
=$9f					KWD_MIN                              = $9f ; 159
=$a0					KWD_MAX                              = $a0 ; 160
=$a1					KWD_SYS                              = $a1 ; 161
=$a2					KWD_CODE                             = $a2 ; 162
=$a3					KWD_TIMER                            = $a3 ; 163
=$a4					KWD_EVENT                            = $a4 ; 164
=$a5					KWD_GET                              = $a5 ; 165
=$a6					KWD_JOYPERIODX                       = $a6 ; 166
=$a7					KWD_JOYPERIODY                       = $a7 ; 167
=$a8					KWD_JOYPERIODBTN                     = $a8 ; 168
=$a9					KWD_INKEY                            = $a9 ; 169
=$aa					KWD_ALLOC                            = $aa ; 170
=$ab					KWD_CHR                              = $ab ; 171
=$ac					KWD_COMMA                            = $ac ; 172
=$ad					KWD_SEMICOLON                        = $ad ; 173
=$ae					KWD_RPAREN                           = $ae ; 174
=$af					KWD_HASH                             = $af ; 175
=$b0					KWD_PLUSPLUS                         = $b0 ; 176
=$b1					KWD_MINUSMINUS                       = $b1 ; 177
=$b2					KWD_RSQPAREN                         = $b2 ; 178
=$b3					KWD_MINUSGREATER                     = $b3 ; 179
=$b4					KWD_IF                               = $b4 ; 180
=$b5					KWD_FOR                              = $b5 ; 181
=$b6					KWD_REPEAT                           = $b6 ; 182
=$b7					KWD_PROC                             = $b7 ; 183
=$b8					KWD_WHILE                            = $b8 ; 184
=$b9					KWD_ENDIF                            = $b9 ; 185
=$ba					KWD_NEXT                             = $ba ; 186
=$bb					KWD_UNTIL                            = $bb ; 187
=$bc					KWD_ENDPROC                          = $bc ; 188
=$bd					KWD_WEND                             = $bd ; 189
=$be					KWD_REM                              = $be ; 190
=$bf					KWD_LET                              = $bf ; 191
=$c0					KWD_SQUOTE                           = $c0 ; 192
=$c1					KWD_COLON                            = $c1 ; 193
=$c2					KWD_LSQPAREN                         = $c2 ; 194
=$c3					KWD_THEN                             = $c3 ; 195
=$c4					KWD_ELSE                             = $c4 ; 196
=$c5					KWD_TO                               = $c5 ; 197
=$c6					KWD_STEP                             = $c6 ; 198
=$c7					KWD_VDU                              = $c7 ; 199
=$c8					KWD_PRINT                            = $c8 ; 200
=$c9					KWD_CALL                             = $c9 ; 201
=$ca					KWD_LOCAL                            = $ca ; 202
=$cb					KWD_GOTO                             = $cb ; 203
=$cc					KWD_GOSUB                            = $cc ; 204
=$cd					KWD_RETURN                           = $cd ; 205
=$ce					KWD_ASSERT                           = $ce ; 206
=$cf					KWD_STOP                             = $cf ; 207
=$d0					KWD_END                              = $d0 ; 208
=$d1					KWD_DIM                              = $d1 ; 209
=$d2					KWD_CLEAR                            = $d2 ; 210
=$d3					KWD_LOAD                             = $d3 ; 211
=$d4					KWD_SAVE                             = $d4 ; 212
=$d5					KWD_LIST                             = $d5 ; 213
=$d6					KWD_NEW                              = $d6 ; 214
=$d7					KWD_RUN                              = $d7 ; 215

;******  Return to file: basic.asm


;******  Processing file: common/math/intmacros.inc


;******  Return to file: basic.asm


;******  Processing file: common/utility/stack.inc

=$14					SMGosub = $14 								; gosub marker (4 bytes, marker + position)
=$24					SMRepeat = $24 								; repeat marker (4 bytes, marker + position)
=$34					SMWhile = $34 								; while marker (4 bytes, marker + position)
=$4b					SMFor = $4B 								; for marker (11 bytes, see for.asm)
=$54					SMProcedure = $54 							; procedure marker (4 bytes, marker + position)
=$67					SMLocal = $67 								; local marker (7 bytes, marker, address, data)
=$0f					StackSizeMask = $0F 						; converts marker to bytes required.

;******  Return to file: basic.asm


;******  Processing file: common/commands/assert.asm

.100c					Command_Assert:
.100c	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeRef			; evaluate the thing being asserted.
.100f	20 43 1e	jsr $1e43			jsr 	Int32Zero 					; check if zero
.1012	f0 01		beq $1015			beq 	_CAError
.1014	60		rts				rts
.1015					_CAError:
.1015	4c 1f 19	jmp $191f			jmp 	EHandlerAssert

;******  Return to file: basic.asm


;******  Processing file: common/commands/clear.asm

.1018					FindEnd:
.1018	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.101a	85 04		sta $04				sta 	temp0
.101c	a9 27		lda #$27			lda 	#(BasicProgram) >> 8
.101e	85 05		sta $05				sta 	1+(temp0)
.1020	98		tya				tya
.1021	48		pha				pha
.1022	a0 00		ldy #$00	_FELoop:ldy 	#0 							; look at offset
.1024	b1 04		lda ($04),y			lda 	(temp0),y
.1026	f0 0c		beq $1034			beq 	_FEExit 					; end if zero
.1028	18		clc				clc 								; add to position.
.1029	65 04		adc $04				adc 	temp0
.102b	85 04		sta $04				sta 	temp0
.102d	90 f3		bcc $1022			bcc 	_FELoop
.102f	e6 05		inc $05				inc 	temp0+1
.1031	4c 22 10	jmp $1022			jmp 	_FELoop
.1034					_FEExit:
.1034	68		pla				pla
.1035	a8		tay				tay
.1036	60		rts				rts
.1037					CommandClear:
.1037	8a		txa				txa
.1038	48		pha				pha
.1039	20 18 10	jsr $1018			jsr 	FindEnd 					; find end of memory
.103c	e6 04		inc $04				inc 	temp0 						; add 1, first free byte
.103e	d0 02		bne $1042			bne 	_CCSkip
.1040	e6 05		inc $05				inc 	temp0+1
.1042	a5 04		lda $04		_CCSkip:lda 	temp0 						; copy into low memory
.1044	85 10		sta $10				sta 	LowMemory
.1046	a5 05		lda $05				lda 	temp0+1
.1048	85 11		sta $11				sta 	LowMemory+1
.104a	a9 00		lda #$00			lda 	#(EndMemory) & $FF
.104c	85 0e		sta $0e				sta 	StackPtr
.104e	a9 9e		lda #$9e			lda 	#(EndMemory) >> 8
.1050	85 0f		sta $0f				sta 	1+(StackPtr)
.1052	a2 00		ldx #$00			ldx 	#0 							; blank hash table
.1054	8a		txa				txa
.1055					_CCErase:
.1055	9d 68 08	sta $0868,x			sta 	HashTable,x
.1058	e8		inx				inx
.1059	e0 20		cpx #$20			cpx 	#HashTableSize*2
.105b	d0 f8		bne $1055			bne 	_CCErase
.105d	a9 01		lda #$01			lda		#1 							; array works, variables autocreate.
.105f	8d a8 08	sta $08a8			sta 	ArrayEnabled
.1062	8d ac 08	sta $08ac			sta 	VariableAutoCreate
.1065	68		pla				pla
.1066	aa		tax				tax
.1067	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/dim.asm

.1068					Command_Dim:
.1068	a9 00		lda #$00			lda 	#0 							; stops the term decoding array dim a(5) would return ref
.106a	8d a8 08	sta $08a8			sta 	ArrayEnabled 				; to A(5) otherwise :)
.106d	a9 07		lda #$07			lda 	#7							; get a term
.106f	aa		tax				tax
.1070	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX
.1073	b5 20		lda $20,x			lda 	esType,x 					; get type
.1075	c9 80		cmp #$80			cmp 	#$80 						; it must be an integer reference.
.1077	d0 47		bne $10c0			bne 	_CDSyntax
.1079	8d a8 08	sta $08a8			sta 	ArrayEnabled 				; reenable normal array behaviour.
.107c	b5 28		lda $28,x			lda 	esInt0,x 					; get variable addr -> temp0
.107e	85 04		sta $04				sta 	temp0
.1080	b5 30		lda $30,x			lda 	esInt1,x
.1082	85 05		sta $05				sta 	temp0+1
.1084	98		tya				tya
.1085	48		pha				pha
.1086	a0 00		ldy #$00			ldy 	#0
.1088	a5 10		lda $10				lda 	LowMemory
.108a	91 04		sta ($04),y			sta 	(temp0),y
.108c	c8		iny				iny
.108d	a5 11		lda $11				lda 	LowMemory+1
.108f	91 04		sta ($04),y			sta 	(temp0),y
.1091	c8		iny				iny
.1092	a9 00		lda #$00			lda 	#0
.1094	91 04		sta ($04),y			sta 	(temp0),y
.1096	c8		iny				iny
.1097	91 04		sta ($04),y			sta 	(temp0),y
.1099	68		pla				pla
.109a	a8		tay				tay
.109b	20 2b 14	jsr $142b			jsr 	CheckLeftParen 				; get left bracket
.109e	20 31 16	jsr $1631			jsr 	EvaluateTOSDeref 			; get the size to dimension
.10a1	20 3d 14	jsr $143d			jsr 	CheckRightParen 			; do the right hand parenthesis
.10a4	b5 40		lda $40,x			lda 	esInt3,x 					; if -ve do not process.
.10a6	30 0c		bmi $10b4			bmi 	_CDNoSizeCalc
.10a8	f6 28		inc $28,x			inc 	esInt0,x 					; increment size by 1 (zero base so dim a(10) is 11 elements)
.10aa	d0 02		bne $10ae			bne 	_CDNoBump
.10ac	f6 30		inc $30,x			inc 	esInt1,x
.10ae					_CDNoBump:
.10ae	20 31 1e	jsr $1e31			jsr 	Int32ShiftLeft 				; x 4 (count => bytes)
.10b1	20 31 1e	jsr $1e31			jsr 	Int32ShiftLeft
.10b4					_CDNoSizeCalc:
.10b4	20 c3 10	jsr $10c3			jsr 	AllocMemStackCount 			; allocate that many bytes as per TOS.
.10b7	b1 00		lda ($00),y			lda 	(codePtr),y
.10b9	c8		iny				iny
.10ba	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; check if comma follows.
.10bc	f0 aa		beq $1068			beq 	Command_DIM 				; if so do more DIM.
.10be	88		dey				dey
.10bf					_CDExit:
.10bf	60		rts				rts
.10c0					_CDSyntax:
.10c0	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax
.10c3					AllocMemStackCount:
.10c3	b5 40		lda $40,x			lda 	esInt3,x 					; if -ve do not advance lowmem pointer
.10c5	30 19		bmi $10e0			bmi 	_AMSCExit
.10c7	d0 18		bne $10e1			bne 	AllocError 					; otherwise 2 MSB must be zero, 64k RAM space.
.10c9	b5 38		lda $38,x			lda 	esInt2,x
.10cb	d0 14		bne $10e1			bne 	AllocError
.10cd	18		clc				clc
.10ce	b5 28		lda $28,x			lda 	esInt0,x 					; add size to pos.
.10d0	65 10		adc $10				adc 	LowMemory
.10d2	85 10		sta $10				sta 	LowMemory
.10d4	b5 30		lda $30,x			lda 	esInt1,x
.10d6	65 11		adc $11				adc 	LowMemory+1
.10d8	85 11		sta $11				sta 	LowMemory+1
.10da	b0 05		bcs $10e1			bcs 	AllocError 					; overflow.
.10dc	c5 0f		cmp $0f				cmp 	StackPtr+1 					; got into SP page.
.10de	b0 01		bcs $10e1			bcs 	AllocError
.10e0					_AMSCExit:
.10e0	60		rts				rts
.10e1					AllocError:
.10e1	4c b1 19	jmp $19b1			jmp 	EHandlerMemory

;******  Return to file: basic.asm


;******  Processing file: common/commands/for.asm

.10e4					Command_FOR:
.10e4	a9 4b		lda #$4b			lda 	#SMFor 						; allocate the space.
.10e6	20 87 20	jsr $2087			jsr 	StackOpen
.10e9	20 6e 12	jsr $126e			jsr 	Command_LET 				; do the same as LET.
.10ec	20 37 14	jsr $1437			jsr 	CheckTO 					; check TO something.
.10ef	a2 01		ldx #$01			ldx 	#1 							; keep the variable address in stack 0
.10f1	20 31 16	jsr $1631			jsr 	EvaluateTOSDeRef			; get terminal value in stack 1
.10f4	98		tya				tya
.10f5	48		pha				pha
.10f6	a0 04		ldy #$04			ldy 	#4
.10f8	a5 28		lda $28				lda		esInt0 						; the address of the index into 4 and 5
.10fa	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10fc	c8		iny				iny
.10fd	a5 30		lda $30				lda		esInt1
.10ff	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1101	c8		iny				iny
.1102	a9 01		lda #$01			lda 	#1  						; the default step in 6
.1104	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1106	c8		iny				iny
.1107	a5 29		lda $29				lda		esInt0+1 					; terminal value in 7 to 11.
.1109	91 0e		sta ($0e),y			sta 	(StackPtr),y
.110b	c8		iny				iny
.110c	a5 31		lda $31				lda		esInt1+1
.110e	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1110	c8		iny				iny
.1111	a5 39		lda $39				lda		esInt2+1
.1113	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1115	c8		iny				iny
.1116	a5 41		lda $41				lda		esInt3+1
.1118	91 0e		sta ($0e),y			sta 	(StackPtr),y
.111a	68		pla				pla
.111b	a8		tay				tay
.111c	b1 00		lda ($00),y			lda 	(codePtr),y 				; followed by STEP.
.111e	c9 c6		cmp #$c6			cmp 	#KWD_STEP
.1120	d0 0e		bne $1130			bne 	_CFDone
.1122	c8		iny				iny									; skip over step.
.1123	20 31 16	jsr $1631			jsr 	EvaluateTOSDeref 			; get step
.1126	98		tya				tya
.1127	48		pha				pha
.1128	b5 28		lda $28,x			lda 	esInt0,x 					; copy it into step (bit lazy here)
.112a	a0 06		ldy #$06			ldy 	#6
.112c	91 0e		sta ($0e),y			sta 	(StackPtr),y
.112e	68		pla				pla
.112f	a8		tay				tay
.1130					_CFDone:
.1130	20 db 20	jsr $20db			jsr 	StackSavePosition 			; save position.
.1133	60		rts				rts
.1134					Command_NEXT:
.1134	a9 4b		lda #$4b			lda 	#SMFor 						; check NEXT
.1136	20 ac 20	jsr $20ac			jsr 	StackCheck
.1139	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it NEXT <index>
.113b	30 1e		bmi $115b			bmi 	_CNNoIndex
.113d	c9 60		cmp #$60			cmp 	#$60
.113f	b0 1a		bcs $115b			bcs 	_CNNoIndex
.1141	a2 00		ldx #$00			ldx 	#0 							; start on stack
.1143	a9 07		lda #$07			lda 	#7  						; get a term
.1145	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX 			; this is the variable/parameter to localise.
.1148	98		tya				tya
.1149	48		pha				pha
.114a	a0 04		ldy #$04			ldy 	#4 							; check same variable
.114c	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.114e	d5 28		cmp $28,x			cmp 	esInt0,x
.1150	d0 72		bne $11c4			bne 	_CNBadIndex
.1152	c8		iny				iny
.1153	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.1155	d5 30		cmp $30,x			cmp 	esInt1,x
.1157	d0 6b		bne $11c4			bne 	_CNBadIndex
.1159	68		pla				pla
.115a	a8		tay				tay
.115b					_CNNoIndex:
.115b	98		tya				tya
.115c	48		pha				pha
.115d	a0 04		ldy #$04			ldy 	#4 							; make temp0 point to the index
.115f	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.1161	85 04		sta $04				sta 	temp0
.1163	c8		iny				iny
.1164	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.1166	85 05		sta $05				sta 	temp0+1
.1168	c8		iny				iny
.1169	a2 00		ldx #$00			ldx 	#0 							; X is the sign of the step.
.116b	b1 0e		lda ($0e),y			lda 	(StackPtr),y 				; get the step.
.116d	85 09		sta $09				sta 	temp2+1 					; save for later.
.116f	10 01		bpl $1172			bpl 	_CNSignX
.1171	ca		dex				dex
.1172					_CNSignX:
.1172	18		clc				clc 								; add to the LSB
.1173	a0 00		ldy #$00			ldy 	#0
.1175	71 04		adc ($04),y			adc 	(temp0),y
.1177	91 04		sta ($04),y			sta 	(temp0),y
.1179					_CNPropogate:
.1179	c8		iny				iny  								; add the sign extended in X to the rest.
.117a	8a		txa				txa
.117b	71 04		adc ($04),y			adc 	(temp0),y
.117d	91 04		sta ($04),y			sta 	(temp0),y
.117f	c8		iny				iny
.1180	8a		txa				txa
.1181	71 04		adc ($04),y			adc 	(temp0),y
.1183	91 04		sta ($04),y			sta 	(temp0),y
.1185	c8		iny				iny
.1186	8a		txa				txa
.1187	71 04		adc ($04),y			adc 	(temp0),y
.1189	91 04		sta ($04),y			sta 	(temp0),y
.118b	18		clc				clc 								; point temp1 to the terminal value.
.118c	a5 0e		lda $0e				lda 	StackPtr
.118e	69 07		adc #$07			adc 	#7
.1190	85 06		sta $06				sta 	temp1
.1192	a9 00		lda #$00			lda 	#0
.1194	85 08		sta $08				sta 	temp2 						; clear temp2, which is the OR of all the subtractions.
.1196	a8		tay				tay 								; and clear the Y register again.
.1197	65 0f		adc $0f				adc 	StackPtr+1
.1199	85 07		sta $07				sta 	temp1+1
.119b	38		sec				sec 								; calculate current - limit oring interim values.
.119c	20 ce 11	jsr $11ce			jsr 	_CNCompare
.119f	20 ce 11	jsr $11ce			jsr 	_CNCompare
.11a2	20 ce 11	jsr $11ce			jsr 	_CNCompare
.11a5	20 ce 11	jsr $11ce			jsr 	_CNCompare
.11a8	50 02		bvc $11ac			bvc 	_CNNoOverflow 				; converts to a signed comparison on the sign bit.
.11aa	49 80		eor #$80			eor 	#$80
.11ac					_CNNoOverflow:
.11ac	a4 09		ldy $09				ldy 	temp2+1						; get step back
.11ae	30 17		bmi $11c7			bmi 	_CNCheckDownto
.11b0	c9 00		cmp #$00			cmp 	#0
.11b2	30 0a		bmi $11be			bmi 	_CNLoopRound 				; loop round if < =
.11b4	a5 08		lda $08				lda 	temp2
.11b6	f0 06		beq $11be			beq 	_CNLoopRound
.11b8					_CNLoopExit:
.11b8	68		pla				pla
.11b9	a8		tay				tay
.11ba	20 b7 20	jsr $20b7			jsr		StackClose 					; delete from stack and continue
.11bd	60		rts				rts
.11be					_CNLoopRound:
.11be	68		pla				pla
.11bf	a8		tay				tay
.11c0	20 cb 20	jsr $20cb			jsr 	StackLoadPosition			; go back to the loop top
.11c3	60		rts				rts
.11c4					_CNBadIndex:
.11c4	4c 43 19	jmp $1943			jmp 	EHandlerBadIndex
.11c7					_CNCheckDownto:
.11c7	c9 00		cmp #$00			cmp 	#0
.11c9	10 f3		bpl $11be			bpl 	_CNLoopRound
.11cb	4c b8 11	jmp $11b8			jmp 	_CNLoopExit
.11ce					_CNCompare:
.11ce	b1 04		lda ($04),y			lda 	(temp0),y 					; do the subtraction - compare don't care about answer
.11d0	f1 06		sbc ($06),y			sbc 	(temp1),y
.11d2	05 08		ora $08				ora 	temp2 						; Or into temp2 (does not affect carry)
.11d4	85 08		sta $08				sta 	temp2
.11d6	c8		iny				iny
.11d7	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/gosub.asm

.11d8					Command_Gosub:
.11d8	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeRef			; get the target line #
.11db	a9 14		lda #$14			lda 	#SMGosub 					; gosub marker allocate 4 bytes.
.11dd	20 87 20	jsr $2087			jsr 	StackOpen 					; create on stack.
.11e0	20 db 20	jsr $20db			jsr 	StackSavePosition 			; save position.
.11e3	4c fa 11	jmp $11fa			jmp 	GotoTOS 					; and use the GOTO code.
.11e6					Command_Return:
.11e6	a9 14		lda #$14			lda 	#SMGosub 					; check the stack matches
.11e8	20 ac 20	jsr $20ac			jsr 	StackCheck
.11eb	d0 07		bne $11f4			bne 	_RTError
.11ed	20 cb 20	jsr $20cb			jsr 	StackLoadPosition 			; load the position back
.11f0	20 b7 20	jsr $20b7			jsr 	StackClose 					; close the frame.
.11f3	60		rts				rts
.11f4					_RTError:
.11f4	4c d5 19	jmp $19d5			jmp 	EHandlerNoGosub

;******  Return to file: basic.asm


;******  Processing file: common/commands/goto.asm

.11f7					Command_Goto:
.11f7	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeRef			; get the target line #
.11fa					GotoTOS:
.11fa	20 0d 12	jsr $120d			jsr 	FindGoto
.11fd	90 0b		bcc $120a			bcc 	GotoError 					; not found
.11ff	a5 04		lda $04				lda		temp0 						; copy new line address
.1201	85 00		sta $00				sta 	codePtr
.1203	a5 05		lda $05				lda 	temp0+1
.1205	85 01		sta $01				sta 	codePtr+1
.1207	a0 03		ldy #$03			ldy 	#3 							; first token.
.1209	60		rts				rts
.120a					GotoError:
.120a	4c a1 19	jmp $19a1			jmp 	EHandlerLineNumber
.120d					FindGoto:
.120d	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.120f	85 04		sta $04				sta 	temp0
.1211	a9 27		lda #$27			lda 	#(BasicProgram) >> 8
.1213	85 05		sta $05				sta 	1+(temp0)
.1215					_FGLoop:
.1215	a0 00		ldy #$00			ldy 	#0 							; look at link
.1217	b1 04		lda ($04),y			lda 	(temp0),y
.1219	18		clc				clc
.121a	f0 0f		beq $122b			beq 	_FGExit
.121c	c8		iny				iny 								; compare line.low
.121d	b1 04		lda ($04),y			lda 	(temp0),y
.121f	d5 28		cmp $28,x			cmp 	esInt0,x
.1221	d0 09		bne $122c			bne 	_FGNext
.1223	c8		iny				iny 								; compare line.high
.1224	b1 04		lda ($04),y			lda 	(temp0),y
.1226	d5 30		cmp $30,x			cmp 	esInt1,x
.1228	d0 02		bne $122c			bne 	_FGNext
.122a	38		sec				sec
.122b					_FGExit:
.122b	60		rts				rts
.122c					_FGNext:
.122c	a0 00		ldy #$00			ldy 	#0
.122e	18		clc				clc
.122f	b1 04		lda ($04),y			lda 	(temp0),y
.1231	65 04		adc $04				adc 	temp0
.1233	85 04		sta $04				sta 	temp0
.1235	90 de		bcc $1215			bcc 	_FGLoop
.1237	e6 05		inc $05				inc 	temp0+1
.1239	4c 15 12	jmp $1215			jmp 	_FGLoop

;******  Return to file: basic.asm


;******  Processing file: common/commands/if.asm

.123c					Command_IF:
.123c	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeRef			; get the target address
.123f	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by THEN ?
.1241	c9 c3		cmp #$c3			cmp 	#KWD_THEN
.1243	d0 15		bne $125a			bne 	StructureIF
.1245	c8		iny				iny 								; skip THEN
.1246	20 43 1e	jsr $1e43			jsr 	Int32Zero 					; is it true ?
.1249	f0 0c		beq $1257			beq 	_IfFalse
.124b	b1 00		lda ($00),y			lda 	(codePtr),y 				; if THEN <const> do GOTO.
.124d	30 04		bmi $1253			bmi 	_CIFExit
.124f	c9 70		cmp #$70			cmp 	#$70
.1251	b0 01		bcs $1254			bcs 	_CIFGoto
.1253					_CIFExit:
.1253	60		rts				rts 								; otherwise carry on.
.1254					_CIFGoto:
.1254	4c f7 11	jmp $11f7			jmp 	Command_GOTO
.1257					_IfFalse:
.1257	4c c2 13	jmp $13c2			jmp 	CommandNextLine
.125a					StructureIF:
.125a	20 43 1e	jsr $1e43			jsr 	Int32Zero 					; is it true ?
.125d	f0 01		beq $1260			beq 	_SIFSkip 					; if non-zero then skip to ELSE/ENDIF
.125f	60		rts				rts 								; else continue.
.1260					_SIFSkip:
.1260	a9 c4		lda #$c4			lda	 	#KWD_ELSE 					; test failed, go to ELSE or ENDIF whichever comes first.
.1262	a2 b9		ldx #$b9			ldx 	#KWD_ENDIF
.1264	4c 39 20	jmp $2039			jmp		ScanForward
.1267					Command_ELSE:
.1267	a2 b9		ldx #$b9			ldx 	#KWD_ENDIF
.1269	8a		txa				txa
.126a	4c 39 20	jmp $2039			jmp		ScanForward
.126d					Command_ENDIF:
.126d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/let.asm

.126e					Command_LET:
.126e	a2 00		ldx #$00			ldx 	#0 							; start on stack
.1270	a9 04		lda #$04			lda 	#4  						; this means ! ? and $ binary operators only work.
.1272	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX 			; this is the LHS
.1275	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.1277	10 2f		bpl $12a8			bpl 	_CLSyntax 					; if not, syntax error.
.1279	20 31 14	jsr $1431			jsr 	CheckEquals 				; check equals follows.
.127c	e8		inx				inx 								; get the right hand side.
.127d	20 31 16	jsr $1631			jsr 	EvaluateTOSDeRef
.1280	ca		dex				dex
.1281	b5 28		lda $28,x			lda 	esInt0,x 					; copy target address to temp0
.1283	85 04		sta $04				sta 	temp0
.1285	b5 30		lda $30,x			lda 	esInt1,x
.1287	85 05		sta $05				sta 	temp0+1
.1289	b5 20		lda $20,x			lda 	esType,x 					; what sort of reference ?
.128b	0a		asl a				asl 	a 							; will now be $00 integer $80 byte $02 string.
.128c	f0 22		beq $12b0			beq 	_CLIntCopy
.128e	30 1b		bmi $12ab			bmi 	_CLByteCopy
.1290	b5 29		lda $29,x			lda 	esInt0+1,x 					; source -> temp1
.1292	85 06		sta $06				sta 	temp1
.1294	b5 31		lda $31,x			lda 	esInt1+1,x
.1296	85 07		sta $07				sta 	temp1+1
.1298	98		tya				tya
.1299	48		pha				pha
.129a	a0 00		ldy #$00			ldy 	#0
.129c					_CLStringCopy:
.129c	b1 06		lda ($06),y			lda 	(temp1),y
.129e	91 04		sta ($04),y			sta 	(temp0),y
.12a0	f0 03		beq $12a5			beq 	_CLCopyExit 				; copied trailing NULL
.12a2	c8		iny				iny
.12a3	d0 f7		bne $129c			bne 	_CLStringCopy 				; it could run riot.
.12a5					_CLCopyExit:
.12a5	68		pla				pla
.12a6	a8		tay				tay
.12a7	60		rts				rts
.12a8					_CLSyntax:
.12a8	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax
.12ab					_CLByteCopy:
.12ab	b5 29		lda $29,x			lda 	esInt0+1,x 					; get the byte to write.
.12ad	81 04		sta ($04,x)			sta 	(temp0,x)					; write, taking advantage of X = 0
.12af	60		rts				rts
.12b0					_CLIntCopy:
.12b0	e8		inx				inx
.12b1	20 b5 12	jsr $12b5			jsr 	CopyTOSToTemp0
.12b4	60		rts				rts
.12b5					CopyTOSToTemp0:
.12b5	98		tya				tya
.12b6	48		pha				pha
.12b7	a0 00		ldy #$00			ldy 	#0
.12b9	b5 28		lda $28,x			lda 	esInt0,x
.12bb	91 04		sta ($04),y			sta 	(temp0),y
.12bd	c8		iny				iny
.12be	b5 30		lda $30,x			lda 	esInt1,x
.12c0	91 04		sta ($04),y			sta 	(temp0),y
.12c2	c8		iny				iny
.12c3	b5 38		lda $38,x			lda 	esInt2,x
.12c5	91 04		sta ($04),y			sta 	(temp0),y
.12c7	c8		iny				iny
.12c8	b5 40		lda $40,x			lda 	esInt3,x
.12ca	91 04		sta ($04),y			sta 	(temp0),y
.12cc	68		pla				pla
.12cd	a8		tay				tay
.12ce	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/new.asm

.12cf					Command_New:
.12cf	a9 00		lda #$00			lda 	#0 							; clear program
.12d1	8d 00 27	sta $2700			sta 	BasicProgram
.12d4	4c 37 10	jmp $1037			jmp 	CommandClear				; clear variables etc.

;******  Return to file: basic.asm


;******  Processing file: common/commands/print.asm

.12d7					Command_Print:
.12d7					_CPRLoop:
.12d7	a9 00		lda #$00			lda 	#0 							; zero the print CRFlag
.12d9					_CPRSetFlag:
.12d9	8d a7 08	sta $08a7			sta 	PrintCRFlag
.12dc	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token.
.12de	c9 80		cmp #$80			cmp 	#$80						; if EOL exit.
.12e0	f0 5d		beq $133f			beq 	_CPRExit
.12e2	c9 c1		cmp #$c1			cmp 	#KWD_COLON 					; if colon exit
.12e4	f0 59		beq $133f			beq 	_CPRExit
.12e6	c9 60		cmp #$60			cmp 	#$60 						; if $60  it is a string.
.12e8	f0 38		beq $1322			beq 	_CPRString
.12ea	c9 00		cmp #$00			cmp 	#$00 						; if -ve go to token
.12ec	30 04		bmi $12f2			bmi 	_CPRToken
.12ee	c9 70		cmp #$70			cmp 	#$70 						; is it a number, if so print as decimal.
.12f0	b0 14		bcs $1306			bcs 	_CPRDecimal
.12f2					_CPRToken:
.12f2	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the token ID and skip it.
.12f4	c8		iny				iny
.12f5	c9 ad		cmp #$ad			cmp 	#KWD_SEMICOLON 				; semicolon goes to set flag which is now non zero
.12f7	f0 e0		beq $12d9			beq 	_CPRSetFlag
.12f9	c9 c0		cmp #$c0			cmp 	#KWD_SQUOTE 				; single quote is CR.
.12fb	f0 34		beq $1331			beq 	_CPRNewLine
.12fd	c9 96		cmp #$96			cmp 	#KWD_AMPERSAND 				; &x means print in hex
.12ff	f0 09		beq $130a			beq 	_CPRHexaDecimal
.1301	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; comma is tab (possibly space)
.1303	f0 32		beq $1337			beq 	_CPRTab
.1305	88		dey				dey 								; undo the skip.
.1306					_CPRDecimal:
.1306	a9 8a		lda #$8a			lda 	#10+128
.1308	d0 3e		bne $1348			bne 	_CPRPrintInteger
.130a					_CPRHexaDecimal:
.130a	a9 10		lda #$10			lda 	#16
.130c	d0 3a		bne $1348			bne 	_CPRPrintInteger
.130e					_CPRStringExpr:
.130e	68		pla				pla 								; chuck the base.
.130f	8a		txa				txa
.1310	48		pha				pha
.1311	98		tya				tya
.1312	48		pha				pha
.1313	b4 28		ldy $28,x			ldy 	esInt0,x
.1315	b5 30		lda $30,x			lda 	esInt1,x
.1317	aa		tax				tax
.1318	20 a0 14	jsr $14a0			jsr 	PrintXYString
.131b	68		pla				pla
.131c	a8		tay				tay
.131d	68		pla				pla
.131e	aa		tax				tax
.131f	4c d7 12	jmp $12d7			jmp 	_CPRLoop
.1322					_CPRString:
.1322	c8		iny				iny 								; move to start of string.
.1323	c8		iny				iny
.1324					_CPRStringLoop:
.1324	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character and bump
.1326	c8		iny				iny
.1327	c9 00		cmp #$00			cmp 	#0 							; end of string, loop back.
.1329	f0 ac		beq $12d7			beq 	_CPRLoop
.132b	20 11 26	jsr $2611			jsr 	XTPrintA 					; print it and try next character.
.132e	4c 24 13	jmp $1324			jmp 	_CPRStringLoop
.1331					_CPRNewLine:
.1331	20 01 26	jsr $2601			jsr 	XTPrintCR
.1334	4c d7 12	jmp $12d7			jmp 	_CPRLoop
.1337					_CPRTab:
.1337	20 09 26	jsr $2609			jsr 	XTPrintTab
.133a	a9 01		lda #$01			lda 	#1
.133c	4c d9 12	jmp $12d9			jmp 	_CPRSetFlag
.133f					_CPRExit:
.133f	ad a7 08	lda $08a7			lda 	PrintCRFlag 				; check flag.
.1342	d0 03		bne $1347			bne 	_CPRNoNL
.1344	20 01 26	jsr $2601			jsr 	XTPrintCR
.1347					_CPRNoNL:
.1347	60		rts				rts
.1348					_CPRPrintInteger:
.1348	48		pha				pha 								; save base on stack
.1349	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeref 			; evaluate whatever it is.
.134c	b5 20		lda $20,x			lda 	esType,x 					; is it a string expression ?
.134e	4a		lsr a				lsr 	a
.134f	b0 bd		bcs $130e			bcs 	_CPRStringExpr
.1351	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.1353	85 04		sta $04				sta 	temp0
.1355	a9 08		lda #$08			lda 	#(buffer) >> 8
.1357	85 05		sta $05				sta 	1+(temp0)
.1359	68		pla				pla
.135a	20 78 1d	jsr $1d78			jsr 	Int32ToString 				; convert in the buffer.
.135d	8a		txa				txa
.135e	48		pha				pha
.135f	a2 00		ldx #$00			ldx 	#0
.1361					_CPROutBuffer:
.1361	bd 8c 08	lda $088c,x			lda 	buffer,x
.1364	f0 06		beq $136c			beq 	_CPROBExit
.1366	20 11 26	jsr $2611			jsr 	XTPrintA
.1369	e8		inx				inx
.136a	d0 f5		bne $1361			bne 	_CPROutBuffer
.136c					_CPROBExit:
.136c	68		pla				pla
.136d	aa		tax				tax
.136e	4c d7 12	jmp $12d7			jmp 	_CPRLoop

;******  Return to file: basic.asm


;******  Processing file: common/commands/rem.asm

.1371					Command_Rem:
.1371					Command_Rem2:
.1371	b1 00		lda ($00),y			lda 	(codePtr),y 				; should be followed by string
.1373	c9 60		cmp #$60			cmp 	#$60
.1375	d0 06		bne $137d			bne 	_CRMExit
.1377	98		tya				tya
.1378	c8		iny				iny
.1379	18		clc				clc
.137a	71 00		adc ($00),y			adc 	(codePtr),y
.137c	a8		tay				tay
.137d					_CRMExit:
.137d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/repeat.asm

.137e					Command_Repeat:
.137e	a9 24		lda #$24			lda 	#SMRepeat 					; repeat marker allocate 4 bytes.
.1380	20 87 20	jsr $2087			jsr 	StackOpen 					; create on stack.
.1383	20 db 20	jsr $20db			jsr 	StackSavePosition 			; save position.
.1386	60		rts				rts
.1387					Command_Until:
.1387	a9 24		lda #$24			lda 	#SMRepeat 					; check the stack matches
.1389	20 ac 20	jsr $20ac			jsr 	StackCheck
.138c	d0 10		bne $139e			bne 	_CUError
.138e	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeRef			; get the conditional
.1391	20 43 1e	jsr $1e43			jsr 	Int32Zero
.1394	f0 04		beq $139a			beq 	_CULoopBack
.1396	20 b7 20	jsr $20b7			jsr 	StackClose 					; close the frame.
.1399	60		rts				rts
.139a					_CULoopBack:
.139a	20 cb 20	jsr $20cb			jsr 	StackLoadPosition			; go back until true
.139d	60		rts				rts
.139e					_CUError:
.139e	4c 05 1a	jmp $1a05			jmp 	EHandlerNoRepeat

;******  Return to file: basic.asm


;******  Processing file: common/commands/run.asm

.13a1					Command_Run:
.13a1	20 37 10	jsr $1037			jsr 	CommandClear 				; clear variables, memory pointers, hash table.
.13a4	20 bd 1f	jsr $1fbd			jsr 	BuildProcedureList 			; build procedure cache.
.13a7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.13a9	85 00		sta $00				sta 	codePtr
.13ab	a9 27		lda #$27			lda 	#(BasicProgram) >> 8
.13ad	85 01		sta $01				sta 	1+(codePtr)
.13af	a0 00		ldy #$00			ldy 	#0 							; check if off end of program.
.13b1	b1 00		lda ($00),y			lda 	(codePtr),y
.13b3	f0 28		beq $13dd			beq 	Command_End
.13b5	a0 03		ldy #$03			ldy 	#3 							; start at this offset.
.13b7					CommandNextCommand:
.13b7	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first token ... see if it is a token.
.13b9	10 1b		bpl $13d6			bpl 	CommandTryLet				; if not, try LET as a default.
.13bb	c8		iny				iny 								; advance past it.
.13bc	20 68 17	jsr $1768			jsr 	ExecuteCommand 				; execute the command
.13bf	4c b7 13	jmp $13b7			jmp 	CommandNextCommand
.13c2					CommandNextLine:
.13c2	a0 00		ldy #$00			ldy 	#0 							; get offset and add
.13c4	b1 00		lda ($00),y			lda 	(codePtr),y
.13c6	18		clc				clc
.13c7	65 00		adc $00				adc 	codePtr
.13c9	85 00		sta $00				sta 	codePtr
.13cb	90 02		bcc $13cf			bcc 	_CSLExit
.13cd	e6 01		inc $01				inc 	codePtr+1
.13cf					_CSLExit:
.13cf	b1 00		lda ($00),y			lda 	(codePtr),y 				; reached end of code ?
.13d1	f0 0a		beq $13dd			beq 	Command_End
.13d3	a0 03		ldy #$03			ldy 	#3 							; 3rd position next line.
.13d5	60		rts				rts
.13d6					CommandTryLet:
.13d6	20 6e 12	jsr $126e			jsr 	Command_LET
.13d9	4c b7 13	jmp $13b7			jmp 	CommandNextCommand
.13dc					Command_Colon:
.13dc	60		rts				rts
.13dd					Command_End:
.13dd	4c 09 10	jmp $1009			jmp 	WarmStart
.13e0					Command_Stop:
.13e0	4c 67 1a	jmp $1a67			jmp 	EHandlerStop
.13e3					Command_StartAsm:
.13e3	4c e6 22	jmp $22e6			jmp 	Assembler

;******  Return to file: basic.asm


;******  Processing file: common/commands/vdu.asm

.13e6					Command_Vdu:
.13e6	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeRef			; evaluate the thing being asserted.
.13e9	b5 28		lda $28,x			lda 	esInt0,x 					; get the byte
.13eb	20 11 26	jsr $2611			jsr 	XTPrintA 					; and print it
.13ee	b1 00		lda ($00),y			lda 	(codePtr),y 				; if comma follows
.13f0	c8		iny				iny
.13f1	c9 ac		cmp #$ac			cmp 	#KWD_COMMA
.13f3	f0 f1		beq $13e6			beq 	Command_Vdu 				; loop back roun.
.13f5	88		dey				dey
.13f6	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/while.asm

.13f7					Command_While:
.13f7	a9 34		lda #$34			lda 	#SMWhile 					; gosub marker allocate 4 bytes.
.13f9	20 87 20	jsr $2087			jsr 	StackOpen 					; create on stack.
.13fc	88		dey				dey
.13fd	20 db 20	jsr $20db			jsr 	StackSavePosition 			; save position before the WHILE.
.1400	c8		iny				iny
.1401	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeRef			; get the conditional
.1404	20 43 1e	jsr $1e43			jsr 	Int32Zero
.1407	f0 01		beq $140a			beq 	_CWFail
.1409	60		rts				rts
.140a					_CWFail:
.140a	20 b7 20	jsr $20b7			jsr 	StackClose 					; close the just opened position.
.140d	a9 bd		lda #$bd			lda 	#KWD_WEND 					; scan forward past WEND.
.140f	aa		tax				tax
.1410	20 39 20	jsr $2039			jsr 	ScanForward
.1413	60		rts				rts
.1414					Command_Wend:
.1414	a9 34		lda #$34			lda 	#SMWhile 					; check the stack matches
.1416	20 ac 20	jsr $20ac			jsr 	StackCheck
.1419	d0 07		bne $1422			bne 	_CWError
.141b	20 cb 20	jsr $20cb			jsr 	StackLoadPosition			; go back until true
.141e	20 b7 20	jsr $20b7			jsr 	StackClose 					; close the frame.
.1421	60		rts				rts
.1422					_CWError:
.1422	4c 1d 1a	jmp $1a1d			jmp 	EHandlerNoWhile

;******  Return to file: basic.asm


;******  Processing file: common/errors/checksyntax.asm

.1425					CheckComma:
.1425	48		pha				pha
.1426	a9 ac		lda #$ac			lda 	#KWD_COMMA
.1428	4c 43 14	jmp $1443			jmp 	CheckSyntax
.142b					CheckLeftParen:
.142b	48		pha				pha
.142c	a9 95		lda #$95			lda 	#KWD_LPAREN
.142e	4c 43 14	jmp $1443			jmp 	CheckSyntax
.1431					CheckEquals:
.1431	48		pha				pha
.1432	a9 89		lda #$89			lda 	#KWD_EQUAL
.1434	4c 43 14	jmp $1443			jmp 	CheckSyntax
.1437					CheckTO:
.1437	48		pha				pha
.1438	a9 c5		lda #$c5			lda 	#KWD_TO
.143a	4c 43 14	jmp $1443			jmp 	CheckSyntax
.143d					CheckRightParen:
.143d	48		pha				pha
.143e	a9 ae		lda #$ae			lda 	#KWD_RPAREN
.1440	4c 43 14	jmp $1443			jmp 	CheckSyntax
.1443					CheckSyntax:
.1443	d1 00		cmp ($00),y			cmp 	(codePtr),y
.1445	d0 03		bne $144a			bne 	_CSFail
.1447	c8		iny				iny
.1448	68		pla				pla
.1449	60		rts				rts
.144a					_CSFail:
.144a	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax
.144d					NoOp1:
.144d					NoOp2:
.144d					NoOp3:
.144d					NoOp6:
.144d					NoOp7:
.144d					NoOp8:
.144d					NoOp9:
.144d	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/errors/errorhandler.asm

.1450					ErrorHandler:
.1450	84 0a		sty $0a				sty 	temp3
.1452	68		pla				pla 								; line addr into XY.
.1453	a8		tay				tay
.1454	68		pla				pla
.1455	aa		tax				tax
.1456	c8		iny				iny
.1457	d0 01		bne $145a			bne 	_EHNoBump
.1459	e8		inx				inx
.145a					_EHNoBump:
.145a	20 a0 14	jsr $14a0			jsr 	PrintXYString 				; print it
.145d	a0 00		ldy #$00			ldy 	#0 							; if offset = 0 (e.g. not in program)
.145f	b1 00		lda ($00),y			lda 	(codePtr),y
.1461	f0 30		beq $1493			beq 	_GoWarm 					; no line #
.1463	20 9b 14	jsr $149b			jsr 	PrintSpace
.1466	a9 40		lda #$40			lda 	#'@'
.1468	20 f1 25	jsr $25f1			jsr 	XTPrintAC
.146b	20 9b 14	jsr $149b			jsr 	PrintSpace
.146e	a2 00		ldx #$00			ldx 	#0 							; set up for ITOA conversion
.1470	c8		iny				iny
.1471	b1 00		lda ($00),y			lda 	(codePtr),y
.1473	95 28		sta $28,x			sta 	esInt0,x
.1475	c8		iny				iny
.1476	b1 00		lda ($00),y			lda 	(codePtr),y
.1478	95 30		sta $30,x			sta 	esInt1,x
.147a	8a		txa				txa
.147b	95 38		sta $38,x			sta 	esInt2,x
.147d	95 40		sta $40,x			sta 	esInt3,x
.147f	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.1481	85 04		sta $04				sta 	temp0
.1483	a9 08		lda #$08			lda 	#(buffer) >> 8
.1485	85 05		sta $05				sta 	1+(temp0)
.1487	a9 0a		lda #$0a			lda 	#10 						; convert base 10.
.1489	20 78 1d	jsr $1d78			jsr 	Int32ToString
.148c	a2 08		ldx #$08			ldx 	#buffer >> 8
.148e	a0 8c		ldy #$8c			ldy 	#buffer & $FF
.1490	20 a0 14	jsr $14a0			jsr 	PrintXYString
.1493					_GoWarm:
.1493	a5 0a		lda $0a				lda 	temp3
.1495	4c 09 10	jmp $1009			jmp 	WarmStart
.1498					InstructionUndefined:
.1498	4c 33 1a	jmp $1a33			jmp 	EHandlerNotImplemented
.149b					PrintSpace:
.149b	a9 20		lda #$20			lda 	#32
.149d	4c f1 25	jmp $25f1			jmp 	XTPrintAC
.14a0					PrintXYString:
.14a0	48		pha				pha
.14a1	84 04		sty $04				sty 	temp0
.14a3	86 05		stx $05				stx 	temp0+1
.14a5	a0 00		ldy #$00			ldy 	#0
.14a7					_PXYSLoop:
.14a7	b1 04		lda ($04),y			lda 	(temp0),y
.14a9	20 f1 25	jsr $25f1			jsr 	XTPrintAC
.14ac	c8		iny				iny
.14ad	b1 04		lda ($04),y			lda 	(temp0),y
.14af	d0 f6		bne $14a7			bne 	_PXYSLoop
.14b1	a4 04		ldy $04				ldy 	temp0
.14b3	a6 05		ldx $05				ldx 	temp0+1
.14b5	68		pla				pla
.14b6	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary1.asm

.14b7					BinaryAdd:
.14b7	20 f3 16	jsr $16f3			jsr		DeRefBoth
.14ba	20 0d 1d	jsr $1d0d			jsr 	Int32Add
.14bd	a9 00		lda #$00			lda 	#0
.14bf	95 20		sta $20,x			sta 	esType,x
.14c1	60		rts				rts
.14c2					BinarySub:
.14c2	20 f3 16	jsr $16f3			jsr		DeRefBoth
.14c5	20 27 1d	jsr $1d27			jsr 	Int32Sub
.14c8	a9 00		lda #$00			lda 	#0
.14ca	95 20		sta $20,x			sta 	esType,x
.14cc	60		rts				rts
.14cd					BinaryMult:
.14cd	20 f3 16	jsr $16f3			jsr		DeRefBoth
.14d0	20 41 1d	jsr $1d41			jsr 	Int32Multiply
.14d3	a9 00		lda #$00			lda 	#0
.14d5	95 20		sta $20,x			sta 	esType,x
.14d7	60		rts				rts
.14d8					BinaryDivide:
.14d8	20 f3 16	jsr $16f3			jsr		DeRefBoth
.14db	20 f4 14	jsr $14f4			jsr		CheckDivisorNonZero
.14de	20 2a 1c	jsr $1c2a			jsr 	Int32SDivide
.14e1	a9 00		lda #$00			lda 	#0
.14e3	95 20		sta $20,x			sta 	esType,x
.14e5	60		rts				rts
.14e6					BinaryModulus:
.14e6	20 f3 16	jsr $16f3			jsr		DeRefBoth
.14e9	20 f4 14	jsr $14f4			jsr 	CheckDivisorNonZero
.14ec	20 99 1c	jsr $1c99			jsr		Int32Modulus
.14ef	a9 00		lda #$00			lda 	#0
.14f1	95 20		sta $20,x			sta 	esType,x
.14f3	60		rts				rts
.14f4					CheckDivisorNonZero:
.14f4	e8		inx				inx
.14f5	20 43 1e	jsr $1e43			jsr 	Int32Zero
.14f8	f0 02		beq $14fc			beq 	_BDivZero
.14fa	ca		dex				dex
.14fb	60		rts				rts
.14fc					_BDivZero:
.14fc	4c 8f 19	jmp $198f			jmp 	EHandlerDivideZero
.14ff					BinaryXor:
.14ff	20 f3 16	jsr $16f3			jsr		DeRefBoth
.1502	20 de 1b	jsr $1bde			jsr 	Int32Xor
.1505	a9 00		lda #$00			lda 	#0
.1507	95 20		sta $20,x			sta 	esType,x
.1509	60		rts				rts
.150a					BinaryOr:
.150a	20 f3 16	jsr $16f3			jsr		DeRefBoth
.150d	20 c5 1b	jsr $1bc5			jsr 	Int32Or
.1510	a9 00		lda #$00			lda 	#0
.1512	95 20		sta $20,x			sta 	esType,x
.1514	60		rts				rts
.1515					BinaryAnd:
.1515	20 f3 16	jsr $16f3			jsr		DeRefBoth
.1518	20 ac 1b	jsr $1bac			jsr 	Int32And
.151b	a9 00		lda #$00			lda 	#0
.151d	95 20		sta $20,x			sta 	esType,x
.151f	60		rts				rts
.1520					BinaryShiftLeft:
.1520	20 f3 16	jsr $16f3			jsr		DeRefBoth
.1523	20 4d 15	jsr $154d			jsr 	CheckShiftParam2
.1526	d0 21		bne $1549			bne 	BinaryShiftZero
.1528					BSLLoop:
.1528	d6 29		dec $29,x			dec 	esInt0+1,x
.152a	30 18		bmi $1544			bmi 	BinaryShiftExit
.152c	20 31 1e	jsr $1e31			jsr 	Int32ShiftLeft
.152f	4c 28 15	jmp $1528			jmp 	BSLLoop
.1532					BinaryShiftRight:
.1532	20 f3 16	jsr $16f3			jsr		DeRefBoth
.1535	20 4d 15	jsr $154d			jsr 	CheckShiftParam2
.1538	d0 0f		bne $1549			bne 	BinaryShiftZero
.153a					BSRLoop:
.153a	d6 29		dec $29,x			dec 	esInt0+1,x
.153c	30 06		bmi $1544			bmi 	BinaryShiftExit
.153e	20 3a 1e	jsr $1e3a			jsr 	Int32ShiftRight
.1541	4c 3a 15	jmp $153a			jmp 	BSRLoop
.1544					BinaryShiftExit:
.1544	a9 00		lda #$00			lda 	#0
.1546	95 20		sta $20,x			sta 	esType,x
.1548	60		rts				rts
.1549					BinaryShiftZero:
.1549	20 1c 1e	jsr $1e1c			jsr 	Int32False
.154c	60		rts				rts
.154d					CheckShiftParam2:
.154d	b5 29		lda $29,x			lda 	esInt0+1,x 					; if value >= 32 then result is zero
.154f	29 e0		and #$e0			and 	#$E0
.1551	15 31		ora $31,x			ora 	esInt1+1,x
.1553	15 39		ora $39,x			ora 	esInt2+1,x
.1555	15 41		ora $41,x			ora 	esInt3+1,x
.1557	60		rts				rts
.1558					IndirectWord:
.1558	20 f3 16	jsr $16f3			jsr		DeRefBoth
.155b	20 0d 1d	jsr $1d0d			jsr 	Int32Add
.155e	a9 80		lda #$80			lda 	#$80 						; make it a reference
.1560	95 20		sta $20,x			sta 	esType,x
.1562	60		rts				rts
.1563					IndirectByte:
.1563	20 f3 16	jsr $16f3			jsr		DeRefBoth
.1566	20 0d 1d	jsr $1d0d			jsr 	Int32Add
.1569	a9 c0		lda #$c0			lda 	#$C0 						; type is set to byte reference.
.156b	95 20		sta $20,x			sta 	esType,x
.156d	60		rts				rts
.156e					IndirectString:
.156e	20 f3 16	jsr $16f3			jsr		DeRefBoth
.1571	20 0d 1d	jsr $1d0d			jsr 	Int32Add
.1574	a9 81		lda #$81			lda 	#$81 						; type is set to string reference.
.1576	95 20		sta $20,x			sta 	esType,x
.1578	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary2.asm

.1579					Binary_Equal:
.1579	20 a9 15	jsr $15a9			jsr 	TestEqual
.157c	b0 04		bcs $1582			bcs 	CompTrue
.157e					CompFalse:
.157e	20 1c 1e	jsr $1e1c			jsr 	Int32False
.1581	60		rts				rts
.1582					CompTrue
.1582	20 18 1e	jsr $1e18			jsr 	Int32True
.1585	60		rts				rts
.1586					Binary_NotEqual:
.1586	20 a9 15	jsr $15a9			jsr 	TestEqual
.1589	90 f7		bcc $1582			bcc 	CompTrue
.158b	b0 f1		bcs $157e			bcs 	CompFalse
.158d					Binary_Less:
.158d	20 c0 15	jsr $15c0			jsr 	TestLess
.1590	b0 f0		bcs $1582			bcs 	CompTrue
.1592	90 ea		bcc $157e			bcc 	CompFalse
.1594					Binary_GreaterEqual:
.1594	20 c0 15	jsr $15c0			jsr 	TestLess
.1597	90 e9		bcc $1582			bcc 	CompTrue
.1599	b0 e3		bcs $157e			bcs 	CompFalse
.159b					Binary_LessEqual:
.159b	20 bd 15	jsr $15bd			jsr 	TestLessSwap
.159e	90 e2		bcc $1582			bcc 	CompTrue
.15a0	b0 dc		bcs $157e			bcs 	CompFalse
.15a2					Binary_Greater:
.15a2	20 bd 15	jsr $15bd			jsr 	TestLessSwap
.15a5	b0 db		bcs $1582			bcs 	CompTrue
.15a7	90 d5		bcc $157e			bcc 	CompFalse
.15a9					TestEqual:
.15a9	20 d7 15	jsr $15d7			jsr 	TypeCheck
.15ac	c9 00		cmp #$00			cmp 	#0
.15ae	f0 0a		beq $15ba			beq 	_TEInteger
.15b0	20 00 16	jsr $1600			jsr 	StringCompare
.15b3	c9 00		cmp #$00			cmp 	#0
.15b5	38		sec				sec
.15b6	f0 01		beq $15b9			beq 	_TEZero
.15b8	18		clc				clc
.15b9					_TEZero
.15b9	60		rts				rts
.15ba					_TEInteger:
.15ba	4c f7 1b	jmp $1bf7			jmp 	Int32Equal
.15bd					TestLessSwap:
.15bd	20 e4 15	jsr $15e4			jsr 	SwapTopStack
.15c0					TestLess:
.15c0	20 d7 15	jsr $15d7			jsr 	TypeCheck
.15c3	c9 00		cmp #$00			cmp 	#0
.15c5	f0 0d		beq $15d4			beq 	_TLInteger
.15c7	20 00 16	jsr $1600			jsr 	StringCompare
.15ca	c9 00		cmp #$00			cmp 	#0
.15cc	38		sec				sec
.15cd	30 01		bmi $15d0			bmi 	_TELess
.15cf	18		clc				clc
.15d0					_TELess:
.15d0	60		rts				rts
.15d1	4c 33 1a	jmp $1a33			jmp 	EHandlerNotImplemented
.15d4					_TLInteger:
.15d4	4c 11 1c	jmp $1c11			jmp 	Int32Less
.15d7					TypeCheck:
.15d7	20 f3 16	jsr $16f3			jsr 	DerefBoth
.15da	b5 20		lda $20,x			lda 	esType,x
.15dc	d5 21		cmp $21,x			cmp 	esType+1,x
.15de	d0 01		bne $15e1			bne 	_TCMismatch
.15e0	60		rts				rts
.15e1					_TCMismatch:
.15e1	4c 7f 1a	jmp $1a7f			jmp 	EHandlerTypeMismatch
.15e4					SwapTopStack:
.15e4	a9 06		lda #$06			lda 	#6
.15e6	85 03		sta $03				sta 	tempShort
.15e8	8a		txa				txa
.15e9	48		pha				pha
.15ea					_TLSLoop:
.15ea	b5 20		lda $20,x			lda 	esType,x
.15ec	48		pha				pha
.15ed	b5 21		lda $21,x			lda 	esType+1,x
.15ef	95 20		sta $20,x			sta 	esType,x
.15f1	68		pla				pla
.15f2	95 21		sta $21,x			sta 	esType+1,x
.15f4	8a		txa				txa
.15f5	18		clc				clc
.15f6	69 08		adc #$08			adc 	#DataStackSize
.15f8	aa		tax				tax
.15f9	c6 03		dec $03				dec 	tempShort
.15fb	d0 ed		bne $15ea			bne 	_TLSLoop
.15fd	68		pla				pla
.15fe	aa		tax				tax
.15ff	60		rts				rts
.1600					StringCompare:
.1600	b5 28		lda $28,x			lda 	esInt0,x 					; copy addresses.
.1602	85 04		sta $04				sta 	temp0
.1604	b5 30		lda $30,x			lda 	esInt1,x
.1606	85 05		sta $05				sta 	temp0+1
.1608	b5 29		lda $29,x			lda 	esInt0+1,x
.160a	85 06		sta $06				sta 	temp1
.160c	b5 31		lda $31,x			lda 	esInt1+1,x
.160e	85 07		sta $07				sta 	temp1+1
.1610	84 03		sty $03				sty 	tempShort
.1612	a0 ff		ldy #$ff			ldy 	#255
.1614	c8		iny		_SCLoop:iny
.1615	b1 04		lda ($04),y			lda 	(temp0),y 					; check match return +ve/-ve if fail.
.1617	38		sec				sec
.1618	f1 06		sbc ($06),y			sbc 	(temp1),y
.161a	d0 04		bne $1620			bne 	_SCExit
.161c	b1 04		lda ($04),y			lda 	(temp0),y 					; matched zero, then exit with zero
.161e	d0 f4		bne $1614			bne 	_SCLoop
.1620					_SCExit:
.1620	a4 03		ldy $03				ldy 	tempShort
.1622	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/evaluate.asm

.1623					EvaluateTerm:
.1623	a9 0f		lda #$0f			lda 	#15
.1625	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX
.1628	4c f8 16	jmp $16f8			jmp 	DeRefTop
.162b					EvaluateBaseDeRef:
.162b	20 37 16	jsr $1637			jsr 	EvaluateBase
.162e	4c f8 16	jmp $16f8			jmp 	DeRefTop
.1631					EvaluateTOSDeRef:
.1631	20 39 16	jsr $1639			jsr 	EvaluateTOS
.1634	4c f8 16	jmp $16f8			jmp 	DeRefTop
.1637					EvaluateBase:
.1637	a2 00		ldx #$00			ldx 	#0 							; reset Stack index
.1639					EvaluateTOS:
.1639	a9 00		lda #$00			lda 	#0 							; start from lowest level.
.163b					EvaluateLevelAX:
.163b	48		pha				pha 								; save level on stack
.163c	a9 00		lda #$00			lda 	#0 							; erase the current stack level
.163e	95 28		sta $28,x			sta 	esInt0,x
.1640	95 30		sta $30,x			sta 	esInt1,x
.1642	95 38		sta $38,x			sta 	esInt2,x
.1644	95 40		sta $40,x			sta 	esInt3,x
.1646	95 20		sta $20,x			sta 	esType,x 					; default to integer.
.1648	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next token/element.
.164a	30 59		bmi $16a5			bmi 	EBNotVariable 				; if $80-$FF it is a token.
.164c	c9 70		cmp #$70			cmp 	#$70 						; if $70-$7F it is a constant
.164e	90 06		bcc $1656			bcc 	_EBNotConstant
.1650					_EBConstant:
.1650	20 37 17	jsr $1737			jsr 	ExtractConstant
.1653	4c 79 16	jmp $1679			jmp 	EBHaveTerm
.1656					_EBNotConstant:
.1656	c9 60		cmp #$60			cmp 	#$60 						; 60 is a string.
.1658	f0 06		beq $1660			beq 	_EBHaveString
.165a	20 63 21	jsr $2163			jsr 	VariableAccess
.165d	4c 79 16	jmp $1679			jmp 	EBHaveTerm
.1660					_EBHaveString:
.1660	98		tya				tya 								; put codePtr + 2 in the address, it's a string.
.1661	18		clc				clc
.1662	69 02		adc #$02			adc 	#2
.1664	65 00		adc $00				adc 	codePtr
.1666	95 28		sta $28,x			sta 	esInt0,x
.1668	a5 01		lda $01				lda 	codePtr+1
.166a	69 00		adc #$00			adc 	#0
.166c	95 30		sta $30,x			sta 	esInt1,x
.166e	f6 20		inc $20,x			inc 	esType,x 					; make the type a string.
.1670	98		tya				tya 								; position in A
.1671	c8		iny				iny 								; point to offset and add it
.1672	18		clc				clc
.1673	71 00		adc ($00),y			adc 	(codePtr),y
.1675	a8		tay				tay
.1676	4c 79 16	jmp $1679			jmp 	EBHaveTerm 				; do the term code.
.1679					EBHaveTerm:
.1679	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next element.
.167b	10 26		bpl $16a3			bpl 	_EBPopExit 					; needs to be a token to continue.
.167d	84 03		sty $03				sty 	tempShort
.167f	a8		tay				tay
.1680	b9 24 1a	lda $1a24,y			lda 	KeywordTypes-$80,y 			; get the type of the keyword.
.1683	a4 03		ldy $03				ldy 	tempShort
.1685	c9 10		cmp #$10			cmp 	#16 						; not a binary operator.
.1687	b0 1a		bcs $16a3			bcs 	_EBPopExit
.1689	85 03		sta $03				sta 	tempShort 					; save level of new operator.
.168b	68		pla				pla 								; restore current level.
.168c	c5 03		cmp $03				cmp 	tempShort 					; if current >= operator then exit
.168e	b0 14		bcs $16a4			bcs 	_EBExit
.1690	48		pha				pha 								; push level on stack.
.1691	b1 00		lda ($00),y			lda		(codePtr),y					; get the token ID and skip
.1693	c8		iny				iny
.1694	48		pha				pha 								; put that on the stack.
.1695	e8		inx				inx 								; do the term in the next stack level.
.1696	a5 03		lda $03				lda 	tempShort 					; get the level of the operator.
.1698	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX
.169b	ca		dex				dex
.169c	68		pla				pla 								; get token ID
.169d	20 68 17	jsr $1768			jsr 	ExecuteCommand 				; execute command A.
.16a0	4c 79 16	jmp $1679			jmp 	EBHaveTerm 					; keep going round
.16a3					_EBPopExit:
.16a3	68		pla				pla
.16a4					_EBExit:
.16a4	60		rts				rts
.16a5					EBNotVariable:
.16a5	84 03		sty $03				sty 	tempShort 					; get the type
.16a7	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.16a9	a8		tay				tay
.16aa	b9 24 1a	lda $1a24,y			lda 	KeywordTypes-$80,y
.16ad	a4 03		ldy $03				ldy 	tempShort
.16af	29 40		and #$40			and 	#$40 						; check unary function
.16b1	d0 37		bne $16ea			bne 	_EBExecUnaryFunction
.16b3	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.16b5	c8		iny				iny
.16b6	c9 8b		cmp #$8b			cmp 	#KWD_MINUS
.16b8	f0 0f		beq $16c9			beq 	_EBNegate
.16ba	c9 91		cmp #$91			cmp 	#KWD_PLING
.16bc	f0 14		beq $16d2			beq 	_EBUnaryReference
.16be	c9 92		cmp #$92			cmp 	#KWD_QUESTION
.16c0	f0 10		beq $16d2			beq 	_EBUnaryReference
.16c2	c9 93		cmp #$93			cmp 	#KWD_DOLLAR
.16c4	f0 0c		beq $16d2			beq 	_EBUnaryReference
.16c6					_EBError:
.16c6	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax
.16c9					_EBNegate:
.16c9	20 23 16	jsr $1623			jsr 	EvaluateTerm
.16cc	20 d6 1d	jsr $1dd6			jsr 	Int32Negate
.16cf	4c 79 16	jmp $1679			jmp 	EBHaveTerm
.16d2					_EBUnaryReference:
.16d2	48		pha				pha 								; save keyword
.16d3	20 23 16	jsr $1623			jsr 	EvaluateTerm 				; get the address to case.
.16d6	68		pla				pla
.16d7	49 91		eor #$91			eor 	#KWD_PLING 					; is it pling, then will now be zero.
.16d9	f0 08		beq $16e3			beq 	_EBSetType
.16db	49 02		eor #$02			eor 	#KWD_DOLLAR^KWD_PLING 		; if was dollar will now be zero
.16dd	f0 02		beq $16e1			beq 	_EBSetString
.16df	a9 41		lda #$41			lda 	#$41 						; will end up as $C0
.16e1					_EBSetString:
.16e1	49 01		eor #$01			eor 	#$01 						; will end up as $81
.16e3					_EBSetType:
.16e3	09 80		ora #$80			ora 	#$80 						; make it a reference.
.16e5	95 20		sta $20,x			sta 	esType,x
.16e7	4c 79 16	jmp $1679			jmp 	EBHaveTerm
.16ea					_EBExecUnaryFunction:
.16ea	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the function token.
.16ec	c8		iny				iny
.16ed	20 68 17	jsr $1768			jsr 	ExecuteCommand 				; and do it.
.16f0	4c 79 16	jmp $1679			jmp 	EBHaveTerm
.16f3					DeRefBoth:
.16f3	e8		inx				inx
.16f4	20 f8 16	jsr $16f8			jsr 	DeRefTop
.16f7	ca		dex				dex
.16f8					DeRefTop:
.16f8	b5 20		lda $20,x			lda 	esType,x 					; is it a reference ?
.16fa	10 3a		bpl $1736			bpl 	_DRTExit
.16fc	29 7f		and #$7f			and 	#$7F 						; clear the reference bit and write back.
.16fe	95 20		sta $20,x			sta 	esType,x
.1700	4a		lsr a				lsr 	a 							; if string, exit. Strings are always references
.1701	b0 33		bcs $1736			bcs 	_DRTExit
.1703	b5 28		lda $28,x			lda 	esInt0,x 					; copy address over.
.1705	85 04		sta $04				sta 	temp0
.1707	b5 30		lda $30,x			lda 	esInt1,x
.1709	85 05		sta $05				sta 	temp0+1
.170b	98		tya				tya
.170c	48		pha				pha
.170d	a0 00		ldy #$00			ldy 	#0
.170f	b1 04		lda ($04),y			lda 	(temp0),y
.1711	95 28		sta $28,x			sta 	esInt0,x
.1713	b5 20		lda $20,x			lda 	esType,x 					; is it now zero, e.g. it's a !
.1715	f0 0c		beq $1723			beq 	_DRTPling
.1717	98		tya				tya 								; clear upper 3 bytes
.1718	95 30		sta $30,x			sta 	esInt1,x
.171a	95 38		sta $38,x			sta 	esInt2,x
.171c	95 40		sta $40,x			sta 	esInt3,x
.171e	95 20		sta $20,x			sta 	esType,x
.1720	4c 34 17	jmp $1734			jmp	 	_DRTExit2
.1723					_DRTPling:
.1723	94 20		sty $20,x			sty 	esType,x 					; make it an integer
.1725	c8		iny				iny
.1726	b1 04		lda ($04),y			lda 	(temp0),y 					; copy 4 bytes.
.1728	95 30		sta $30,x			sta 	esInt1,x
.172a	c8		iny				iny
.172b	b1 04		lda ($04),y			lda 	(temp0),y
.172d	95 38		sta $38,x			sta 	esInt2,x
.172f	c8		iny				iny
.1730	b1 04		lda ($04),y			lda 	(temp0),y
.1732	95 40		sta $40,x			sta 	esInt3,x
.1734					_DRTExit2:
.1734	68		pla				pla
.1735	a8		tay				tay
.1736					_DRTExit:
.1736	60		rts				rts
.1737					ExtractConstant:
.1737	a9 00		lda #$00			lda 	#0 							; count of number of hex digits read.
.1739	85 03		sta $03				sta 	tempShort 					; use tempShort for that
.173b	8a		txa				txa
.173c	48		pha				pha
.173d					_EBConstLoop:
.173d	e6 03		inc $03				inc 	tempShort 					; bump the hex digit count.
.173f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character.
.1741	29 f0		and #$f0			and 	#$F0 						; check it is 70-7F
.1743	c9 70		cmp #$70			cmp 	#$70
.1745	d0 1e		bne $1765			bne 	_EBConstEnd
.1747	a5 03		lda $03				lda 	tempShort 					; check LSB of digit count
.1749	4a		lsr a				lsr 	a
.174a	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the digit and bump
.174c	c8		iny				iny
.174d	90 06		bcc $1755			bcc		_EBConstHigh 				; goes in upper byte.
.174f	29 0f		and #$0f			and 	#$0F
.1751	95 28		sta $28,x			sta 	esInt0,x 					; and write it out.
.1753	10 e8		bpl $173d			bpl 	_EBConstLoop 				; try next one.
.1755					_EBConstHigh:
.1755	0a		asl a				asl 	a
.1756	0a		asl a				asl 	a
.1757	0a		asl a				asl 	a
.1758	0a		asl a				asl 	a
.1759	15 28		ora $28,x			ora 	esInt0,x 					; put into upper 4 bits
.175b	95 28		sta $28,x			sta 	esInt0,x
.175d	8a		txa				txa 								; move to next slot in data stack.
.175e	18		clc				clc
.175f	69 08		adc #$08			adc 	#DataStackSize
.1761	aa		tax				tax
.1762	4c 3d 17	jmp $173d			jmp 	_EBConstLoop
.1765					_EBConstEnd:
.1765	68		pla				pla
.1766	aa		tax				tax
.1767	60		rts				rts
.1768					ExecuteCommand:
.1768	85 03		sta $03				sta 	tempShort  					; needs making 65C02 specific.
.176a	8a		txa				txa
.176b	48		pha				pha
.176c	a6 03		ldx $03				ldx 	tempShort
.176e	bd 7c 1a	lda $1a7c,x			lda 	TokenVectorLow-$80,x
.1771	85 04		sta $04				sta 	temp0
.1773	bd d4 1a	lda $1ad4,x			lda 	TokenVectorHigh-$80,x
.1776	85 05		sta $05				sta 	temp0+1
.1778	68		pla				pla
.1779	aa		tax				tax
.177a	6c 04 00	jmp ($0004)			jmp 	(temp0)

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/unary.asm

.177d					UnaryPage:
.177d	20 94 17	jsr $1794			jsr 	UnaryFalse 					; set all to zero/int
.1780	a9 00		lda #$00			lda 	#BasicProgram & $FF
.1782	95 28		sta $28,x			sta 	esInt0,x
.1784	a9 27		lda #$27			lda 	#BasicProgram >> 8
.1786	95 30		sta $30,x			sta 	esInt1,x
.1788	60		rts				rts
.1789					UnaryParenthesis:
.1789	20 39 16	jsr $1639			jsr 	EvaluateTOS					; evaluate expression
.178c	20 3d 14	jsr $143d			jsr 	CheckRightParen				; check for )
.178f	60		rts				rts
.1790					UnaryTrue:
.1790	20 18 1e	jsr $1e18			jsr 	Int32True
.1793	60		rts				rts
.1794					UnaryFalse:
.1794	20 1c 1e	jsr $1e1c			jsr 	Int32False
.1797	60		rts				rts
.1798					UnaryAbs:
.1798	20 23 16	jsr $1623			jsr 	EvaluateTerm				; work out value required and dispatch
.179b	20 d1 1d	jsr $1dd1			jsr		Int32Absolute
.179e	a9 00		lda #$00			lda 	#0
.17a0	95 20		sta $20,x			sta 	esType,x
.17a2	60		rts				rts
.17a3					UnarySys:
.17a3	20 23 16	jsr $1623			jsr 	EvaluateTerm				; address to call
.17a6	b5 28		lda $28,x			lda 	esInt0,x 					; copy call address
.17a8	85 04		sta $04				sta 	temp0
.17aa	b5 30		lda $30,x			lda 	esInt1,x
.17ac	85 05		sta $05				sta 	temp0+1
.17ae	8a		txa				txa
.17af	48		pha				pha
.17b0	98		tya				tya
.17b1	48		pha				pha
.17b2	ad 00 08	lda $0800			lda 	aVariable 				 	; load AXY
.17b5	ae 5c 08	ldx $085c			ldx 	xVariable
.17b8	ac 60 08	ldy $0860			ldy 	yVariable
.17bb	20 d1 17	jsr $17d1			jsr 	_USCall						; call code
.17be	8d 00 08	sta $0800			sta 	aVariable 				 	; save AXY
.17c1	8e 5c 08	stx $085c			stx 	xVariable
.17c4	8c 60 08	sty $0860			sty 	yVariable
.17c7	68		pla				pla
.17c8	a8		tay				tay
.17c9	68		pla				pla
.17ca	aa		tax				tax
.17cb	ad 00 08	lda $0800			lda 	aVariable 				 	; load A to return
.17ce	4c 2b 1e	jmp $1e2b			jmp 	Int32Set8Bit
.17d1	6c 04 00	jmp ($0004)	_USCall:jmp 	(temp0)
.17d4					UnarySgn1:
.17d4	20 23 16	jsr $1623			jsr 	EvaluateTerm				; work out value required and dispatch
.17d7	20 09 1e	jsr $1e09			jsr 	Int32Sign
.17da	a9 00		lda #$00			lda 	#0
.17dc	95 20		sta $20,x			sta 	esType,x
.17de	60		rts				rts
.17df					UnaryNot:
.17df	20 23 16	jsr $1623			jsr 	EvaluateTerm				; work out value required and dispatch
.17e2	20 f0 1d	jsr $1df0			jsr 	Int32Not
.17e5	a9 00		lda #$00			lda 	#0
.17e7	95 20		sta $20,x			sta 	esType,x
.17e9	60		rts				rts
.17ea					UnaryMin:
.17ea	38		sec				sec 								; min indicated with CS
.17eb	b0 01		bcs $17ee			bcs 	UnaryMax+1
.17ed					UnaryMax:
.17ed	18		clc				clc 								; max is CC.
.17ee	08		php				php 								; save what we're doing.
.17ef	20 2b 14	jsr $142b			jsr 	CheckLeftParen 				; check for (, required here
.17f2	20 31 16	jsr $1631			jsr 	EvaluateTOSDeRef			; evaluate expression
.17f5	e8		inx				inx
.17f6	20 25 14	jsr $1425			jsr 	CheckComma
.17f9	20 31 16	jsr $1631			jsr 	EvaluateTOSDeRef
.17fc	20 f3 16	jsr $16f3			jsr 	DerefBoth 					; dereference them.
.17ff	ca		dex				dex
.1800	20 3d 14	jsr $143d			jsr 	CheckRightParen
.1803	20 11 1c	jsr $1c11			jsr 	Int32Less 					; is p1 < p2, CS if true.
.1806	a9 00		lda #$00			lda 	#0 							; put into A, now 1 if <, 0 if >
.1808	69 00		adc #$00			adc 	#0
.180a	28		plp				plp
.180b	69 00		adc #$00			adc 	#0 							; toggle bit 0 for Min.
.180d	4a		lsr a				lsr 	a 							; put into carry
.180e	90 03		bcc $1813			bcc 	_UMinMaxExit 				; if clear just exit.
.1810	20 e4 15	jsr $15e4			jsr 	SwapTopStack 				; swap two values over.
.1813					_UMinMaxExit:
.1813	a9 00		lda #$00			lda 	#0
.1815	95 20		sta $20,x			sta 	esType,x
.1817	60		rts				rts
.1818					UTypeError:
.1818	4c 7f 1a	jmp $1a7f			jmp 	EHandlerTypeMismatch
.181b					UnaryRefToValue:
.181b	a9 0f		lda #$0f			lda 	#15
.181d	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX 			; get a term.
.1820	b5 20		lda $20,x			lda 	esType,x
.1822	10 f4		bpl $1818			bpl 	UTypeError 					; not a reference
.1824	29 7f		and #$7f			and 	#$7F 						; clear reference bit.
.1826	95 20		sta $20,x			sta 	esType,x 					; overwrite type
.1828	a9 00		lda #$00			lda 	#0
.182a	95 20		sta $20,x			sta 	esType,x
.182c	60		rts				rts
.182d					UnaryHexMarker:
.182d	4c 23 16	jmp $1623			jmp 	EvaluateTerm
.1830					UnaryRandom:
.1830	20 4c 1e	jsr $1e4c			jsr 	Int32Random 				; random #
.1833	a9 00		lda #$00			lda 	#0
.1835	95 20		sta $20,x			sta 	esType,x
.1837	60		rts				rts
.1838					UnaryLen:
.1838	20 23 16	jsr $1623			jsr 	EvaluateTerm				; work out value required and dispatch
.183b	b5 28		lda $28,x			lda 	esInt0,x 					; copy addr to temp0
.183d	85 04		sta $04				sta 	temp0
.183f	b5 30		lda $30,x			lda 	esInt1,x
.1841	85 05		sta $05				sta 	temp0+1
.1843	20 94 17	jsr $1794			jsr 	UnaryFalse 					; sets return to int zero.
.1846	98		tya				tya
.1847	48		pha				pha
.1848	a0 00		ldy #$00			ldy 	#0
.184a					_ULCheck:
.184a	b1 04		lda ($04),y			lda 	(temp0),y
.184c	f0 03		beq $1851			beq 	_ULFound
.184e	c8		iny				iny
.184f	d0 f9		bne $184a			bne 	_ULCheck
.1851					_ULFound:
.1851	94 28		sty $28,x			sty 	esInt0,x 					; update result
.1853	68		pla				pla
.1854	a8		tay				tay
.1855	60		rts				rts
.1856	60		rts				rts
.1857					UnaryChr:
.1857	20 23 16	jsr $1623			jsr 	EvaluateTerm				; work out value required and dereference
.185a	b5 28		lda $28,x			lda 	esInt0,x 					; get char code
.185c	8d a5 08	sta $08a5			sta 	ChrBuffer 					; put into buffer.
.185f	a9 00		lda #$00			lda 	#0
.1861	8d a6 08	sta $08a6			sta 	ChrBuffer+1 				; make ASCIIZ
.1864	a9 a5		lda #$a5			lda 	#ChrBuffer & $FF 			; set address
.1866	95 28		sta $28,x			sta 	esInt0,x
.1868	a9 08		lda #$08			lda 	#ChrBuffer >> 8
.186a	95 30		sta $30,x			sta 	esInt1,x
.186c	f6 20		inc $20,x			inc 	esType,x 					; makes it a string
.186e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/alloc.asm

.186f					Unary_Alloc:
.186f	20 23 16	jsr $1623			jsr 	EvaluateTerm				; memory to allocate
.1872	a5 10		lda $10				lda 	LowMemory 					; push low memory ons tack.
.1874	48		pha				pha
.1875	a5 11		lda $11				lda 	LowMemory+1
.1877	48		pha				pha
.1878	20 c3 10	jsr $10c3			jsr 	AllocMemStackCount 			; allocate memory (in DIM code)
.187b	68		pla				pla 								; update stack entry
.187c	95 30		sta $30,x			sta 	esInt1,x
.187e	68		pla				pla
.187f	95 28		sta $28,x			sta 	esInt0,x
.1881	a9 00		lda #$00			lda 	#0
.1883	95 38		sta $38,x			sta 	esInt2,x
.1885	95 40		sta $40,x			sta 	esInt3,x
.1887	95 20		sta $20,x			sta 	esType,x
.1889	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/event.asm

.188a					Event_Function:
.188a	20 2b 14	jsr $142b			jsr 	CheckLeftParen 				; check for (
.188d	a9 04		lda #$04			lda 	#4  						; this means ! ? and $ binary operators only work.
.188f	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX 			; this is the event variable.
.1892	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.1894	10 5d		bpl $18f3			bpl 	_EFSyntax 					; if not, syntax error.
.1896	20 25 14	jsr $1425			jsr 	CheckComma
.1899	e8		inx				inx
.189a	20 31 16	jsr $1631			jsr 	EvaluateTOSDeRef 			; get the rate
.189d	ca		dex				dex
.189e	20 3d 14	jsr $143d			jsr 	CheckRightParen 			; closing bracket.
.18a1	20 d5 25	jsr $25d5			jsr 	XTUpdateClock
.18a4	98		tya				tya
.18a5	48		pha				pha
.18a6	b5 28		lda $28,x			lda 	esInt0,x 					; point temp0 to the variable
.18a8	85 04		sta $04				sta 	temp0
.18aa	b5 30		lda $30,x			lda 	esInt1,x
.18ac	85 05		sta $05				sta 	temp0+1
.18ae	a0 00		ldy #$00			ldy 	#0 							; check if zero, if so initialise/return FLASE
.18b0	b1 04		lda ($04),y			lda 	(temp0),y
.18b2	c8		iny				iny
.18b3	11 04		ora ($04),y			ora 	(temp0),y
.18b5	f0 1b		beq $18d2			beq 	_EFInitialise
.18b7	a0 00		ldy #$00			ldy 	#0 							; calc timer - variable
.18b9	ad a0 08	lda $08a0			lda 	ClockTicks
.18bc	d1 04		cmp ($04),y			cmp 	(temp0),y
.18be	c8		iny				iny
.18bf	ad a1 08	lda $08a1			lda 	ClockTicks+1
.18c2	f1 04		sbc ($04),y			sbc 	(temp0),y
.18c4	10 06		bpl $18cc			bpl 	_EFFire						; if >= reset and return TRUE
.18c6	20 1c 1e	jsr $1e1c			jsr 	Int32False					; otherwise just return FALSE
.18c9	4c f0 18	jmp $18f0			jmp 	_EFExit
.18cc					_EFFire:
.18cc	20 18 1e	jsr $1e18			jsr 	Int32True
.18cf	4c d5 18	jmp $18d5			jmp 	_EFResetTimer
.18d2					_EFInitialise:
.18d2	20 1c 1e	jsr $1e1c			jsr 	Int32False 					; return FALSE
.18d5					_EFResetTimer:
.18d5	a0 00		ldy #$00			ldy 	#0 							; reset the variable to clock + rate.
.18d7	18		clc				clc
.18d8	ad a0 08	lda $08a0			lda 	ClockTicks
.18db	75 29		adc $29,x			adc 	esInt0+1,x
.18dd	91 04		sta ($04),y			sta 	(temp0),y
.18df	c8		iny				iny
.18e0	ad a1 08	lda $08a1			lda 	ClockTicks+1
.18e3	75 31		adc $31,x			adc 	esInt1+1,x
.18e5	91 04		sta ($04),y			sta 	(temp0),y
.18e7	88		dey				dey									; check zero
.18e8	11 04		ora ($04),y			ora 	(temp0),y
.18ea	d0 04		bne $18f0			bne 	_EFExit
.18ec	a9 01		lda #$01			lda 	#1 							; if so set it to 1.
.18ee	91 04		sta ($04),y			sta 	(temp0),y
.18f0					_EFExit:
.18f0	68		pla				pla
.18f1	a8		tay				tay
.18f2	60		rts				rts
.18f3					_EFSyntax:
.18f3	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/functions/keyboard.asm

.18f6					Unary_Inkey:
.18f6	20 c5 25	jsr $25c5			jsr 	XTGetKey
.18f9	95 28		sta $28,x			sta 	esInt0,x
.18fb	4c 2b 1e	jmp $1e2b			jmp 	Int32Set8Bit
.18fe					Unary_Get:
.18fe	20 f6 18	jsr $18f6			jsr 	Unary_Inkey
.1901	b5 28		lda $28,x			lda 	esInt0,x
.1903	f0 f9		beq $18fe			beq 	Unary_Get
.1905	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/timer.asm

.1906					Unary_Timer:
.1906	20 d5 25	jsr $25d5			jsr 	XTUpdateClock
.1909	ad a0 08	lda $08a0			lda 	ClockTicks
.190c	95 28		sta $28,x			sta 	esInt0,x
.190e	ad a1 08	lda $08a1			lda 	ClockTicks+1
.1911	95 30		sta $30,x			sta 	esInt1,x
.1913	ad a2 08	lda $08a2			lda 	ClockTicks+2
.1916	95 38		sta $38,x			sta 	esInt2,x
.1918	a9 00		lda #$00			lda 	#0
.191a	95 40		sta $40,x			sta 	esInt3,x
.191c	95 20		sta $20,x			sta 	esType,x
.191e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/generated/errors.asm

.191f					EHandlerAssert:
.191f	20 50 14	jsr $1450		jsr	ErrorHandler
>1922	41 73 73 65 72 74 20 46			.text "Assert Failed",0
>192a	61 69 6c 65 64 00
.1930					EHandlerBadAIndex:
.1930	20 50 14	jsr $1450		jsr	ErrorHandler
>1933	42 61 64 20 41 72 72 61			.text "Bad Array Index",0
>193b	79 20 49 6e 64 65 78 00
.1943					EHandlerBadIndex:
.1943	20 50 14	jsr $1450		jsr	ErrorHandler
>1946	57 72 6f 6e 67 20 4e 65			.text "Wrong Next index",0
>194e	78 74 20 69 6e 64 65 78 00
.1957					EHandlerBadProc:
.1957	20 50 14	jsr $1450		jsr	ErrorHandler
>195a	55 6e 6b 6e 6f 77 6e 20			.text "Unknown Procedure",0
>1962	50 72 6f 63 65 64 75 72 65 00
.196c					EHandlerBranchSize:
.196c	20 50 14	jsr $1450		jsr	ErrorHandler
>196f	42 72 61 6e 63 68 20 72			.text "Branch range",0
>1977	61 6e 67 65 00
.197c					EHandlerClosure:
.197c	20 50 14	jsr $1450		jsr	ErrorHandler
>197f	53 74 72 75 63 74 75 72			.text "Structure Error",0
>1987	65 20 45 72 72 6f 72 00
.198f					EHandlerDivideZero:
.198f	20 50 14	jsr $1450		jsr	ErrorHandler
>1992	44 69 76 69 64 65 20 62			.text "Divide by Zero",0
>199a	79 20 5a 65 72 6f 00
.19a1					EHandlerLineNumber:
.19a1	20 50 14	jsr $1450		jsr	ErrorHandler
>19a4	55 6e 6b 6e 6f 77 6e 20			.text "Unknown line",0
>19ac	6c 69 6e 65 00
.19b1					EHandlerMemory:
.19b1	20 50 14	jsr $1450		jsr	ErrorHandler
>19b4	49 6e 73 75 66 66 69 63			.text "Insufficient Memory",0
>19bc	69 65 6e 74 20 4d 65 6d 6f 72 79 00
.19c8					EHandlerNoArray:
.19c8	20 50 14	jsr $1450		jsr	ErrorHandler
>19cb	42 61 64 20 41 72 72 61			.text "Bad Array",0
>19d3	79 00
.19d5					EHandlerNoGosub:
.19d5	20 50 14	jsr $1450		jsr	ErrorHandler
>19d8	52 65 74 75 72 6e 20 77			.text "Return without Gosub",0
>19e0	69 74 68 6f 75 74 20 47 6f 73 75 62 00
.19ed					EHandlerNoProc:
.19ed	20 50 14	jsr $1450		jsr	ErrorHandler
>19f0	45 6e 64 50 72 6f 63 20			.text "EndProc without Proc",0
>19f8	77 69 74 68 6f 75 74 20 50 72 6f 63 00
.1a05					EHandlerNoRepeat:
.1a05	20 50 14	jsr $1450		jsr	ErrorHandler
>1a08	55 6e 74 69 6c 20 77 69			.text "Until without Repeat",0
>1a10	74 68 6f 75 74 20 52 65 70 65 61 74 00
.1a1d					EHandlerNoWhile:
.1a1d	20 50 14	jsr $1450		jsr	ErrorHandler
>1a20	57 65 6e 64 20 77 69 74			.text "Wend without While",0
>1a28	68 6f 75 74 20 57 68 69 6c 65 00
.1a33					EHandlerNotImplemented:
.1a33	20 50 14	jsr $1450		jsr	ErrorHandler
>1a36	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>1a3e	65 6d 65 6e 74 65 64 00
.1a46					EHandlerOperand:
.1a46	20 50 14	jsr $1450		jsr	ErrorHandler
>1a49	42 61 64 20 4f 70 65 72			.text "Bad Operand",0
>1a51	61 6e 64 00
.1a55					EHandlerParameters:
.1a55	20 50 14	jsr $1450		jsr	ErrorHandler
>1a58	42 61 64 20 50 61 72 61			.text "Bad Parameters",0
>1a60	6d 65 74 65 72 73 00
.1a67					EHandlerStop:
.1a67	20 50 14	jsr $1450		jsr	ErrorHandler
>1a6a	53 74 6f 70 00				.text "Stop",0
.1a6f					EHandlerSyntax:
.1a6f	20 50 14	jsr $1450		jsr	ErrorHandler
>1a72	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>1a7a	72 72 6f 72 00
.1a7f					EHandlerTypeMismatch:
.1a7f	20 50 14	jsr $1450		jsr	ErrorHandler
>1a82	54 79 70 65 20 4d 69 73			.text "Type Mismatch",0
>1a8a	6d 61 74 63 68 00
.1a90					EHandlerUnknownVar:
.1a90	20 50 14	jsr $1450		jsr	ErrorHandler
>1a93	55 6e 6b 6e 6f 77 6e 20			.text "Unknown variable",0
>1a9b	76 61 72 69 61 62 6c 65 00

;******  Return to file: basic.asm


;******  Processing file: common/generated/keytypes.asm

.1aa4					KeywordTypes:
>1aa4	81					.byte $81 ; $80 <<end>>
>1aa5	01					.byte $01 ; $81 and
>1aa6	01					.byte $01 ; $82 or
>1aa7	01					.byte $01 ; $83 xor
>1aa8	02					.byte $02 ; $84 >
>1aa9	02					.byte $02 ; $85 <
>1aaa	02					.byte $02 ; $86 >=
>1aab	02					.byte $02 ; $87 <=
>1aac	02					.byte $02 ; $88 <>
>1aad	02					.byte $02 ; $89 =
>1aae	03					.byte $03 ; $8a +
>1aaf	03					.byte $03 ; $8b -
>1ab0	04					.byte $04 ; $8c *
>1ab1	04					.byte $04 ; $8d /
>1ab2	04					.byte $04 ; $8e %
>1ab3	04					.byte $04 ; $8f >>
>1ab4	04					.byte $04 ; $90 <<
>1ab5	05					.byte $05 ; $91 !
>1ab6	05					.byte $05 ; $92 ?
>1ab7	05					.byte $05 ; $93 $
>1ab8	40					.byte $40 ; $94 ~
>1ab9	40					.byte $40 ; $95 (
>1aba	40					.byte $40 ; $96 &
>1abb	40					.byte $40 ; $97 @
>1abc	40					.byte $40 ; $98 len
>1abd	40					.byte $40 ; $99 sgn
>1abe	40					.byte $40 ; $9a abs
>1abf	40					.byte $40 ; $9b random
>1ac0	40					.byte $40 ; $9c page
>1ac1	40					.byte $40 ; $9d true
>1ac2	40					.byte $40 ; $9e false
>1ac3	40					.byte $40 ; $9f min
>1ac4	40					.byte $40 ; $a0 max
>1ac5	40					.byte $40 ; $a1 sys
>1ac6	40					.byte $40 ; $a2 code
>1ac7	40					.byte $40 ; $a3 timer
>1ac8	40					.byte $40 ; $a4 event
>1ac9	40					.byte $40 ; $a5 get
>1aca	40					.byte $40 ; $a6 joy.x
>1acb	40					.byte $40 ; $a7 joy.y
>1acc	40					.byte $40 ; $a8 joy.btn
>1acd	40					.byte $40 ; $a9 inkey
>1ace	40					.byte $40 ; $aa alloc
>1acf	40					.byte $40 ; $ab chr
>1ad0	81					.byte $81 ; $ac ,
>1ad1	81					.byte $81 ; $ad ;
>1ad2	81					.byte $81 ; $ae )
>1ad3	81					.byte $81 ; $af #
>1ad4	81					.byte $81 ; $b0 ++
>1ad5	81					.byte $81 ; $b1 --
>1ad6	81					.byte $81 ; $b2 ]
>1ad7	81					.byte $81 ; $b3 ->
>1ad8	82					.byte $82 ; $b4 if
>1ad9	82					.byte $82 ; $b5 for
>1ada	82					.byte $82 ; $b6 repeat
>1adb	82					.byte $82 ; $b7 proc
>1adc	82					.byte $82 ; $b8 while
>1add	80					.byte $80 ; $b9 endif
>1ade	80					.byte $80 ; $ba next
>1adf	80					.byte $80 ; $bb until
>1ae0	80					.byte $80 ; $bc endproc
>1ae1	80					.byte $80 ; $bd wend
>1ae2	81					.byte $81 ; $be rem
>1ae3	81					.byte $81 ; $bf let
>1ae4	81					.byte $81 ; $c0 '
>1ae5	81					.byte $81 ; $c1 :
>1ae6	81					.byte $81 ; $c2 [
>1ae7	81					.byte $81 ; $c3 then
>1ae8	81					.byte $81 ; $c4 else
>1ae9	81					.byte $81 ; $c5 to
>1aea	81					.byte $81 ; $c6 step
>1aeb	81					.byte $81 ; $c7 vdu
>1aec	81					.byte $81 ; $c8 print
>1aed	81					.byte $81 ; $c9 call
>1aee	81					.byte $81 ; $ca local
>1aef	81					.byte $81 ; $cb goto
>1af0	81					.byte $81 ; $cc gosub
>1af1	81					.byte $81 ; $cd return
>1af2	81					.byte $81 ; $ce assert
>1af3	81					.byte $81 ; $cf stop
>1af4	81					.byte $81 ; $d0 end
>1af5	81					.byte $81 ; $d1 dim
>1af6	81					.byte $81 ; $d2 clear
>1af7	81					.byte $81 ; $d3 load
>1af8	81					.byte $81 ; $d4 save
>1af9	81					.byte $81 ; $d5 list
>1afa	81					.byte $81 ; $d6 new
>1afb	81					.byte $81 ; $d7 run

;******  Return to file: basic.asm


;******  Processing file: common/generated/vectors.asm

.1afc					TokenVectorLow:
>1afc	c2					.byte CommandNextLine & $FF            ; <<end>>
>1afd	15					.byte BinaryAnd & $FF                  ; and
>1afe	0a					.byte BinaryOr & $FF                   ; or
>1aff	ff					.byte BinaryXor & $FF                  ; xor
>1b00	a2					.byte Binary_Greater & $FF             ; >
>1b01	8d					.byte Binary_Less & $FF                ; <
>1b02	94					.byte Binary_GreaterEqual & $FF        ; >=
>1b03	9b					.byte Binary_LessEqual & $FF           ; <=
>1b04	86					.byte Binary_NotEqual & $FF            ; <>
>1b05	79					.byte Binary_Equal & $FF               ; =
>1b06	b7					.byte BinaryAdd & $FF                  ; +
>1b07	c2					.byte BinarySub & $FF                  ; -
>1b08	cd					.byte BinaryMult & $FF                 ; *
>1b09	d8					.byte BinaryDivide & $FF               ; /
>1b0a	e6					.byte BinaryModulus & $FF              ; %
>1b0b	32					.byte BinaryShiftRight & $FF           ; >>
>1b0c	20					.byte BinaryShiftLeft & $FF            ; <<
>1b0d	58					.byte IndirectWord & $FF               ; !
>1b0e	63					.byte IndirectByte & $FF               ; ?
>1b0f	6e					.byte IndirectString & $FF             ; $
>1b10	df					.byte UnaryNot & $FF                   ; ~
>1b11	89					.byte UnaryParenthesis & $FF           ; (
>1b12	2d					.byte UnaryHexMarker & $FF             ; &
>1b13	1b					.byte UnaryRefToValue & $FF            ; @
>1b14	38					.byte UnaryLen & $FF                   ; len
>1b15	d4					.byte UnarySgn1 & $FF                  ; sgn
>1b16	98					.byte UnaryAbs & $FF                   ; abs
>1b17	30					.byte UnaryRandom & $FF                ; random
>1b18	7d					.byte UnaryPage & $FF                  ; page
>1b19	90					.byte UnaryTrue & $FF                  ; true
>1b1a	94					.byte UnaryFalse & $FF                 ; false
>1b1b	ea					.byte UnaryMin & $FF                   ; min
>1b1c	ed					.byte UnaryMax & $FF                   ; max
>1b1d	a3					.byte UnarySys & $FF                   ; sys
>1b1e	98					.byte InstructionUndefined & $FF       ; code
>1b1f	06					.byte Unary_Timer & $FF                ; timer
>1b20	8a					.byte Event_Function & $FF             ; event
>1b21	fe					.byte Unary_Get & $FF                  ; get
>1b22	98					.byte InstructionUndefined & $FF       ; joy.x
>1b23	98					.byte InstructionUndefined & $FF       ; joy.y
>1b24	98					.byte InstructionUndefined & $FF       ; joy.btn
>1b25	f6					.byte Unary_Inkey & $FF                ; inkey
>1b26	6f					.byte Unary_Alloc & $FF                ; alloc
>1b27	57					.byte UnaryChr & $FF                   ; chr
>1b28	4d					.byte NoOp1 & $FF                      ; ,
>1b29	4d					.byte NoOp2 & $FF                      ; ;
>1b2a	4d					.byte NoOp3 & $FF                      ; )
>1b2b	98					.byte InstructionUndefined & $FF       ; #
>1b2c	98					.byte InstructionUndefined & $FF       ; ++
>1b2d	98					.byte InstructionUndefined & $FF       ; --
>1b2e	98					.byte InstructionUndefined & $FF       ; ]
>1b2f	98					.byte InstructionUndefined & $FF       ; ->
>1b30	3c					.byte Command_IF & $FF                 ; if
>1b31	e4					.byte Command_FOR & $FF                ; for
>1b32	7e					.byte Command_Repeat & $FF             ; repeat
>1b33	4d					.byte NoOp6 & $FF                      ; proc
>1b34	f7					.byte Command_While & $FF              ; while
>1b35	6d					.byte Command_ENDIF & $FF              ; endif
>1b36	34					.byte Command_NEXT & $FF               ; next
>1b37	87					.byte Command_Until & $FF              ; until
>1b38	5a					.byte Command_EndProc & $FF            ; endproc
>1b39	14					.byte Command_Wend & $FF               ; wend
>1b3a	71					.byte Command_Rem & $FF                ; rem
>1b3b	6e					.byte Command_LET & $FF                ; let
>1b3c	71					.byte Command_Rem2 & $FF               ; '
>1b3d	dc					.byte Command_Colon & $FF              ; :
>1b3e	e3					.byte Command_StartAsm & $FF           ; [
>1b3f	4d					.byte NoOp7 & $FF                      ; then
>1b40	67					.byte Command_ELSE & $FF               ; else
>1b41	4d					.byte NoOp8 & $FF                      ; to
>1b42	4d					.byte NoOp9 & $FF                      ; step
>1b43	e6					.byte Command_Vdu & $FF                ; vdu
>1b44	d7					.byte Command_Print & $FF              ; print
>1b45	80					.byte Command_Call & $FF               ; call
>1b46	6e					.byte Command_Local & $FF              ; local
>1b47	f7					.byte Command_Goto & $FF               ; goto
>1b48	d8					.byte Command_Gosub & $FF              ; gosub
>1b49	e6					.byte Command_Return & $FF             ; return
>1b4a	0c					.byte Command_Assert & $FF             ; assert
>1b4b	e0					.byte Command_Stop & $FF               ; stop
>1b4c	dd					.byte Command_End & $FF                ; end
>1b4d	68					.byte Command_Dim & $FF                ; dim
>1b4e	37					.byte CommandClear & $FF               ; clear
>1b4f	98					.byte InstructionUndefined & $FF       ; load
>1b50	98					.byte InstructionUndefined & $FF       ; save
>1b51	98					.byte InstructionUndefined & $FF       ; list
>1b52	cf					.byte Command_New & $FF                ; new
>1b53	a1					.byte Command_Run & $FF                ; run
.1b54					TokenVectorHigh:
>1b54	13					.byte CommandNextLine >> 8             ; <<end>>
>1b55	15					.byte BinaryAnd >> 8                   ; and
>1b56	15					.byte BinaryOr >> 8                    ; or
>1b57	14					.byte BinaryXor >> 8                   ; xor
>1b58	15					.byte Binary_Greater >> 8              ; >
>1b59	15					.byte Binary_Less >> 8                 ; <
>1b5a	15					.byte Binary_GreaterEqual >> 8         ; >=
>1b5b	15					.byte Binary_LessEqual >> 8            ; <=
>1b5c	15					.byte Binary_NotEqual >> 8             ; <>
>1b5d	15					.byte Binary_Equal >> 8                ; =
>1b5e	14					.byte BinaryAdd >> 8                   ; +
>1b5f	14					.byte BinarySub >> 8                   ; -
>1b60	14					.byte BinaryMult >> 8                  ; *
>1b61	14					.byte BinaryDivide >> 8                ; /
>1b62	14					.byte BinaryModulus >> 8               ; %
>1b63	15					.byte BinaryShiftRight >> 8            ; >>
>1b64	15					.byte BinaryShiftLeft >> 8             ; <<
>1b65	15					.byte IndirectWord >> 8                ; !
>1b66	15					.byte IndirectByte >> 8                ; ?
>1b67	15					.byte IndirectString >> 8              ; $
>1b68	17					.byte UnaryNot >> 8                    ; ~
>1b69	17					.byte UnaryParenthesis >> 8            ; (
>1b6a	18					.byte UnaryHexMarker >> 8              ; &
>1b6b	18					.byte UnaryRefToValue >> 8             ; @
>1b6c	18					.byte UnaryLen >> 8                    ; len
>1b6d	17					.byte UnarySgn1 >> 8                   ; sgn
>1b6e	17					.byte UnaryAbs >> 8                    ; abs
>1b6f	18					.byte UnaryRandom >> 8                 ; random
>1b70	17					.byte UnaryPage >> 8                   ; page
>1b71	17					.byte UnaryTrue >> 8                   ; true
>1b72	17					.byte UnaryFalse >> 8                  ; false
>1b73	17					.byte UnaryMin >> 8                    ; min
>1b74	17					.byte UnaryMax >> 8                    ; max
>1b75	17					.byte UnarySys >> 8                    ; sys
>1b76	14					.byte InstructionUndefined >> 8        ; code
>1b77	19					.byte Unary_Timer >> 8                 ; timer
>1b78	18					.byte Event_Function >> 8              ; event
>1b79	18					.byte Unary_Get >> 8                   ; get
>1b7a	14					.byte InstructionUndefined >> 8        ; joy.x
>1b7b	14					.byte InstructionUndefined >> 8        ; joy.y
>1b7c	14					.byte InstructionUndefined >> 8        ; joy.btn
>1b7d	18					.byte Unary_Inkey >> 8                 ; inkey
>1b7e	18					.byte Unary_Alloc >> 8                 ; alloc
>1b7f	18					.byte UnaryChr >> 8                    ; chr
>1b80	14					.byte NoOp1 >> 8                       ; ,
>1b81	14					.byte NoOp2 >> 8                       ; ;
>1b82	14					.byte NoOp3 >> 8                       ; )
>1b83	14					.byte InstructionUndefined >> 8        ; #
>1b84	14					.byte InstructionUndefined >> 8        ; ++
>1b85	14					.byte InstructionUndefined >> 8        ; --
>1b86	14					.byte InstructionUndefined >> 8        ; ]
>1b87	14					.byte InstructionUndefined >> 8        ; ->
>1b88	12					.byte Command_IF >> 8                  ; if
>1b89	10					.byte Command_FOR >> 8                 ; for
>1b8a	13					.byte Command_Repeat >> 8              ; repeat
>1b8b	14					.byte NoOp6 >> 8                       ; proc
>1b8c	13					.byte Command_While >> 8               ; while
>1b8d	12					.byte Command_ENDIF >> 8               ; endif
>1b8e	11					.byte Command_NEXT >> 8                ; next
>1b8f	13					.byte Command_Until >> 8               ; until
>1b90	1f					.byte Command_EndProc >> 8             ; endproc
>1b91	14					.byte Command_Wend >> 8                ; wend
>1b92	13					.byte Command_Rem >> 8                 ; rem
>1b93	12					.byte Command_LET >> 8                 ; let
>1b94	13					.byte Command_Rem2 >> 8                ; '
>1b95	13					.byte Command_Colon >> 8               ; :
>1b96	13					.byte Command_StartAsm >> 8            ; [
>1b97	14					.byte NoOp7 >> 8                       ; then
>1b98	12					.byte Command_ELSE >> 8                ; else
>1b99	14					.byte NoOp8 >> 8                       ; to
>1b9a	14					.byte NoOp9 >> 8                       ; step
>1b9b	13					.byte Command_Vdu >> 8                 ; vdu
>1b9c	12					.byte Command_Print >> 8               ; print
>1b9d	1e					.byte Command_Call >> 8                ; call
>1b9e	1f					.byte Command_Local >> 8               ; local
>1b9f	11					.byte Command_Goto >> 8                ; goto
>1ba0	11					.byte Command_Gosub >> 8               ; gosub
>1ba1	11					.byte Command_Return >> 8              ; return
>1ba2	10					.byte Command_Assert >> 8              ; assert
>1ba3	13					.byte Command_Stop >> 8                ; stop
>1ba4	13					.byte Command_End >> 8                 ; end
>1ba5	10					.byte Command_Dim >> 8                 ; dim
>1ba6	10					.byte CommandClear >> 8                ; clear
>1ba7	14					.byte InstructionUndefined >> 8        ; load
>1ba8	14					.byte InstructionUndefined >> 8        ; save
>1ba9	14					.byte InstructionUndefined >> 8        ; list
>1baa	12					.byte Command_New >> 8                 ; new
>1bab	13					.byte Command_Run >> 8                 ; run

;******  Return to file: basic.asm


;******  Processing file: common/math/int32binary.asm

.1bac					Int32And:
.1bac	b5 28		lda $28,x			lda 	esInt0,x
.1bae	35 29		and $29,x			and 	esInt0+1,x
.1bb0	95 28		sta $28,x			sta 	esInt0,x
.1bb2	b5 30		lda $30,x			lda 	esInt1,x
.1bb4	35 31		and $31,x			and 	esInt1+1,x
.1bb6	95 30		sta $30,x			sta 	esInt1,x
.1bb8	b5 38		lda $38,x			lda 	esInt2,x
.1bba	35 39		and $39,x			and 	esInt2+1,x
.1bbc	95 38		sta $38,x			sta 	esInt2,x
.1bbe	b5 40		lda $40,x			lda 	esInt3,x
.1bc0	35 41		and $41,x			and 	esInt3+1,x
.1bc2	95 40		sta $40,x			sta 	esInt3,x
.1bc4	60		rts				rts
.1bc5					Int32Or:
.1bc5	b5 28		lda $28,x			lda 	esInt0,x
.1bc7	15 29		ora $29,x			ora 	esInt0+1,x
.1bc9	95 28		sta $28,x			sta 	esInt0,x
.1bcb	b5 30		lda $30,x			lda 	esInt1,x
.1bcd	15 31		ora $31,x			ora 	esInt1+1,x
.1bcf	95 30		sta $30,x			sta 	esInt1,x
.1bd1	b5 38		lda $38,x			lda 	esInt2,x
.1bd3	15 39		ora $39,x			ora 	esInt2+1,x
.1bd5	95 38		sta $38,x			sta 	esInt2,x
.1bd7	b5 40		lda $40,x			lda 	esInt3,x
.1bd9	15 41		ora $41,x			ora 	esInt3+1,x
.1bdb	95 40		sta $40,x			sta 	esInt3,x
.1bdd	60		rts				rts
.1bde					Int32Xor:
.1bde	b5 28		lda $28,x			lda 	esInt0,x
.1be0	55 29		eor $29,x			eor 	esInt0+1,x
.1be2	95 28		sta $28,x			sta 	esInt0,x
.1be4	b5 30		lda $30,x			lda 	esInt1,x
.1be6	55 31		eor $31,x			eor 	esInt1+1,x
.1be8	95 30		sta $30,x			sta 	esInt1,x
.1bea	b5 38		lda $38,x			lda 	esInt2,x
.1bec	55 39		eor $39,x			eor 	esInt2+1,x
.1bee	95 38		sta $38,x			sta 	esInt2,x
.1bf0	b5 40		lda $40,x			lda 	esInt3,x
.1bf2	55 41		eor $41,x			eor 	esInt3+1,x
.1bf4	95 40		sta $40,x			sta 	esInt3,x
.1bf6	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32compare.asm

.1bf7					Int32Equal:
.1bf7	b5 28		lda $28,x			lda 	esInt0,x
.1bf9	d5 29		cmp $29,x			cmp 	esInt0+1,x
.1bfb	d0 2b		bne $1c28			bne 	Int32CFail
.1bfd	b5 30		lda $30,x			lda 	esInt1,x
.1bff	d5 31		cmp $31,x			cmp 	esInt1+1,x
.1c01	d0 25		bne $1c28			bne 	Int32CFail
.1c03	b5 38		lda $38,x			lda 	esInt2,x
.1c05	d5 39		cmp $39,x			cmp 	esInt2+1,x
.1c07	d0 1f		bne $1c28			bne 	Int32CFail
.1c09	b5 40		lda $40,x			lda 	esInt3,x
.1c0b	d5 41		cmp $41,x			cmp 	esInt3+1,x
.1c0d	d0 19		bne $1c28			bne 	Int32CFail
.1c0f					Int32CSucceed:
.1c0f	38		sec				sec
.1c10	60		rts				rts
.1c11					Int32Less:
.1c11	38		sec				sec
.1c12	b5 28		lda $28,x			lda		esInt0,x
.1c14	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1c16	b5 30		lda $30,x			lda		esInt1,x
.1c18	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1c1a	b5 38		lda $38,x			lda		esInt2,x
.1c1c	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1c1e	b5 40		lda $40,x			lda		esInt3,x
.1c20	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1c22	50 02		bvc $1c26			bvc 	_I32LNoOverflow
.1c24	49 80		eor #$80			eor 	#$80
.1c26					_I32LNoOverflow
.1c26	30 e7		bmi $1c0f			bmi 	Int32CSucceed
.1c28					Int32CFail:
.1c28	18		clc				clc
.1c29	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32divide.asm

.1c2a					Int32SDivide:
.1c2a	98		tya				tya  								; save Y, which is the count of negations
.1c2b	48		pha				pha
.1c2c	a0 00		ldy #$00			ldy 	#0 							; zero count
.1c2e	20 46 1c	jsr $1c46			jsr 	_Int32SRemSign 				; unsign TOS
.1c31	e8		inx				inx 								; unsign TOS+1
.1c32	20 46 1c	jsr $1c46			jsr 	_Int32SRemSign
.1c35	ca		dex				dex
.1c36	98		tya				tya 								; save sign count on stack
.1c37	48		pha				pha
.1c38	20 4f 1c	jsr $1c4f			jsr 	Int32UDivide 				; unsigned division
.1c3b	68		pla				pla 								; get sign count back
.1c3c	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.1c3e	f0 03		beq $1c43			beq 	_I32SNoNeg
.1c40	20 d6 1d	jsr $1dd6			jsr 	Int32Negate
.1c43					_I32SNoNeg:
.1c43	68		pla				pla 								; restoe Y and exit
.1c44	a8		tay				tay
.1c45	60		rts				rts
.1c46					_Int32SRemSign:
.1c46	b5 40		lda $40,x			lda 	esInt3,x 					; is it -ve
.1c48	10 04		bpl $1c4e			bpl 	_Int32SRSExit
.1c4a	c8		iny				iny 								; increment the sign count
.1c4b	20 d6 1d	jsr $1dd6			jsr 	Int32Negate 				; negate the value.
.1c4e					_Int32SRSExit:
.1c4e	60		rts				rts
.1c4f					Int32UDivide:
.1c4f	e8		inx				inx 								; clear A
.1c50	e8		inx				inx
.1c51	20 1c 1e	jsr $1e1c			jsr 	Int32False
.1c54	ca		dex				dex
.1c55	ca		dex				dex
.1c56	98		tya				tya 								; save Y on the stack
.1c57	48		pha				pha
.1c58	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.1c5a					_Int32UDLoop:
.1c5a	16 28		asl $28,x			asl 	esInt0,x					; shift QA left. First Q
.1c5c	36 30		rol $30,x			rol 	esInt1,x
.1c5e	36 38		rol $38,x			rol 	esInt2,x
.1c60	36 40		rol $40,x			rol 	esInt3,x
.1c62	36 2a		rol $2a,x			rol 	esInt0+2,x 					; then A.
.1c64	36 32		rol $32,x			rol 	esInt1+2,x
.1c66	36 3a		rol $3a,x			rol 	esInt2+2,x
.1c68	36 42		rol $42,x			rol 	esInt3+2,x
.1c6a	38		sec				sec 								; calculate A-M saving result on the stack
.1c6b	b5 2a		lda $2a,x			lda 	esInt0+2,x
.1c6d	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1c6f	48		pha				pha
.1c70	b5 32		lda $32,x			lda 	esInt1+2,x
.1c72	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1c74	48		pha				pha
.1c75	b5 3a		lda $3a,x			lda 	esInt2+2,x
.1c77	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1c79	48		pha				pha
.1c7a	b5 42		lda $42,x			lda 	esInt3+2,x
.1c7c	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1c7e	90 10		bcc $1c90			bcc		_Int32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.1c80	95 42		sta $42,x			sta 	esInt3+2,x 					; write result back to A
.1c82	68		pla				pla
.1c83	95 3a		sta $3a,x			sta 	esInt2+2,x
.1c85	68		pla				pla
.1c86	95 32		sta $32,x			sta 	esInt1+2,x
.1c88	68		pla				pla
.1c89	95 2a		sta $2a,x			sta 	esInt0+2,x
.1c8b	f6 28		inc $28,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.1c8d	4c 93 1c	jmp $1c93			jmp 	_Int32Next 					; do the next iteration
.1c90					_Int32NoSubtract:
.1c90	68		pla				pla
.1c91	68		pla				pla
.1c92	68		pla				pla
.1c93					_Int32Next:
.1c93	88		dey				dey 								; do this 32 times.
.1c94	d0 c4		bne $1c5a			bne 	_Int32UDLoop
.1c96	68		pla				pla 								; restore Y and exit
.1c97	a8		tay				tay
.1c98	60		rts				rts
.1c99					Int32Modulus:
.1c99	20 4f 1c	jsr $1c4f			jsr 	Int32UDivide 				; do the division.
.1c9c	b5 42		lda $42,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.1c9e	95 40		sta $40,x			sta 	esInt3,x
.1ca0	b5 3a		lda $3a,x			lda 	esInt2+2,x
.1ca2	95 38		sta $38,x			sta 	esInt2,x
.1ca4	b5 32		lda $32,x			lda 	esInt1+2,x
.1ca6	95 30		sta $30,x			sta 	esInt1,x
.1ca8	b5 2a		lda $2a,x			lda 	esInt0+2,x
.1caa	95 28		sta $28,x			sta 	esInt0,x
.1cac	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32fromstr.asm

.1cad					Int32FromString:
.1cad	85 03		sta $03				sta 	tempShort 					; save base
.1caf	98		tya				tya
.1cb0	48		pha				pha
.1cb1	a0 00		ldy #$00			ldy 	#0 							; set index into string being read
.1cb3	b1 04		lda ($04),y			lda 	(temp0),y 					; look at first character
.1cb5	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.1cb7	d0 01		bne $1cba			bne 	_I32FSNotNegative
.1cb9	c8		iny				iny 								; if so consume it.
.1cba					_I32FSNotNegative:
.1cba	a5 03		lda $03				lda 	tempShort 					; get the base back.
.1cbc	c0 00		cpy #$00			cpy 	#0 							; if we read a -ve (e.g. Y != 0)
.1cbe	f0 02		beq $1cc2			beq 	_I32FSNN2
.1cc0	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.1cc2					_I32FSNN2:
.1cc2	48		pha				pha 								; save base + final sign on stack.
.1cc3	20 1c 1e	jsr $1e1c			jsr 	Int32False 					; zero the return value.
.1cc6					I32FSMainLoop:
.1cc6	68		pla				pla 								; get the base back into tempshort
.1cc7	48		pha				pha
.1cc8	29 7f		and #$7f			and 	#$7F
.1cca	85 03		sta $03				sta 	tempShort
.1ccc	b1 04		lda ($04),y			lda 	(temp0),y 					; look at next character.
.1cce	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.1cd0	90 02		bcc $1cd4			bcc 	_I32FSNotLC
.1cd2	e9 20		sbc #$20			sbc 	#32
.1cd4					_I32FSNotLC:
.1cd4	38		sec				sec 								; subtract 48 (ASCII "0")
.1cd5	e9 30		sbc #$30			sbc 	#"0"
.1cd7	90 26		bcc $1cff			bcc 	_I32FSDone 					; nothing more to do.
.1cd9	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.1cdb	90 06		bcc $1ce3			bcc 	_I32FSValidate
.1cdd	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.1cdf	90 1e		bcc $1cff			bcc 	_I32FSDone
.1ce1	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.1ce3					_I32FSValidate:
.1ce3	c5 03		cmp $03				cmp 	tempShort 					; compare against the base.
.1ce5	b0 18		bcs $1cff			bcs 	_I32FSDone 					; sorry, too large for this base.
.1ce7	48		pha				pha 								; save the new digit value.
.1ce8	e8		inx				inx 								; put base into next slot.
.1ce9	a5 03		lda $03				lda 	tempShort
.1ceb	20 2b 1e	jsr $1e2b			jsr 	Int32Set8Bit
.1cee	ca		dex				dex
.1cef	20 41 1d	jsr $1d41			jsr 	Int32Multiply 				; multiply current by the base
.1cf2	e8		inx				inx
.1cf3	68		pla				pla  								; put additive into next slot
.1cf4	20 2b 1e	jsr $1e2b			jsr 	Int32Set8Bit
.1cf7	ca		dex				dex
.1cf8	20 0d 1d	jsr $1d0d			jsr 	Int32Add 					; and add it
.1cfb	c8		iny				iny 								; look at next character
.1cfc	4c c6 1c	jmp $1cc6			jmp 	I32FSMainLoop 				; and go round again.
.1cff					_I32FSDone:
.1cff	68		pla				pla 								; get base/final sign back
.1d00	10 04		bpl $1d06			bpl 	_I32FSNN3
.1d02	88		dey				dey 								; one fewer character to allow for the - prefix.
.1d03	20 d6 1d	jsr $1dd6			jsr 	Int32Negate 				; negate the result.
.1d06					_I32FSNN3:
.1d06	84 03		sty $03				sty 	tempShort 					; save the count of characters read
.1d08	68		pla				pla
.1d09	a8		tay				tay
.1d0a	a5 03		lda $03				lda 	tempShort 					; get the count of characters read into A and exit
.1d0c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32math.asm

.1d0d					Int32Add:
.1d0d	18		clc				clc
.1d0e	b5 28		lda $28,x			lda 	esInt0,x
.1d10	75 29		adc $29,x			adc 	esInt0+1,x
.1d12	95 28		sta $28,x			sta 	esInt0,x
.1d14	b5 30		lda $30,x			lda 	esInt1,x
.1d16	75 31		adc $31,x			adc 	esInt1+1,x
.1d18	95 30		sta $30,x			sta 	esInt1,x
.1d1a	b5 38		lda $38,x			lda 	esInt2,x
.1d1c	75 39		adc $39,x			adc 	esInt2+1,x
.1d1e	95 38		sta $38,x			sta 	esInt2,x
.1d20	b5 40		lda $40,x			lda 	esInt3,x
.1d22	75 41		adc $41,x			adc 	esInt3+1,x
.1d24	95 40		sta $40,x			sta 	esInt3,x
.1d26	60		rts				rts
.1d27					Int32Sub:
.1d27	38		sec				sec
.1d28	b5 28		lda $28,x			lda 	esInt0,x
.1d2a	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1d2c	95 28		sta $28,x			sta 	esInt0,x
.1d2e	b5 30		lda $30,x			lda 	esInt1,x
.1d30	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1d32	95 30		sta $30,x			sta 	esInt1,x
.1d34	b5 38		lda $38,x			lda 	esInt2,x
.1d36	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1d38	95 38		sta $38,x			sta 	esInt2,x
.1d3a	b5 40		lda $40,x			lda 	esInt3,x
.1d3c	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1d3e	95 40		sta $40,x			sta 	esInt3,x
.1d40	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32multiply.asm

.1d41					Int32Multiply:
.1d41	e8		inx				inx 								; copy 2nd -> 3rd
.1d42	20 67 1d	jsr $1d67			jsr 	Int32CopyUp
.1d45	ca		dex				dex
.1d46	20 67 1d	jsr $1d67			jsr 	Int32CopyUp 				; copy 1st -> 2nd
.1d49	20 1c 1e	jsr $1e1c			jsr 	Int32False 					; zero 1st.
.1d4c					_I32Loop:
.1d4c	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.1d4e	29 01		and #$01			and 	#1
.1d50	f0 03		beq $1d55			beq 	_I32NoAdd 					; if set
.1d52	20 0d 1d	jsr $1d0d			jsr 	Int32Add 					; add 2nd to 1st.
.1d55					_I32NoAdd:
.1d55	e8		inx				inx 								; shift 2nd left
.1d56	20 31 1e	jsr $1e31			jsr 	Int32ShiftLeft
.1d59	e8		inx				inx  								; shift 3rd right
.1d5a	20 3a 1e	jsr $1e3a			jsr 	Int32ShiftRight
.1d5d	20 43 1e	jsr $1e43			jsr 	Int32Zero 					; check if zero.
.1d60	08		php				php 								; save status bits
.1d61	ca		dex				dex 	 							; point back to 1st
.1d62	ca		dex				dex
.1d63	28		plp				plp 								; get status bits
.1d64	d0 e6		bne $1d4c			bne 	_I32Loop 					; if non-zero keep going.
.1d66	60		rts				rts
.1d67					Int32CopyUp:
.1d67	b5 28		lda $28,x			lda 	esInt0,x
.1d69	95 29		sta $29,x			sta 	esInt0+1,x
.1d6b	b5 30		lda $30,x			lda 	esInt1,x
.1d6d	95 31		sta $31,x			sta 	esInt1+1,x
.1d6f	b5 38		lda $38,x			lda 	esInt2,x
.1d71	95 39		sta $39,x			sta 	esInt2+1,x
.1d73	b5 40		lda $40,x			lda 	esInt3,x
.1d75	95 41		sta $41,x			sta 	esInt3+1,x
.1d77	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32tostr.asm

.1d78					Int32ToString:
.1d78	48		pha				pha 								; save base
.1d79	85 03		sta $03				sta 	tempShort 					; save target base.
.1d7b	a9 00		lda #$00			lda 	#0
.1d7d	8d a4 08	sta $08a4			sta 	IToSCount 					; clear character count.
.1d80	98		tya				tya
.1d81	48		pha				pha
.1d82	a5 03		lda $03				lda 	tempShort 					; check if we are signed conversion
.1d84	10 10		bpl $1d96			bpl 	_I32TSUnsigned
.1d86	48		pha				pha 								; save base on stack.
.1d87	b5 40		lda $40,x			lda 	esInt3,x 					; is it actually negative
.1d89	10 08		bpl $1d93			bpl 	_I32TSNoFlip
.1d8b	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.1d8d	20 c2 1d	jsr $1dc2			jsr 	I32WriteCharacter
.1d90	20 d6 1d	jsr $1dd6			jsr 	Int32Negate 				; negate the value.
.1d93					_I32TSNoFlip:
.1d93	68		pla				pla 								; get the base back
.1d94	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.1d96					_I32TSUnsigned:
.1d96	20 9d 1d	jsr $1d9d			jsr 	I32DivideWrite 				; recursive code to output string.
.1d99	68		pla				pla
.1d9a	a8		tay				tay
.1d9b	68		pla				pla
.1d9c	60		rts				rts
.1d9d					I32DivideWrite:
.1d9d	48		pha				pha 								; save the divisor/base
.1d9e	e8		inx				inx 								; write in the dividing position.
.1d9f	20 2b 1e	jsr $1e2b			jsr 	Int32Set8Bit
.1da2	ca		dex				dex
.1da3	20 4f 1c	jsr $1c4f			jsr 	Int32UDivide 				; divide number by base.
.1da6	68		pla				pla 								; get the base into Y
.1da7	a8		tay				tay
.1da8	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.1daa	48		pha				pha
.1dab	20 43 1e	jsr $1e43			jsr 	Int32Zero 					; is the result zero ?
.1dae	f0 04		beq $1db4			beq 	_I32NoRecurse 				; if so, don't recurse.
.1db0	98		tya				tya 								; put base into A
.1db1	20 9d 1d	jsr $1d9d			jsr 	I32DivideWrite 				; and jsr the dividor recursively.
.1db4					_I32NoRecurse:
.1db4	68		pla				pla 								; get the remainder back
.1db5	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.1db7	90 02		bcc $1dbb			bcc 	_I32NotHex
.1db9	69 06		adc #$06			adc 	#7-1
.1dbb					_I32NotHex:
.1dbb	18		clc				clc 								; make it ASCII
.1dbc	69 30		adc #$30			adc 	#48
.1dbe	20 c2 1d	jsr $1dc2			jsr 	I32WriteCharacter 			; write the character out
.1dc1	60		rts				rts 								; and exit.
.1dc2					I32WriteCharacter:
.1dc2	ac a4 08	ldy $08a4			ldy 	IToSCount 					; get position
.1dc5	91 04		sta ($04),y			sta 	(temp0),y 					; write out with trailing 0
.1dc7	c8		iny				iny
.1dc8	a9 00		lda #$00			lda 	#0
.1dca	91 04		sta ($04),y			sta 	(temp0),y
.1dcc	ee a4 08	inc $08a4			inc 	IToSCount 					; bump count
.1dcf	60		rts				rts
.1dd0	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32unary.asm

.1dd1					Int32Absolute:
.1dd1	b5 40		lda $40,x			lda 	esInt3,x 					; use negate code if -ve.
.1dd3	30 01		bmi $1dd6			bmi 	Int32Negate
.1dd5	60		rts				rts
.1dd6					Int32Negate:
.1dd6	38		sec				sec
.1dd7	a9 00		lda #$00			lda 	#0
.1dd9	f5 28		sbc $28,x			sbc 	esInt0,x
.1ddb	95 28		sta $28,x			sta 	esInt0,x
.1ddd	a9 00		lda #$00			lda 	#0
.1ddf	f5 30		sbc $30,x			sbc 	esInt1,x
.1de1	95 30		sta $30,x			sta 	esInt1,x
.1de3	a9 00		lda #$00			lda 	#0
.1de5	f5 38		sbc $38,x			sbc 	esInt2,x
.1de7	95 38		sta $38,x			sta 	esInt2,x
.1de9	a9 00		lda #$00			lda 	#0
.1deb	f5 40		sbc $40,x			sbc 	esInt3,x
.1ded	95 40		sta $40,x			sta 	esInt3,x
.1def	60		rts				rts
.1df0					Int32Not:
.1df0	b5 28		lda $28,x			lda 	esInt0,x
.1df2	49 ff		eor #$ff			eor 	#$FF
.1df4	95 28		sta $28,x			sta 	esInt0,x
.1df6	b5 30		lda $30,x			lda 	esInt1,x
.1df8	49 ff		eor #$ff			eor 	#$FF
.1dfa	95 30		sta $30,x			sta 	esInt1,x
.1dfc	b5 38		lda $38,x			lda 	esInt2,x
.1dfe	49 ff		eor #$ff			eor 	#$FF
.1e00	95 38		sta $38,x			sta 	esInt2,x
.1e02	b5 40		lda $40,x			lda 	esInt3,x
.1e04	49 ff		eor #$ff			eor 	#$FF
.1e06	95 40		sta $40,x			sta 	esInt3,x
.1e08	60		rts				rts
.1e09					Int32Sign:
.1e09	b5 40		lda $40,x			lda 	esInt3,x					; look at MSB
.1e0b	30 0b		bmi $1e18			bmi 	Int32True 					; if set return -1 (true)
.1e0d	20 43 1e	jsr $1e43			jsr 	Int32Zero 					; is it zero ?
.1e10	f0 0a		beq $1e1c			beq 	Int32False 					; if zero return 0 (false)
.1e12	20 1c 1e	jsr $1e1c			jsr 	Int32False 					; > 0 return 1
.1e15	f6 28		inc $28,x			inc 	esInt0,x
.1e17	60		rts				rts
.1e18					Int32True:
.1e18	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.1e1a	d0 02		bne $1e1e			bne 	Int32WriteAll
.1e1c					Int32False:
.1e1c	a9 00		lda #$00			lda 	#0
.1e1e					Int32WriteAll:
.1e1e	95 28		sta $28,x			sta 	esInt0,x
.1e20					Int32Write123:
.1e20	95 30		sta $30,x			sta 	esInt1,x
.1e22	95 38		sta $38,x			sta 	esInt2,x
.1e24	95 40		sta $40,x			sta 	esInt3,x
.1e26	a9 00		lda #$00			lda 	#$00						; and make it an integer
.1e28	95 20		sta $20,x			sta 	esType,x
.1e2a	60		rts				rts
.1e2b					Int32Set8Bit:
.1e2b	95 28		sta $28,x			sta 	esInt0,x
.1e2d	a9 00		lda #$00			lda 	#0
.1e2f	f0 ef		beq $1e20			beq		Int32Write123
.1e31					Int32ShiftLeft:
.1e31	16 28		asl $28,x			asl 	esInt0,x
.1e33	36 30		rol $30,x			rol	 	esInt1,x
.1e35	36 38		rol $38,x			rol	 	esInt2,x
.1e37	36 40		rol $40,x			rol	 	esInt3,x
.1e39	60		rts				rts
.1e3a					Int32ShiftRight:
.1e3a	56 40		lsr $40,x			lsr 	esInt3,x
.1e3c	76 38		ror $38,x			ror 	esInt2,x
.1e3e	76 30		ror $30,x			ror 	esInt1,x
.1e40	76 28		ror $28,x			ror 	esInt0,x
.1e42	60		rts				rts
.1e43					Int32Zero:
.1e43	b5 28		lda $28,x			lda 	esInt0,x
.1e45	15 30		ora $30,x			ora 	esInt1,x
.1e47	15 38		ora $38,x			ora 	esInt2,x
.1e49	15 40		ora $40,x			ora 	esInt3,x
.1e4b	60		rts				rts
.1e4c					Int32Random:
.1e4c	98		tya				tya
.1e4d	48		pha				pha
.1e4e	a0 07		ldy #$07			ldy 	#7
.1e50	ad 88 08	lda $0888			lda 	Seed32+0
.1e53	d0 03		bne $1e58			bne 	_Random1
.1e55	a8		tay				tay
.1e56	a9 aa		lda #$aa			lda		#$AA
.1e58					_Random1:
.1e58	0a		asl a				asl 	a
.1e59	2e 89 08	rol $0889			rol 	Seed32+1
.1e5c	2e 8a 08	rol $088a			rol 	Seed32+2
.1e5f	2e 8b 08	rol $088b			rol 	Seed32+3
.1e62	90 02		bcc $1e66			bcc 	_Random2
.1e64	49 c5		eor #$c5			eor 	#$C5
.1e66					_Random2:
.1e66	88		dey				dey
.1e67	d0 ef		bne $1e58			bne 	_Random1
.1e69	8d 88 08	sta $0888			sta 	Seed32+0
.1e6c	95 28		sta $28,x			sta 	esInt0,x
.1e6e	ad 89 08	lda $0889			lda 	Seed32+1
.1e71	95 30		sta $30,x			sta 	esInt1,x
.1e73	ad 8a 08	lda $088a			lda 	Seed32+2
.1e76	95 38		sta $38,x			sta 	esInt2,x
.1e78	ad 8b 08	lda $088b			lda 	Seed32+3
.1e7b	95 40		sta $40,x			sta 	esInt3,x
.1e7d	68		pla				pla
.1e7e	a8		tay				tay
.1e7f	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/procedures/call.asm

.1e80					Command_Call:
.1e80	98		tya				tya 								; Y offset - 4
.1e81	38		sec				sec
.1e82	e9 04		sbc #$04			sbc 	#4
.1e84	18		clc				clc
.1e85	65 00		adc $00				adc 	codePtr 					; add to CodePtr -> temp1
.1e87	85 06		sta $06				sta 	temp1
.1e89	a5 01		lda $01				lda 	codePtr+1
.1e8b	69 00		adc #$00			adc 	#0
.1e8d	85 07		sta $07				sta 	temp1+1
.1e8f	a2 00		ldx #$00			ldx 	#0
.1e91					_CCCalcHash:
.1e91	8a		txa				txa 								; which is simple additive
.1e92	18		clc				clc
.1e93	71 00		adc ($00),y			adc 	(codePtr),y
.1e95	aa		tax				tax
.1e96	b1 00		lda ($00),y			lda 	(codePtr),y 				; until added end marker.
.1e98	c8		iny				iny
.1e99	c9 30		cmp #$30			cmp 	#$30
.1e9b	b0 f4		bcs $1e91			bcs 	_CCCalCHash
.1e9d	8a		txa				txa
.1e9e	48		pha				pha
.1e9f	20 2b 14	jsr $142b			jsr 	CheckLeftParen 				; check for opening parameter bracket.
.1ea2	a2 00		ldx #$00			ldx 	#0 							; actually start at 1 with pre-increment.
.1ea4					_CCEvaluateParameters:
.1ea4	b1 00		lda ($00),y			lda 	(codePtr),y 				; hit )
.1ea6	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN
.1ea8	f0 13		beq $1ebd			beq 	_CCHaveParams
.1eaa					_CCNextParam:
.1eaa	e8		inx				inx 								; first parameter goes in offset #1.
.1eab	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX 			; evaluate and derefernce.
.1eae	20 f8 16	jsr $16f8			jsr 	DeRefTop
.1eb1	b1 00		lda ($00),y			lda 	(codePtr),y 				; check if followed by a comma
.1eb3	c8		iny				iny
.1eb4	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; if so go back
.1eb6	f0 f2		beq $1eaa			beq 	_CCNextParam
.1eb8	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN 				; if not ) error
.1eba	d0 45		bne $1f01			bne 	_CCSyntax
.1ebc	88		dey				dey 								; point (codePtr),y to the )
.1ebd					_CCHaveParams:
.1ebd	8e ab 08	stx $08ab			stx 	ParamCount 					; save number of parameters evaluated.
.1ec0	68		pla				pla 								; put the hash into temp2
.1ec1	85 08		sta $08				sta 	temp2
.1ec3	98		tya				tya
.1ec4	48		pha				pha
.1ec5	ad a9 08	lda $08a9			lda 	ProcTable 					; copy ProcTable to temp0
.1ec8	85 04		sta $04				sta 	temp0
.1eca	ad aa 08	lda $08aa			lda 	ProcTable+1
.1ecd	85 05		sta $05				sta 	temp0+1
.1ecf					_CCCheckLoop:
.1ecf	a0 01		ldy #$01			ldy 	#1 							; check the MSB of the line entry, if zero, then not found.
.1ed1	b1 04		lda ($04),y			lda 	(temp0),y
.1ed3	f0 2f		beq $1f04			beq 	_CCNoProc
.1ed5	85 0b		sta $0b				sta 	temp3+1 					; save in temp3+1
.1ed7	c8		iny				iny 								; get the hash
.1ed8	b1 04		lda ($04),y			lda 	(temp0),y
.1eda	c5 08		cmp $08				cmp 	temp2 						; does it match ?
.1edc	d0 15		bne $1ef3			bne 	_CCNext
.1ede	a0 00		ldy #$00			ldy 	#0 							; get LSB into temp3
.1ee0	b1 04		lda ($04),y			lda 	(temp0),y
.1ee2	85 0a		sta $0a				sta 	temp3
.1ee4	a0 03		ldy #$03			ldy 	#3 							; start offset 4 pre-increment.
.1ee6					_CCCompare:
.1ee6	c8		iny				iny 								; check match
.1ee7	b1 0a		lda ($0a),y			lda 	(temp3),y
.1ee9	d1 06		cmp ($06),y			cmp 	(temp1),y
.1eeb	d0 06		bne $1ef3			bne 	_CCNext
.1eed	c9 30		cmp #$30			cmp 	#$30 						; stop if reached actual match.
.1eef	b0 f5		bcs $1ee6			bcs 	_CCCompare
.1ef1	90 17		bcc $1f0a			bcc 	_CCFound 					; yes, a match.
.1ef3					_CCNext:
.1ef3	18		clc				clc 								; go four on, table size.
.1ef4	a5 04		lda $04				lda 	temp0
.1ef6	69 04		adc #$04			adc 	#4
.1ef8	85 04		sta $04				sta 	temp0
.1efa	90 d3		bcc $1ecf			bcc 	_CCCheckLoop
.1efc	e6 05		inc $05				inc 	temp0+1
.1efe	4c cf 1e	jmp $1ecf			jmp 	_CCCheckLoop
.1f01					_CCSyntax:
.1f01	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax
.1f04					_CCNoProc:
.1f04	4c 57 19	jmp $1957			jmp 	EHandlerBadProc
.1f07					_CCParamErr:
.1f07	4c 55 1a	jmp $1a55			jmp 	EHandlerParameters
.1f0a					_CCFound:
.1f0a	68		pla				pla
.1f0b	a8		tay				tay
.1f0c	c8		iny				iny 								; now point to the token after it
.1f0d	a9 54		lda #$54			lda 	#SMProcedure				; open a procedure frame
.1f0f	20 87 20	jsr $2087			jsr 	StackOpen
.1f12	20 db 20	jsr $20db			jsr 	StackSavePosition 			; save return address on the stack.
.1f15	a0 03		ldy #$03			ldy 	#3 							; get the offset to the start of the parameter list
.1f17	b1 04		lda ($04),y			lda 	(temp0),y
.1f19	a8		tay				tay
.1f1a	a5 0a		lda $0a				lda 	temp3 						; copy start of line into code Ptr
.1f1c	85 00		sta $00				sta 	codePtr
.1f1e	a5 0b		lda $0b				lda		temp3+1
.1f20	85 01		sta $01				sta 	codePtr+1
.1f22	a2 00		ldx #$00			ldx 	#0
.1f24					_CCSaveParams:
.1f24	b1 00		lda ($00),y			lda 	(codePtr),y 				; found the right bracket
.1f26	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN
.1f28	f0 29		beq $1f53			beq 	_CCExit
.1f2a					_CCParamLoop:
.1f2a	e8		inx				inx 								; point to the parameter we will save
.1f2b	20 87 1f	jsr $1f87			jsr 	GetLocalTerm 				; get and localise a parameter. Address to copy to is in temp0.
.1f2e	98		tya				tya
.1f2f	48		pha				pha
.1f30	a0 00		ldy #$00			ldy 	#0
.1f32	b5 28		lda $28,x			lda 	esInt0,x
.1f34	91 04		sta ($04),y			sta 	(temp0),y
.1f36	c8		iny				iny
.1f37	b5 30		lda $30,x			lda 	esInt1,x
.1f39	91 04		sta ($04),y			sta 	(temp0),y
.1f3b	c8		iny				iny
.1f3c	b5 38		lda $38,x			lda 	esInt2,x
.1f3e	91 04		sta ($04),y			sta 	(temp0),y
.1f40	c8		iny				iny
.1f41	b5 40		lda $40,x			lda 	esInt3,x
.1f43	91 04		sta ($04),y			sta 	(temp0),y
.1f45	68		pla				pla
.1f46	a8		tay				tay
.1f47	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and skip next
.1f49	c8		iny				iny
.1f4a	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; if , go round again.
.1f4c	f0 dc		beq $1f2a			beq 	_CCParamLoop
.1f4e	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN 				; should be )
.1f50	d0 af		bne $1f01			bne 	_CCSyntax
.1f52	88		dey				dey 								; Y now points to )
.1f53					_CCExit:
.1f53	ec ab 08	cpx $08ab			cpx 	ParamCount 					; parameters match
.1f56	d0 af		bne $1f07			bne 	_CCParamErr
.1f58	c8		iny				iny 								; skip the right bracket
.1f59	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/procedures/endproc.asm

.1f5a					Command_EndProc:
.1f5a	20 ee 20	jsr $20ee			jsr 	StackPopLocals 				; restore local variables.
.1f5d	a9 54		lda #$54			lda 	#SMProcedure				; check TOS is PROC
.1f5f	20 ac 20	jsr $20ac			jsr 	StackCheck
.1f62	d0 07		bne $1f6b			bne 	_EPError
.1f64	20 cb 20	jsr $20cb			jsr 	StackLoadPosition 			; restore position and drop
.1f67	20 b7 20	jsr $20b7			jsr 	StackClose
.1f6a	60		rts				rts
.1f6b					_EPError:
.1f6b	4c ed 19	jmp $19ed			jmp 	EHandlerNoProc

;******  Return to file: basic.asm


;******  Processing file: common/procedures/local.asm

.1f6e					Command_Local:
.1f6e	20 87 1f	jsr $1f87			jsr 	GetLocalTerm 				; get a local variable.
.1f71	98		tya				tya
.1f72	48		pha				pha
.1f73	a0 00		ldy #$00			ldy 	#0 							; erase the variable.
.1f75	98		tya				tya
.1f76					_CLClear:
.1f76	91 04		sta ($04),y			sta 	(temp0),y
.1f78	c8		iny				iny
.1f79	c0 04		cpy #$04			cpy 	#4
.1f7b	d0 f9		bne $1f76			bne 	_CLClear
.1f7d	68		pla				pla
.1f7e	a8		tay				tay
.1f7f	b1 00		lda ($00),y			lda 	(codePtr),y					; check comma
.1f81	c8		iny				iny
.1f82	c9 ac		cmp #$ac			cmp 	#KWD_COMMA
.1f84	f0 e8		beq $1f6e			beq 	Command_Local
.1f86	60		rts				rts
.1f87					GetLocalTerm:
.1f87	8a		txa				txa
.1f88	48		pha				pha
.1f89	a2 00		ldx #$00			ldx 	#0 							; start on stack
.1f8b	a9 07		lda #$07			lda 	#7  						; get a term
.1f8d	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX 			; this is the variable/parameter to localise.
.1f90	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.1f92	10 26		bpl $1fba			bpl 	_GLTSyntax 					; if not, syntax error.
.1f94	98		tya				tya
.1f95	48		pha				pha
.1f96	a9 67		lda #$67			lda 	#SMLocal 					; create stack frame.
.1f98	20 87 20	jsr $2087			jsr 	StackOpen
.1f9b	a0 05		ldy #$05			ldy 	#5
.1f9d	b5 28		lda $28,x			lda 	esInt0,x 					; copy address to temp0 and to stack+5,stack+6
.1f9f	85 04		sta $04				sta 	temp0
.1fa1	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1fa3	b5 30		lda $30,x			lda 	esInt1,x
.1fa5	85 05		sta $05				sta 	temp0+1
.1fa7	c8		iny				iny
.1fa8	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1faa	a0 00		ldy #$00			ldy 	#0 							; now copy data into stack1-4
.1fac					_GLTCopy:
.1fac	b1 04		lda ($04),y			lda 	(temp0),y
.1fae	c8		iny				iny
.1faf	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1fb1	c0 04		cpy #$04			cpy 	#4
.1fb3	d0 f7		bne $1fac			bne 	_GLTCopy
.1fb5	68		pla				pla
.1fb6	a8		tay				tay
.1fb7	68		pla				pla
.1fb8	aa		tax				tax
.1fb9	60		rts				rts
.1fba					_GLTSyntax:
.1fba	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/procedures/scanproc.asm

.1fbd					BuildProcedureList:
.1fbd	a5 10		lda $10				lda 	LowMemory 					; starts at low memory
.1fbf	8d a9 08	sta $08a9			sta 	ProcTable
.1fc2	a5 11		lda $11				lda 	LowMemory+1
.1fc4	8d aa 08	sta $08aa			sta 	ProcTable+1
.1fc7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.1fc9	85 04		sta $04				sta 	temp0
.1fcb	a9 27		lda #$27			lda 	#(BasicProgram) >> 8
.1fcd	85 05		sta $05				sta 	1+(temp0)
.1fcf					_BPLLoop:
.1fcf	a0 00		ldy #$00			ldy 	#0
.1fd1	b1 04		lda ($04),y			lda 	(temp0),y 					; reached then end ?
.1fd3	f0 49		beq $201e			beq 	_BPLExit
.1fd5	a0 03		ldy #$03			ldy 	#3 							; look to see if it is PROC
.1fd7	b1 04		lda ($04),y			lda 	(temp0),y
.1fd9	c9 b7		cmp #$b7			cmp 	#KWD_PROC
.1fdb	f0 10		beq $1fed			beq 	_BPLFoundProc
.1fdd					_BPLNext:
.1fdd	a0 00		ldy #$00			ldy 	#0 							; next line.
.1fdf	18		clc				clc
.1fe0	b1 04		lda ($04),y			lda 	(temp0),y
.1fe2	65 04		adc $04				adc 	temp0
.1fe4	85 04		sta $04				sta 	temp0
.1fe6	90 e7		bcc $1fcf			bcc 	_BPLLoop
.1fe8	e6 05		inc $05				inc 	temp0+1
.1fea	4c cf 1f	jmp $1fcf			jmp 	_BPLLoop
.1fed					_BPLFoundProc:
.1fed	a9 00		lda #$00			lda 	#0 							; for calculating the hash.
.1fef	85 06		sta $06				sta 	temp1
.1ff1	a0 04		ldy #$04			ldy 	#4
.1ff3					_BPLCalcHash:
.1ff3	18		clc				clc 								; add the tokens making the identifier to make an 8 bit hash.
.1ff4	a5 06		lda $06				lda 	temp1
.1ff6	71 04		adc ($04),y			adc 	(temp0),y
.1ff8	85 06		sta $06				sta 	temp1
.1ffa	b1 04		lda ($04),y			lda 	(temp0),y
.1ffc	c8		iny				iny
.1ffd	c9 30		cmp #$30			cmp		#$30
.1fff	b0 f2		bcs $1ff3			bcs 	_BPLCalcHash
.2001	b1 04		lda ($04),y			lda 	(temp0),y 					; check for (
.2003	c9 95		cmp #$95			cmp 	#KWD_LPAREN
.2005	d0 2f		bne $2036			bne 	BPSyntax
.2007	c8		iny				iny 								; first char after (
.2008					_BPLAddRecord:
.2008	a5 04		lda $04				lda 	temp0 						; write address of line (+0,+1)
.200a	20 27 20	jsr $2027			jsr 	WriteBPL
.200d	a5 05		lda $05				lda 	temp0+1
.200f	20 27 20	jsr $2027			jsr 	WriteBPL
.2012	a5 06		lda $06				lda 	temp1 						; write out sum hash (+2)
.2014	20 27 20	jsr $2027			jsr 	WriteBPL
.2017	98		tya				tya 								; offset to first character of parameter (+3)
.2018	20 27 20	jsr $2027			jsr 	WriteBPL
.201b	4c dd 1f	jmp $1fdd			jmp 	_BPLNext
.201e					_BPLExit:
.201e	a9 00		lda #$00			lda 	#0 							; write two zeros indicating end.
.2020	20 27 20	jsr $2027			jsr 	WriteBPL
.2023	20 27 20	jsr $2027			jsr 	WriteBPL
.2026	60		rts				rts
.2027					WriteBPL:
.2027	84 03		sty $03				sty 	tempShort
.2029	a0 00		ldy #$00			ldy 	#0
.202b	91 10		sta ($10),y			sta 	(LowMemory),y
.202d	e6 10		inc $10				inc 	LowMemory
.202f	d0 02		bne $2033			bne 	_WBPLExit
.2031	e6 11		inc $11				inc 	LowMemory+1
.2033					_WBPLExit:
.2033	a4 03		ldy $03				ldy 	tempShort
.2035	60		rts				rts
.2036					BPSyntax:
.2036	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/utility/scanner.asm

.2039					ScanForward:
.2039	85 0a		sta $0a				sta 	temp3 						; save tokens to search in temp3/temp3+1
.203b	86 0b		stx $0b				stx 	temp3+1
.203d	a9 00		lda #$00			lda 	#0 							; temp2 counts structure levels.
.203f	85 08		sta $08				sta 	temp2
.2041	b1 00		lda ($00),y	_SFLoop:lda 	(codePtr),y 				; look at the high token.
.2043	c9 80		cmp #$80			cmp 	#$80
.2045	f0 13		beq $205a			beq 	_SFNextLine 				; if $80 go to next line.
.2047	b0 17		bcs $2060			bcs  	_SFFoundCommand				; if -ve its a token
.2049	c9 60		cmp #$60			cmp 	#$60 						; if $60 it's a string.
.204b	f0 04		beq $2051			beq 	_SFSkipString
.204d					_SFNextToken:
.204d	c8		iny				iny
.204e	4c 41 20	jmp $2041			jmp 	_SFLoop
.2051					_SFSkipString:
.2051	98		tya				tya
.2052	c8		iny				iny
.2053	18		clc				clc
.2054	71 00		adc ($00),y			adc 	(codePtr),y
.2056	a8		tay				tay
.2057	4c 41 20	jmp $2041			jmp 	_SFLoop
.205a					_SFNextLine:
.205a	20 c2 13	jsr $13c2			jsr 	CommandNextLine
.205d	4c 41 20	jmp $2041			jmp 	_SFLoop
.2060					_SFFoundCommand:
.2060	a5 08		lda $08				lda 	temp2 						; structure level is non-zero then don't check
.2062	d0 0a		bne $206e			bne 	_SFNoCheck
.2064	b1 00		lda ($00),y			lda 	(codePtr),y  				; get the token.
.2066	c5 0a		cmp $0a				cmp 	temp3 						; if it matches either, then we win.
.2068	f0 18		beq $2082			beq 	_SFFoundEnd
.206a	c5 0b		cmp $0b				cmp 	temp3+1
.206c	f0 14		beq $2082			beq 	_SFFoundEnd
.206e					_SFNoCheck:
.206e	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the token
.2070	aa		tax				tax 								; get its type
.2071	bd 24 1a	lda $1a24,x			lda 	KeywordTypes-$80,x
.2074	10 d7		bpl $204d			bpl		_SFNextToken 				; not a command
.2076	38		sec				sec
.2077	e9 81		sbc #$81			sbc 	#$81 						; this is now -1 if close, 0 normal, 1 open.
.2079	18		clc				clc
.207a	65 08		adc $08				adc 	temp2 						; add to structure level
.207c	85 08		sta $08				sta 	temp2
.207e	30 04		bmi $2084			bmi		_SFBalance
.2080	10 cb		bpl $204d			bpl 	_SFNextToken
.2082					_SFFoundEnd:
.2082	c8		iny				iny									; skip over the token
.2083	60		rts				rts
.2084					_SFBalance:
.2084	4c 7c 19	jmp $197c			jmp 	EHandlerClosure

;******  Return to file: basic.asm


;******  Processing file: common/utility/stack.asm

.2087					StackOpen:
.2087	85 03		sta $03				sta 	tempShort 					; save it
.2089	29 0f		and #$0f			and 	#StackSizeMask 				; bytes to subtract.
.208b	49 ff		eor #$ff			eor 	#$FF 						; add to stack pointer, 2's complement
.208d	38		sec				sec
.208e	65 0e		adc $0e				adc 	StackPtr
.2090	85 0e		sta $0e				sta 	StackPtr
.2092	a5 0f		lda $0f				lda 	StackPtr+1
.2094	69 ff		adc #$ff			adc 	#$FF
.2096	85 0f		sta $0f				sta 	StackPtr+1
.2098	98		tya				tya
.2099	48		pha				pha
.209a	a0 00		ldy #$00			ldy 	#0 							; write marker at offset 0
.209c	a5 03		lda $03				lda 	tempShort
.209e	91 0e		sta ($0e),y			sta 	(StackPtr),y
.20a0	68		pla				pla
.20a1	a8		tay				tay
.20a2	a5 11		lda $11				lda 	LowMemory+1 				; check memory available
.20a4	c5 0f		cmp $0f				cmp 	StackPtr+1
.20a6	b0 01		bcs $20a9			bcs		_SOMemory
.20a8	60		rts				rts
.20a9					_SOMemory:
.20a9	4c b1 19	jmp $19b1			jmp 	EHandlerMemory
.20ac					StackCheck:
.20ac	84 03		sty $03				sty 	tempShort
.20ae	a0 00		ldy #$00			ldy 	#0 							; eor with marker
.20b0	51 0e		eor ($0e),y			eor 	(StackPtr),y
.20b2	a4 03		ldy $03				ldy 	tempShort
.20b4	c9 00		cmp #$00			cmp 	#0 							; set Z flag
.20b6	60		rts				rts
.20b7					StackClose:
.20b7	98		tya				tya
.20b8	48		pha				pha
.20b9	a0 00		ldy #$00			ldy 	#0
.20bb	b1 0e		lda ($0e),y			lda 	(StackPtr),y 				; get type back
.20bd	29 0f		and #$0f			and 	#StackSizeMask 				; bytes to add
.20bf	18		clc				clc
.20c0	65 0e		adc $0e				adc 	StackPtr
.20c2	85 0e		sta $0e				sta 	StackPtr
.20c4	90 02		bcc $20c8			bcc 	_SCSkip
.20c6	e6 0f		inc $0f				inc 	StackPtr+1
.20c8					_SCSkip:
.20c8	68		pla				pla
.20c9	a8		tay				tay
.20ca	60		rts				rts
.20cb					StackLoadPosition:
.20cb	a0 03		ldy #$03			ldy 	#3 							; read in codePtr from 3,2
.20cd	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20cf	85 01		sta $01				sta 	codePtr+1
.20d1	88		dey				dey
.20d2	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20d4	85 00		sta $00				sta 	codePtr
.20d6	88		dey				dey
.20d7	b1 0e		lda ($0e),y			lda 	(stackPtr),y 				; restore offset in line
.20d9	a8		tay				tay
.20da	60		rts				rts
.20db					StackSavePosition:
.20db	98		tya				tya 								; get position in A
.20dc	a0 01		ldy #$01			ldy 	#1
.20de	91 0e		sta ($0e),y			sta 	(stackPtr),y 				; write it out.
.20e0	48		pha				pha 								; save to stack
.20e1	c8		iny				iny 								; write line position
.20e2	a5 00		lda $00				lda 	codePtr
.20e4	91 0e		sta ($0e),y			sta 	(stackPtr),y
.20e6	c8		iny				iny
.20e7	a5 01		lda $01				lda 	codePtr+1
.20e9	91 0e		sta ($0e),y			sta 	(stackPtr),y
.20eb	68		pla				pla
.20ec	a8		tay				tay
.20ed	60		rts				rts
.20ee					StackPopLocals:
.20ee	a0 00		ldy #$00			ldy 	#0 							; check if TOS is a local record
.20f0	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20f2	c9 67		cmp #$67			cmp 	#SMLocal
.20f4	d0 1c		bne $2112			bne 	_SPLExit
.20f6	a0 05		ldy #$05			ldy 	#5 							; copy local address to temp0
.20f8	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20fa	85 04		sta $04				sta 	temp0
.20fc	c8		iny				iny
.20fd	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20ff	85 05		sta $05				sta 	temp0+1
.2101	a0 04		ldy #$04			ldy 	#4 							; start copying back
.2103					_SPLLoop:
.2103	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.2105	88		dey				dey
.2106	91 04		sta ($04),y			sta 	(temp0),y
.2108	c0 00		cpy #$00			cpy 	#0
.210a	d0 f7		bne $2103			bne 	_SPLLoop
.210c	20 b7 20	jsr $20b7			jsr 	StackClose 					; drop frame and try again
.210f	4c ee 20	jmp $20ee			jmp 	StackPopLocals
.2112					_SPLExit:
.2112	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: variables/common/varcreate.asm

.2113					VariableCreate:
.2113	ad ac 08	lda $08ac			lda 	VariableAutoCreate 			; are we allowed to autocreate
.2116	f0 48		beq $2160			beq 	_CVNoCreate
.2118	a5 10		lda $10				lda 	LowMemory 					; copy LowMemory to temp0 adding 9 as you go
.211a	85 04		sta $04				sta 	temp0 						; 9 is the size of a variable record.
.211c	18		clc				clc
.211d	69 09		adc #$09			adc 	#9
.211f	85 10		sta $10				sta 	LowMemory
.2121	a5 11		lda $11				lda 	LowMemory+1
.2123	85 05		sta $05				sta 	temp0+1
.2125	69 00		adc #$00			adc 	#0
.2127	85 11		sta $11				sta 	LowMemory+1
.2129	c5 0f		cmp $0f				cmp 	StackPtr+1 					; caught up with high memory ?
.212b	b0 30		bcs $215d			bcs 	_CVMemoryError
.212d	a0 00		ldy #$00			ldy 	#0 							; copy the current link from hash table into the 'next' links
.212f	b1 06		lda ($06),y			lda 	(temp1),y 					; from the hash table, inserting it into the front.
.2131	91 04		sta ($04),y			sta 	(temp0),y 					; (offset 0 & 1)
.2133	c8		iny				iny
.2134	b1 06		lda ($06),y			lda 	(temp1),y
.2136	91 04		sta ($04),y			sta 	(temp0),y
.2138	c8		iny				iny
.2139	a5 08		lda $08				lda 	temp2 						; write full 8 bit hash into offset 2
.213b	91 04		sta ($04),y			sta 	(temp0),y
.213d	c8		iny				iny
.213e	18		clc				clc 								; write variable name address into offset 3,4 (codePtr + y)
.213f	a5 0a		lda $0a				lda 	temp3
.2141	91 04		sta ($04),y			sta 	(temp0),y
.2143	c8		iny				iny
.2144	a5 0b		lda $0b				lda 	temp3+1
.2146	91 04		sta ($04),y			sta 	(temp0),y
.2148					_CVClear:
.2148	c8		iny				iny
.2149	a9 00		lda #$00			lda 	#$00
.214b	91 04		sta ($04),y			sta 	(temp0),y
.214d	c0 08		cpy #$08			cpy 	#8
.214f	d0 f7		bne $2148			bne 	_CVClear
.2151	a0 00		ldy #$00			ldy 	#0 							; put the address of the record as the new link head
.2153	a5 04		lda $04				lda 	temp0
.2155	91 06		sta ($06),y			sta 	(temp1),y
.2157	c8		iny				iny
.2158	a5 05		lda $05				lda 	temp0+1
.215a	91 06		sta ($06),y			sta 	(temp1),y
.215c	60		rts				rts
.215d					_CVMemoryError:
.215d	4c b1 19	jmp $19b1			jmp 	EHandlerMemory
.2160					_CVNoCreate
.2160	4c 90 1a	jmp $1a90			jmp 	EHandlerUnknownVar

;******  Return to file: basic.asm


;******  Processing file: variables/common/variables.asm

.2163					VariableAccess:
.2163	b1 00		lda ($00),y			lda 	(codePtr),y 				; check 20xx where x is 1..1A representing A-Z.
.2165	c9 1a		cmp #$1a			cmp 	#$1A 						; is this A-Z ?
.2167	b0 0b		bcs $2174			bcs 	_VANotBasic
.2169	0a		asl a				asl 	a 							; x 4
.216a	0a		asl a				asl 	a
.216b	95 28		sta $28,x			sta 	esInt0,x 					; set up address
.216d	a9 08		lda #$08			lda 	#RootVariables >> 8
.216f	95 30		sta $30,x			sta 	esInt1,x
.2171	4c b2 21	jmp $21b2			jmp 	VACheckModifier
.2174					_VANotBasic:
.2174	0a		asl a				asl 	a 							; calculate hash as 2 x first byte + second byte
.2175	c8		iny				iny
.2176	18		clc				clc
.2177	71 00		adc ($00),y			adc 	(codePtr),y
.2179	88		dey				dey
.217a	85 08		sta $08				sta 	temp2 						; 8 bit hash in temp2.
.217c	29 0f		and #$0f			and 	#HashTableSize-1 			; force into hash range
.217e	0a		asl a				asl 	a 							; double, word addresses in table and CLC
.217f	69 68		adc #$68			adc 	#HashTable & $FF 			; make temp1 point to the hash table first link.
.2181	85 06		sta $06				sta 	temp1
.2183	a9 08		lda #$08			lda 	#HashTable >> 8
.2185	85 07		sta $07				sta 	temp1+1
.2187	84 09		sty $09				sty 	temp2+1 					; Y is the offset of the first character.
.2189	98		tya				tya
.218a	18		clc				clc
.218b	65 00		adc $00				adc 	codePtr 					; temp3 is the address of that variable name.
.218d	85 0a		sta $0a				sta 	temp3
.218f	a5 01		lda $01				lda		codePtr+1
.2191	69 00		adc #$00			adc 	#0
.2193	85 0b		sta $0b				sta 	temp3+1
.2195	8a		txa				txa
.2196	48		pha				pha
.2197	98		tya				tya
.2198	48		pha				pha
.2199	20 fd 21	jsr $21fd			jsr 	VariableSearch 				; does it exist already ?
.219c	b0 03		bcs $21a1			bcs 	_VAExists
.219e	20 13 21	jsr $2113			jsr 	VariableCreate 				; create it.
.21a1					_VAExists:
.21a1	68		pla				pla
.21a2	a8		tay				tay
.21a3	68		pla				pla
.21a4	aa		tax				tax
.21a5	18		clc				clc
.21a6	a5 04		lda $04				lda 	temp0 						; add 5 to temp0, which is the offset in the record
.21a8	69 05		adc #$05			adc 	#5 							; of the actual variable data and copy into the stack
.21aa	95 28		sta $28,x			sta 	esInt0,x
.21ac	a5 05		lda $05				lda 	temp0+1
.21ae	69 00		adc #$00			adc 	#0
.21b0	95 30		sta $30,x			sta 	esInt1,x
.21b2					VACheckModifier:
.21b2	b1 00		lda ($00),y			lda 	(codePtr),y
.21b4	c8		iny				iny
.21b5	c9 30		cmp #$30			cmp 	#$30
.21b7	b0 f9		bcs $21b2			bcs 	VACheckModifier
.21b9	ad a8 08	lda $08a8			lda 	arrayEnabled 				; arrays in operation
.21bc	f0 2b		beq $21e9			beq 	_VAExit
.21be	b1 00		lda ($00),y			lda 	(codePtr),y 				; check for (
.21c0	c9 95		cmp #$95			cmp 	#KWD_LPAREN
.21c2	d0 25		bne $21e9			bne 	_VAExit
.21c4	c8		iny				iny
.21c5	a9 80		lda #$80			lda 	#$80 						; convert to a reference and derefence it
.21c7	95 20		sta $20,x			sta 	esType,x
.21c9	20 f8 16	jsr $16f8			jsr 	DeRefTop
.21cc	b5 30		lda $30,x			lda 	esInt1,x 					; check address $0000 - uninitialised
.21ce	15 28		ora $28,x			ora 	esInt0,x
.21d0	f0 22		beq $21f4			beq 	_VAUninitialised
.21d2	e8		inx				inx
.21d3	20 31 16	jsr $1631			jsr 	EvaluateTOSDeRef 			; get the index.
.21d6	20 3d 14	jsr $143d			jsr 	CheckRightParen
.21d9	20 31 1e	jsr $1e31			jsr 	Int32ShiftLeft 				; x 4
.21dc	20 31 1e	jsr $1e31			jsr 	Int32ShiftLeft
.21df	ca		dex				dex
.21e0	20 0d 1d	jsr $1d0d			jsr 	Int32Add 					; add together
.21e3	b5 38		lda $38,x			lda 	esInt2,x 					; check MSBytses result
.21e5	15 40		ora $40,x			ora 	esInt3,x
.21e7	d0 0e		bne $21f7			bne 	_VABadAIndex
.21e9					_VAExit:
.21e9	a9 00		lda #$00			lda 	#0 							; clear the upper two bytes of variable/element address.
.21eb	95 38		sta $38,x			sta 	esInt2,x
.21ed	95 40		sta $40,x			sta 	esInt3,x
.21ef	a9 80		lda #$80			lda 	#$80 						; it's a reference to an integer.
.21f1	95 20		sta $20,x			sta 	esType,x
.21f3	60		rts				rts
.21f4					_VAUninitialised:
.21f4	4c c8 19	jmp $19c8			jmp 	EHandlerNoArray
.21f7					_VABadAIndex:
.21f7	4c 30 19	jmp $1930			jmp 	EHandlerBadAIndex
.21fa					_VANoCreate:
.21fa	4c 90 1a	jmp $1a90			jmp 	EHandlerUnknownVar

;******  Return to file: basic.asm


;******  Processing file: variables/common/varsearch.asm

.21fd					VariableSearch:
.21fd	a5 06		lda $06				lda 	temp1 						; put the first hash link address into temp0
.21ff	85 04		sta $04				sta 	temp0
.2201	a5 07		lda $07				lda 	temp1+1
.2203	85 05		sta $05				sta 	temp0+1
.2205					_VSLoop:
.2205	a0 01		ldy #$01			ldy 	#1 							; look at MSB of link to follow
.2207	b1 04		lda ($04),y			lda 	(temp0),y
.2209	f0 29		beq $2234			beq 	_VSFail						; if zero, end of linked list, so exit with CC
.220b	aa		tax				tax 								; follow the link.
.220c	88		dey				dey
.220d	b1 04		lda ($04),y			lda 	(temp0),y
.220f	85 04		sta $04				sta 	temp0
.2211	86 05		stx $05				stx 	temp0+1
.2213	a0 02		ldy #$02			ldy 	#2 							; check the hashes match
.2215	b1 04		lda ($04),y			lda 	(temp0),y
.2217	c5 08		cmp $08				cmp 	temp2 						; no, they don't, go around.
.2219	d0 ea		bne $2205			bne 	_VSLoop
.221b	c8		iny				iny 								; copy the varname address into temp4
.221c	b1 04		lda ($04),y			lda 	(temp0),y
.221e	85 0c		sta $0c				sta 	temp4
.2220	c8		iny				iny
.2221	b1 04		lda ($04),y			lda 	(temp0),y
.2223	85 0d		sta $0d				sta 	temp4+1
.2225	a0 00		ldy #$00			ldy 	#0 							; now compare them.
.2227					_VSCompareName:
.2227	b1 0c		lda ($0c),y			lda 	(temp4),y
.2229	d1 0a		cmp ($0a),y			cmp 	(temp3),y
.222b	d0 d8		bne $2205			bne 	_VSLoop 					; different, go around
.222d	c8		iny				iny
.222e	c9 30		cmp #$30			cmp 	#$30 						; reached end marker
.2230	b0 f5		bcs $2227			bcs 	_VSCompareName
.2232	38		sec				sec 								; and we match.
.2233	60		rts				rts
.2234	18		clc		_VSFail:clc
.2235	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: assembler/inline/assembler.inc

=0					AM_Immediate = 0
=1					AM_Zero = 1
=2					AM_Implied = 2
=3					AM_Abs = 3
=4					AM_IndY = 4
=5					AM_ZeroX = 5
=6					AM_AbsY = 6
=7					AM_AbsX = 7
=8					AMX_IndX = 8
=9					AMX_Ind = 9
=10					AMX_Relative = 10
=11					AMX_ZeroY = 11

;******  Return to file: basic.asm


;******  Processing file: assembler/inline/asmtoken.asm

.2236					AssemBuildToken:
.2236	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first token.
.2238	38		sec				sec 	 							; we know it is in range, store in LSB
.2239	e9 30		sbc #$30			sbc 	#$30
.223b	8d ad 08	sta $08ad			sta 	AsmToken
.223e	c8		iny				iny
.223f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get second token.
.2241	38		sec				sec
.2242	e9 30		sbc #$30			sbc 	#$30
.2244	90 21		bcc $2267			bcc 	_ABSyntax 					; check it is in the range, e.g. a continuing token.
.2246	c9 30		cmp #$30			cmp 	#$30
.2248	b0 1d		bcs $2267			bcs 	_ABSyntax
.224a	8d ae 08	sta $08ae			sta 	AsmToken+1 					; we'll shift it into position
.224d	c8		iny				iny 								; get and skip third token
.224e	b1 00		lda ($00),y			lda 	(codePtr),y
.2250	c8		iny				iny
.2251	c9 30		cmp #$30			cmp 	#$30 						; this should be last.
.2253	b0 12		bcs $2267			bcs 	_ABSyntax
.2255	0a		asl a				asl 	a
.2256	0a		asl a				asl 	a
.2257	0a		asl a				asl 	a
.2258	0a		asl a				asl 	a
.2259	2e ae 08	rol $08ae			rol 	AsmToken+1
.225c	0a		asl a				asl 	a
.225d	2e ae 08	rol $08ae			rol 	AsmToken+1
.2260	0d ad 08	ora $08ad			ora 	AsmToken 					; or into LSB
.2263	8d ad 08	sta $08ad			sta 	AsmToken
.2266	60		rts				rts
.2267					_ABSyntax:
.2267	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: assembler/inline/asmutils.asm

.226a					AssemblerWrite:
.226a	48		pha				pha 								; save A
.226b	ad 3d 08	lda $083d			lda 	pVariable+1 				; print address
.226e	20 d0 22	jsr $22d0			jsr 	AWPrintHex
.2271	ad 3c 08	lda $083c			lda 	pVariable
.2274	20 c8 22	jsr $22c8			jsr 	AWPrintHexSpace
.2277	68		pla				pla 								; restore opcode
.2278	20 9d 22	jsr $229d			jsr 	AWWriteOpcode 				; write opcode out.
.227b	bd bc 22	lda $22bc,x			lda 	AWSizeTable,x 				; get the number of bytes to output.
.227e	aa		tax				tax 								; count in X
.227f	c9 02		cmp #$02			cmp 	#2 							; check zero mode ?
.2281	d0 04		bne $2287			bne 	_AWWNoCheckZP
.2283	a5 30		lda $30				lda 	ESInt1 						; if zero mode, must be 00-FF
.2285	d0 13		bne $229a			bne 	_AWWOperand
.2287					_AWWNoCheckZP:
.2287	ca		dex				dex
.2288	f0 0d		beq $2297			beq 	_AWExit
.228a	a5 28		lda $28				lda 	ESInt0
.228c	20 9d 22	jsr $229d			jsr 	AWWriteOpcode
.228f	ca		dex				dex
.2290	f0 05		beq $2297			beq 	_AWExit
.2292	a5 30		lda $30				lda 	ESInt1
.2294	20 9d 22	jsr $229d			jsr 	AWWriteOpcode
.2297					_AWExit:
.2297	4c 01 26	jmp $2601			jmp 	XTPrintCR
.229a					_AWWOperand:
.229a	4c 46 1a	jmp $1a46			jmp 	EHandlerOperand
.229d					AWWriteOpcode:
.229d	48		pha				pha 								; save opcode
.229e	ad 3c 08	lda $083c			lda 	pVariable 					; copy address in P to temp0
.22a1	85 04		sta $04				sta 	temp0
.22a3	ad 3d 08	lda $083d			lda 	pVariable+1
.22a6	85 05		sta $05				sta 	temp0+1
.22a8	84 03		sty $03				sty 	tempShort 					; write byte out.
.22aa	68		pla				pla
.22ab	a0 00		ldy #$00			ldy 	#0
.22ad	91 04		sta ($04),y			sta 	(temp0),y
.22af	a4 03		ldy $03				ldy 	tempShort
.22b1	ee 3c 08	inc $083c			inc 	pVariable 					; bump P
.22b4	d0 03		bne $22b9			bne 	_AWWOSkip
.22b6	ee 3d 08	inc $083d			inc 	pVariable+1
.22b9					_AWWOSkip:
.22b9	4c c8 22	jmp $22c8			jmp 	AWPrintHexSpace 			; write it out.
.22bc					AWSizeTable:
>22bc	02 02 01 03 02 02 03 03				.byte 	2,2,1,3,2,2,3,3,3,3,2,2
>22c4	03 03 02 02
.22c8					AWPrintHexSpace:
.22c8	20 d0 22	jsr $22d0			jsr 	AWPrintHex
.22cb	a9 20		lda #$20			lda 	#' '
.22cd	4c 11 26	jmp $2611			jmp 	XTPrintA
.22d0					AWPrintHex:
.22d0	48		pha				pha
.22d1	4a		lsr a				lsr 	a
.22d2	4a		lsr a				lsr 	a
.22d3	4a		lsr a				lsr 	a
.22d4	4a		lsr a				lsr 	a
.22d5	20 d9 22	jsr $22d9			jsr 	_AWPrintNibble
.22d8	68		pla				pla
.22d9					_AWPrintNibble:
.22d9	29 0f		and #$0f			and 	#$0F
.22db	c9 0a		cmp #$0a			cmp 	#10
.22dd	90 02		bcc $22e1			bcc 	_AWNotHex
.22df	69 06		adc #$06			adc 	#6
.22e1					_AWNotHex:
.22e1	69 30		adc #$30			adc 	#48
.22e3	4c 11 26	jmp $2611			jmp 	XTPrintA

;******  Return to file: basic.asm


;******  Processing file: assembler/inline/assembler.asm

.22e6					Assembler:
.22e6	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.22e8	c9 30		cmp #$30			cmp 	#$30 						; single char identifier not allowed
.22ea	90 69		bcc $2355			bcc 	AssemblerSyntax
.22ec	c9 54		cmp #$54			cmp 	#$30+$24 					; is it a label ?
.22ee	f0 20		beq $2310			beq 	AssemblerLabel
.22f0	c9 60		cmp #$60			cmp 	#$60 						; is it a character (e.g $00-$5F)
.22f2	90 64		bcc $2358			bcc 	AssemblerOpcode
.22f4	c8		iny				iny 								; consume it.
.22f5	c9 b2		cmp #$b2			cmp 	#KWD_RSQPAREN 				; if ]
.22f7	f0 16		beq $230f			beq 	AssemblerExit
.22f9	c9 81		cmp #$81			cmp 	#KWD_AND 					; tokenised assembler.
.22fb	f0 49		beq $2346			beq 	AssemblerAnd 				; AND only at present.
.22fd	c9 c1		cmp #$c1			cmp 	#KWD_COLON 					; ignore colons
.22ff	f0 e5		beq $22e6			beq 	Assembler
.2301	c9 ad		cmp #$ad			cmp 	#KWD_SEMICOLON 				; semicolon is a comment
.2303	f0 04		beq $2309			beq 	AssemblerNextLine
.2305	c9 80		cmp #$80			cmp 	#$80 						; if not EOL
.2307	d0 4c		bne $2355			bne 	AssemblerSyntax
.2309					AssemblerNextLine:
.2309	20 c2 13	jsr $13c2			jsr 	CommandNextLine 			; go to next line
.230c	4c e6 22	jmp $22e6			jmp 	Assembler
.230f					AssemblerExit:
.230f	60		rts				rts
.2310					AssemblerLabel:
.2310	c8		iny				iny 								; skip over the .
.2311	b1 00		lda ($00),y			lda 	(codePtr),y 				; which means we can't have single letter labels
.2313	c9 30		cmp #$30			cmp 	#$30
.2315	90 3e		bcc $2355			bcc 	AssemblerSyntax
.2317	a9 0f		lda #$0f			lda 	#15 						; get a single term
.2319	a2 00		ldx #$00			ldx 	#0
.231b	20 3b 16	jsr $163b			jsr 	EvaluateLevelAX
.231e	b5 20		lda $20,x			lda 	esType,x 					; check it is a reference
.2320	10 33		bpl $2355			bpl 	AssemblerSyntax
.2322	b5 28		lda $28,x			lda 	esInt0,x 					; copy label address to temp0
.2324	85 04		sta $04				sta 	temp0
.2326	b5 30		lda $30,x			lda 	esInt1,x
.2328	85 05		sta $05				sta 	temp0+1
.232a	98		tya				tya
.232b	48		pha				pha
.232c	a0 00		ldy #$00			ldy 	#0
.232e	ad 3c 08	lda $083c			lda 	pVariable 					; copy the value of P in
.2331	91 04		sta ($04),y			sta 	(temp0),y
.2333	c8		iny				iny
.2334	ad 3d 08	lda $083d			lda 	pVariable+1
.2337	91 04		sta ($04),y			sta 	(temp0),y
.2339	c8		iny				iny
.233a	a9 00		lda #$00			lda 	#0
.233c	91 04		sta ($04),y			sta 	(temp0),y
.233e	c8		iny				iny
.233f	91 04		sta ($04),y			sta 	(temp0),y
.2341	68		pla				pla
.2342	a8		tay				tay
.2343	4c e6 22	jmp $22e6			jmp 	Assembler 					; go round again.
.2346					AssemblerAND:
.2346	ad 39 24	lda $2439			lda 	AndMnemonic
.2349	8d ad 08	sta $08ad			sta 	AsmToken
.234c	ad 3a 24	lda $243a			lda 	AndMnemonic+1
.234f	8d ae 08	sta $08ae			sta 	AsmToken+1
.2352	4c 5b 23	jmp $235b			jmp 	AssemblerHaveToken
.2355					AssemblerSyntax:
.2355	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax
.2358					AssemblerOpcode:
.2358	20 36 22	jsr $2236			jsr 	AssemBuildToken 			; make 16 bit token
.235b					AssemblerHaveToken:
.235b	20 3f 25	jsr $253f			jsr 	AssemGetOperand				; figure out operand and addresing mode.
.235e	8e af 08	stx $08af			stx 	AsmMode
.2361	a9 29		lda #$29			lda 	#(OpcodeTable) & $FF
.2363	85 04		sta $04				sta 	temp0
.2365	a9 24		lda #$24			lda 	#(OpcodeTable) >> 8
.2367	85 05		sta $05				sta 	1+(temp0)
.2369	98		tya				tya
.236a	48		pha				pha
.236b					_AHTSearch:
.236b	a0 01		ldy #$01			ldy 	#1 							; search table for token.
.236d	b1 04		lda ($04),y			lda 	(temp0),y
.236f	c9 ff		cmp #$ff			cmp 	#$FF
.2371	f0 e2		beq $2355			beq 	AssemblerSyntax 			; end of table.
.2373	cd ae 08	cmp $08ae			cmp 	AsmToken+1
.2376	d0 08		bne $2380			bne 	_AHTNext
.2378	88		dey				dey
.2379	b1 04		lda ($04),y			lda 	(temp0),y
.237b	cd ad 08	cmp $08ad			cmp 	AsmToken
.237e	f0 0e		beq $238e			beq 	_AHTFound
.2380					_AHTNext:
.2380	a5 04		lda $04				lda 	temp0 						; go to next record
.2382	18		clc				clc
.2383	69 04		adc #$04			adc 	#4
.2385	85 04		sta $04				sta 	temp0
.2387	90 e2		bcc $236b			bcc 	_AHTSearch
.2389	e6 05		inc $05				inc 	temp0+1
.238b	4c 6b 23	jmp $236b			jmp 	_AHTSearch
.238e					_AHTFound:
.238e	a0 02		ldy #$02			ldy 	#2 							; copy base opcode / type
.2390	b1 04		lda ($04),y			lda 	(temp0),y
.2392	8d b0 08	sta $08b0			sta 	AsmOpcode
.2395	c8		iny				iny
.2396	b1 04		lda ($04),y			lda 	(temp0),y
.2398	8d b1 08	sta $08b1			sta 	AsmType
.239b	c9 f0		cmp #$f0			cmp 	#$F0 						; is it a single type opcode ?
.239d	90 0c		bcc $23ab			bcc 	_AHTAllowed
.239f	29 0f		and #$0f			and 	#$0F
.23a1	cd af 08	cmp $08af			cmp 	AsmMode 					; does it match what we found ?
.23a4	f0 05		beq $23ab			beq 	_AHTAllowed 				; if so, carry on.
.23a6	20 c4 23	jsr $23c4			jsr 	HackStandaloneTypes 		; try to hack it ?
.23a9	90 d5		bcc $2380			bcc 	_AHTNext 					; failed, loop back.
.23ab					_AHTAllowed:
.23ab	68		pla				pla
.23ac	a8		tay				tay
.23ad	ad b1 08	lda $08b1			lda 	AsmType
.23b0	c9 f0		cmp #$f0			cmp 	#$F0 						; if type is F0-FF go do standalone.
.23b2	90 0f		bcc $23c3			bcc 	_AHTIsGroup
.23b4	ad b1 08	lda $08b1			lda 	AsmType 					; set up AX and write out
.23b7	29 0f		and #$0f			and 	#$0F
.23b9	aa		tax				tax
.23ba	ad b0 08	lda $08b0			lda 	AsmOpcode
.23bd	20 6a 22	jsr $226a			jsr 	AssemblerWrite
.23c0	4c e6 22	jmp $22e6			jmp 	Assembler 					; go round again.
.23c3					_AHTIsGroup:
>23c3	db						.byte 	$DB
.23c4					HackStandaloneTypes:
.23c4	ad b1 08	lda $08b1			lda 	AsmType						; make Mode required : Mode in user code.
.23c7	0a		asl a				asl 	a
.23c8	0a		asl a				asl 	a
.23c9	0a		asl a				asl 	a
.23ca	0a		asl a				asl 	a
.23cb	0d af 08	ora $08af			ora 	AsmMode
.23ce	c9 13		cmp #$13			cmp 	#(AM_Zero << 4)|AM_Abs
.23d0	f0 0f		beq $23e1			beq 	_HSTZeroAbsolute
.23d2	c9 57		cmp #$57			cmp 	#(AM_ZeroX << 4)|AM_AbsX
.23d4	f0 13		beq $23e9			beq 	_HSTZeroXAbsoluteX
.23d6	c9 a3		cmp #$a3			cmp 	#(AMX_Relative << 4)|AM_Abs
.23d8	f0 17		beq $23f1			beq 	_HSTRelAbsolute
.23da					_HSTFail:
.23da	18		clc				clc
.23db	60		rts				rts
.23dc					_HSTSwitch:
.23dc	8d af 08	sta $08af			sta 	AsmMode 					; switch it to this
.23df	38		sec				sec
.23e0	60		rts				rts
.23e1					_HSTZeroAbsolute:
.23e1	a5 30		lda $30				lda 	esInt1 						; must be 00-FF
.23e3	d0 f5		bne $23da			bne 	_HSTFail
.23e5	a9 01		lda #$01			lda 	#AM_Zero 					; and switch
.23e7	10 f3		bpl $23dc			bpl 	_HSTSwitch
.23e9					_HSTZeroXAbsoluteX:
.23e9	a5 30		lda $30				lda 	esInt1 						; must be 00-FF
.23eb	d0 ed		bne $23da			bne 	_HSTFail
.23ed	a9 05		lda #$05			lda 	#AM_ZeroX 					; and switch
.23ef	10 eb		bpl $23dc			bpl 	_HSTSwitch
.23f1					_HSTRelAbsolute:
.23f1	ad 3c 08	lda $083c			lda 	pVariable 					; temp1 = pVariable+2 (start address)
.23f4	18		clc				clc
.23f5	69 02		adc #$02			adc 	#2
.23f7	85 06		sta $06				sta 	temp1
.23f9	ad 3d 08	lda $083d			lda 	pVariable+1
.23fc	69 00		adc #$00			adc 	#0
.23fe	85 07		sta $07				sta 	temp1+1
.2400	38		sec				sec 								; subtract from the target address
.2401	a5 28		lda $28				lda 	esInt0
.2403	e5 06		sbc $06				sbc 	temp1
.2405	85 28		sta $28				sta 	esInt0
.2407	a5 30		lda $30				lda		esInt1
.2409	e5 07		sbc $07				sbc 	temp1+1
.240b	85 30		sta $30				sta 	esInt1
.240d	f0 07		beq $2416			beq 	_HSTRangeOk 				; MSB must be $FF or $00
.240f	c9 ff		cmp #$ff			cmp 	#$FF
.2411	f0 03		beq $2416			beq 	_HSTRangeOk
.2413					_HSTRangeError:
.2413	4c 6c 19	jmp $196c			jmp 	EHandlerBranchSize
.2416					_HSTRangeOk:
.2416	45 28		eor $28				eor 	esInt0						; signs must be the same.
.2418	30 f9		bmi $2413			bmi 	_HSTRangeError
.241a	a9 00		lda #$00			lda 	#0 							; force into range.
.241c	85 30		sta $30				sta 	esInt1
.241e	a9 01		lda #$01			lda 	#AM_Zero
.2420	10 ba		bpl $23dc			bpl 	_HSTSwitch

;******  Return to file: basic.asm


;******  Processing file: assembler/inline/generated/asmdat.asm

.2422					MaskTable:
>2422	ff					.byte $ff ; Mask $0x
>2423	75					.byte $75 ; Mask $1x
>2424	54					.byte $54 ; Mask $2x
>2425	d5					.byte $d5 ; Mask $3x
>2426	55					.byte $55 ; Mask $4x
>2427	d4					.byte $d4 ; Mask $5x
>2428	d0					.byte $d0 ; Mask $6x
.2429					OpcodeTable:
>2429	61 22					.word $2261 ; bit
>242b	24					.byte $24
>242c	f0					.byte $f0
>242d	48 34					.word $3448 ; inc
>242f	1a					.byte $1a
>2430	f2					.byte $f2
>2431	43 10					.word $1043 ; dec
>2433	3a					.byte $3a
>2434	f2					.byte $f2
>2435	0e 44					.word $440e ; ora
>2437	01					.byte $01
>2438	01					.byte $01
.2439					AndMnemonic:
>2439	60 34					.word $3460 ; and
>243b	21					.byte $21
>243c	01					.byte $01
>243d	24 3a					.word $3a24 ; eor
>243f	41					.byte $41
>2440	01					.byte $01
>2441	12 4c					.word $4c12 ; sta
>2443	61					.byte $61
>2444	01					.byte $01
>2445	0b 0c					.word $0c0b ; lda
>2447	81					.byte $81
>2448	01					.byte $01
>2449	e2 31					.word $31e2 ; cmp
>244b	a1					.byte $a1
>244c	01					.byte $01
>244d	52 04					.word $0452 ; sbc
>244f	e1					.byte $e1
>2450	01					.byte $01
>2451	60 49					.word $4960 ; asl
>2453	02					.byte $02
>2454	12					.byte $12
>2455	71 39					.word $3971 ; rol
>2457	22					.byte $22
>2458	12					.byte $12
>2459	2b 4a					.word $4a2b ; lsr
>245b	42					.byte $42
>245c	12					.byte $12
>245d	31 3a					.word $3a31 ; ror
>245f	62					.byte $62
>2460	12					.byte $12
>2461	f2 4e					.word $4ef2 ; stx
>2463	82					.byte $82
>2464	22					.byte $22
>2465	eb 0e					.word $0eeb ; ldx
>2467	a2					.byte $a2
>2468	32					.byte $32
>2469	43 10					.word $1043 ; dec
>246b	c2					.byte $c2
>246c	42					.byte $42
>246d	48 34					.word $3448 ; inc
>246f	e2					.byte $e2
>2470	42					.byte $42
>2471	61 22					.word $2261 ; bit
>2473	20					.byte $20
>2474	43					.byte $43
>2475	12 4f					.word $4f12 ; sty
>2477	80					.byte $80
>2478	23					.byte $23
>2479	0b 0f					.word $0f0b ; ldy
>247b	a0					.byte $a0
>247c	53					.byte $53
>247d	02 3f					.word $3f02 ; cpy
>247f	c0					.byte $c0
>2480	63					.byte $63
>2481	e2 3e					.word $3ee2 ; cpx
>2483	e0					.byte $e0
>2484	63					.byte $63
>2485	61 3d					.word $3d61 ; bpl
>2487	10					.byte $10
>2488	fa					.byte $fa
>2489	01 31					.word $3101 ; bmi
>248b	30					.byte $30
>248c	fa					.byte $fa
>248d	41 54					.word $5441 ; bvc
>248f	50					.byte $50
>2490	fa					.byte $fa
>2491	41 0a					.word $0a41 ; bcs
>2493	70					.byte $70
>2494	fa					.byte $fa
>2495	41 08					.word $0841 ; bcc
>2497	90					.byte $90
>2498	fa					.byte $fa
>2499	41 0a					.word $0a41 ; bcs
>249b	b0					.byte $b0
>249c	fa					.byte $fa
>249d	81 34					.word $3481 ; bne
>249f	d0					.byte $d0
>24a0	fa					.byte $fa
>24a1	01 12					.word $1201 ; beq
>24a3	f0					.byte $f0
>24a4	fa					.byte $fa
>24a5	29 4a					.word $4a29 ; jsr
>24a7	20					.byte $20
>24a8	f3					.byte $f3
>24a9	e9 31					.word $31e9 ; jmp
>24ab	4c					.byte $4c
>24ac	f3					.byte $f3
>24ad	e9 31					.word $31e9 ; jmp
>24af	6c					.byte $6c
>24b0	f9					.byte $f9
>24b1	41 45					.word $4541 ; brk
>24b3	00					.byte $00
>24b4	f2					.byte $f2
>24b5	11 4d					.word $4d11 ; rti
>24b7	40					.byte $40
>24b8	f2					.byte $f2
>24b9	51 4e					.word $4e51 ; rts
>24bb	60					.byte $60
>24bc	f2					.byte $f2
>24bd	ef 1d					.word $1def ; php
>24bf	08					.byte $08
>24c0	f2					.byte $f2
>24c1	ef 2d					.word $2def ; plp
>24c3	28					.byte $28
>24c4	f2					.byte $f2
>24c5	0f 1c					.word $1c0f ; pha
>24c7	48					.byte $48
>24c8	f2					.byte $f2
>24c9	0f 2c					.word $2c0f ; pla
>24cb	68					.byte $68
>24cc	f2					.byte $f2
>24cd	03 13					.word $1303 ; dey
>24cf	88					.byte $88
>24d0	f2					.byte $f2
>24d1	13 03					.word $0313 ; tay
>24d3	a8					.byte $a8
>24d4	f2					.byte $f2
>24d5	08 37					.word $3708 ; iny
>24d7	c8					.byte $c8
>24d8	f2					.byte $f2
>24d9	e8 36					.word $36e8 ; inx
>24db	e8					.byte $e8
>24dc	f2					.byte $f2
>24dd	42 2c					.word $2c42 ; clc
>24df	18					.byte $18
>24e0	f2					.byte $f2
>24e1	52 10					.word $1052 ; sec
>24e3	38					.byte $38
>24e4	f2					.byte $f2
>24e5	02 2d					.word $2d02 ; cli
>24e7	58					.byte $58
>24e8	f2					.byte $f2
>24e9	12 11					.word $1112 ; sei
>24eb	78					.byte $78
>24ec	f2					.byte $f2
>24ed	13 60					.word $6013 ; tya
>24ef	98					.byte $98
>24f0	f2					.byte $f2
>24f1	a2 2e					.word $2ea2 ; clv
>24f3	b8					.byte $b8
>24f4	f2					.byte $f2
>24f5	62 2c					.word $2c62 ; cld
>24f7	d8					.byte $d8
>24f8	f2					.byte $f2
>24f9	72 10					.word $1072 ; sed
>24fb	f8					.byte $f8
>24fc	f2					.byte $f2
>24fd	13 5c					.word $5c13 ; txa
>24ff	8a					.byte $8a
>2500	f2					.byte $f2
>2501	53 5e					.word $5e53 ; txs
>2503	9a					.byte $9a
>2504	f2					.byte $f2
>2505	f3 02					.word $02f3 ; tax
>2507	aa					.byte $aa
>2508	f2					.byte $f2
>2509	f3 4a					.word $4af3 ; tsx
>250b	ba					.byte $ba
>250c	f2					.byte $f2
>250d	e3 12					.word $12e3 ; dex
>250f	ca					.byte $ca
>2510	f2					.byte $f2
>2511	ed 39					.word $39ed ; nop
>2513	ea					.byte $ea
>2514	f2					.byte $f2
>2515	e9 31					.word $31e9 ; jmp
>2517	7c					.byte $7c
>2518	f8					.byte $f8
>2519	01 44					.word $4401 ; bra
>251b	80					.byte $80
>251c	fa					.byte $fa
>251d	32 4f					.word $4f32 ; stz
>251f	64					.byte $64
>2520	f1					.byte $f1
>2521	32 4f					.word $4f32 ; stz
>2523	74					.byte $74
>2524	f5					.byte $f5
>2525	32 4f					.word $4f32 ; stz
>2527	9c					.byte $9c
>2528	f3					.byte $f3
>2529	32 4f					.word $4f32 ; stz
>252b	9e					.byte $9e
>252c	f7					.byte $f7
>252d	0f 1f					.word $1f0f ; phy
>252f	5a					.byte $5a
>2530	f2					.byte $f2
>2531	0f 2f					.word $2f0f ; ply
>2533	7a					.byte $7a
>2534	f2					.byte $f2
>2535	ef 1e					.word $1eef ; phx
>2537	da					.byte $da
>2538	f2					.byte $f2
>2539	0f 1f					.word $1f0f ; phy
>253b	fa					.byte $fa
>253c	f2					.byte $f2
>253d	ff ff					.word $FFFF

;******  Return to file: basic.asm


;******  Processing file: assembler/inline/operand.asm

.253f					AssemGetOperand:
.253f	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next token.
.2541	a2 02		ldx #$02			ldx 	#AM_Implied 				; first check for Implied and Acc, effectively same.
.2543	c9 80		cmp #$80			cmp 	#$80 						; EOL and colon are implied.
.2545	f0 09		beq $2550			beq 	_AGOExit
.2547	c9 c1		cmp #$c1			cmp 	#KWD_COLON
.2549	f0 05		beq $2550			beq 	_AGOExit
.254b	c9 00		cmp #$00			cmp 	#$00 						; indicates 'A' e.g. ASL A , single character letter A
.254d	d0 02		bne $2551			bne 	_AGONotImplied
.254f	c8		iny				iny 								; consume the A
.2550					_AGOExit:
.2550	60		rts				rts
.2551					_AGONotImplied:
.2551	c9 af		cmp #$af			cmp 	#KWD_HASH 					; is it immediate e.g. #xxx
.2553	d0 0b		bne $2560			bne 	_AGONotImmediate
.2555	c8		iny				iny 								; consume
.2556	a2 00		ldx #$00			ldx 	#AM_Immediate
.2558	20 b4 25	jsr $25b4			jsr 	AssemGetParameter 			; get the parameter value
.255b	a5 30		lda $30				lda 	esInt1 						; must be 00-FF
.255d	d0 63		bne $25c2			bne 	AGPError
.255f	60		rts				rts
.2560					_AGONotImmediate:
.2560	c9 95		cmp #$95			cmp 	#KWD_LPAREN 				; check if indirect (xxx
.2562	f0 1e		beq $2582			beq 	_AGOIndirect
.2564	20 b4 25	jsr $25b4			jsr 	AssemGetParameter 			; get parameter
.2567	a2 03		ldx #$03			ldx 	#AM_Abs						; return Absolute.
.2569	b1 00		lda ($00),y			lda 	(codePtr),y 				; followed by comma
.256b	c9 ac		cmp #$ac			cmp 	#KWD_COMMA
.256d	d0 e1		bne $2550			bne 	_AGOExit
.256f	c8		iny				iny 								; consume and get and consume next.
.2570	b1 00		lda ($00),y			lda 	(codePtr),y
.2572	c8		iny				iny
.2573	a2 07		ldx #$07			ldx 	#AM_ABSX 					; which must be X or Y
.2575	c9 17		cmp #$17			cmp 	#'X'-'A'
.2577	f0 d7		beq $2550			beq 	_AGOExit
.2579	a2 06		ldx #$06			ldx 	#AM_ABSY
.257b	c9 18		cmp #$18			cmp 	#'Y'-'A'
.257d	f0 d1		beq $2550			beq 	_AGOExit
.257f					_AGOSyntax:
.257f	4c 6f 1a	jmp $1a6f			jmp 	EHandlerSyntax
.2582					_AGOIndirect:
.2582	c8		iny				iny 								; consume (
.2583	20 b4 25	jsr $25b4			jsr 	AssemGetParameter 			; get the indirection address.
.2586	b1 00		lda ($00),y			lda 	(codePtr),y 				; what follows
.2588	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN 				; if right parenthesis then it must be (xxx),y or (xxxx)
.258a	f0 10		beq $259c			beq 	_AGOIndirectY
.258c	20 25 14	jsr $1425			jsr 	CheckComma 					; so must be comma.
.258f	b1 00		lda ($00),y			lda 	(codePtr),y 				; followed by X
.2591	c9 17		cmp #$17			cmp 	#'X'-'A'
.2593	d0 ea		bne $257f			bne 	_AGOSyntax
.2595	c8		iny				iny 								; consume
.2596	20 3d 14	jsr $143d			jsr 	CheckRightParen 			; check closing )
.2599	a2 08		ldx #$08			ldx 	#AMX_IndX 					; return (nnnn,x)
.259b	60		rts				rts
.259c					_AGOIndirectY:
.259c	c8		iny				iny 								; consume RParen
.259d	b1 00		lda ($00),y			lda 	(codePtr),y 				; if not followed by , then exit with Indirect
.259f	a2 09		ldx #$09			ldx 	#AMX_Ind
.25a1	c9 ac		cmp #$ac			cmp 	#KWD_Comma
.25a3	d0 ab		bne $2550			bne 	_AGOExit
.25a5	c8		iny				iny 								; comsume ,
.25a6	b1 00		lda ($00),y			lda 	(codePtr),y 				; followed by Y
.25a8	c9 18		cmp #$18			cmp 	#'Y'-'A'
.25aa	d0 d3		bne $257f			bne 	_AGOSyntax
.25ac	c8		iny				iny 								; consume Y
.25ad	a2 04		ldx #$04			ldx 	#AM_IndY 					; there is no (absolute),Y
.25af	a5 30		lda $30				lda 	esInt1 						; check parameter.
.25b1	d0 9d		bne $2550			bne 	_AGOExit
.25b3	60		rts				rts
.25b4					AssemGetParameter:
.25b4	8a		txa				txa
.25b5	48		pha				pha
.25b6	20 2b 16	jsr $162b			jsr 	EvaluateBaseDeref			; work out the operand
.25b9	a5 38		lda $38				lda 	esInt2 						; check range
.25bb	05 40		ora $40				ora 	esInt3 						; e.g. 0000-FFFF
.25bd	d0 03		bne $25c2			bne 	AGPError
.25bf	68		pla				pla
.25c0	aa		tax				tax
.25c1	60		rts				rts
.25c2					AGPError:
.25c2	4c 46 1a	jmp $1a46			jmp 	EHandlerOperand

;******  Return to file: basic.asm


;******  Processing file: system/x16/x16/x16hardware.asm

.25c5					XTGetKey:
.25c5	8a		txa				txa
.25c6	48		pha				pha
.25c7	98		tya				tya
.25c8	48		pha				pha
.25c9	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.25cc	85 03		sta $03				sta 	tempShort
.25ce	68		pla				pla
.25cf	a8		tay				tay
.25d0	68		pla				pla
.25d1	aa		tax				tax
.25d2	a5 03		lda $03				lda 	tempShort
.25d4	60		rts				rts
.25d5					XTUpdateClock:
.25d5	48		pha				pha
.25d6	8a		txa				txa
.25d7	48		pha				pha
.25d8	98		tya				tya
.25d9	48		pha				pha
.25da	20 de ff	jsr $ffde			jsr 	$FFDE
.25dd	8c a2 08	sty $08a2			sty 	ClockTicks+2
.25e0	8e a1 08	stx $08a1			stx 	ClockTicks+1
.25e3	8d a0 08	sta $08a0			sta 	ClockTicks
.25e6	a9 00		lda #$00			lda 	#0
.25e8	8d a3 08	sta $08a3			sta 	ClockTicks+3
.25eb	68		pla				pla
.25ec	a8		tay				tay
.25ed	68		pla				pla
.25ee	aa		tax				tax
.25ef	68		pla				pla
.25f0	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: system/x16/x16/x16print.asm

.25f1					XTPrintAC:
.25f1	c9 61		cmp #$61			cmp 	#"a"
.25f3	90 1c		bcc $2611			bcc 	XTPrintA
.25f5	c9 7b		cmp #$7b			cmp 	#"z"+1
.25f7	b0 18		bcs $2611			bcs 	XTPrintA
.25f9	48		pha				pha
.25fa	49 20		eor #$20			eor 	#$20
.25fc	20 11 26	jsr $2611			jsr 	XTPrintA
.25ff	68		pla				pla
.2600	60		rts				rts
.2601					XTPrintCR:
.2601	48		pha				pha
.2602	a9 0d		lda #$0d			lda 	#13
.2604	20 11 26	jsr $2611			jsr 	XTPrintA
.2607	68		pla				pla
.2608	60		rts				rts
.2609					XTPrintTab:
.2609	48		pha				pha
.260a	a9 20		lda #$20			lda 	#32
.260c	20 11 26	jsr $2611			jsr 	XTPrintA
.260f	68		pla				pla
.2610	60		rts				rts
.2611					XTPrintA:
.2611	85 03		sta $03				sta 	tempShort
.2613	48		pha				pha
.2614	8a		txa				txa
.2615	48		pha				pha
.2616	98		tya				tya
.2617	48		pha				pha
.2618	a5 03		lda $03				lda 	tempShort
.261a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.261d	68		pla				pla
.261e	a8		tay				tay
.261f	68		pla				pla
.2620	aa		tax				tax
.2621	68		pla				pla
.2622	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: testing/code/99program.asm

>2623						.align 256
.2700					BasicProgram:
>2700	07					.byte $07
>2701	e8					.byte $e8
>2702	03					.byte $03
>2703	0e					.byte $0e
>2704	89					.byte $89
>2705	70					.byte $70
>2706	80					.byte $80
>2707	0a					.byte $0a
>2708	f2					.byte $f2
>2709	03					.byte $03
>270a	0f					.byte $0f
>270b	89					.byte $89
>270c	96					.byte $96
>270d	70					.byte $70
>270e	70					.byte $70
>270f	77					.byte $77
>2710	80					.byte $80
>2711	12					.byte $12
>2712	fc					.byte $fc
>2713	03					.byte $03
>2714	42					.byte $42
>2715	3e					.byte $3e
>2716	3c					.byte $3c
>2717	34					.byte $34
>2718	32					.byte $32
>2719	3e					.byte $3e
>271a	33					.byte $33
>271b	04					.byte $04
>271c	89					.byte $89
>271d	96					.byte $96
>271e	7c					.byte $7c
>271f	7d					.byte $7d
>2720	7e					.byte $7e
>2721	7f					.byte $7f
>2722	80					.byte $80
>2723	0a					.byte $0a
>2724	06					.byte $06
>2725	04					.byte $04
>2726	c2					.byte $c2
>2727	54					.byte $54
>2728	3b					.byte $3b
>2729	3e					.byte $3e
>272a	3e					.byte $3e
>272b	0f					.byte $0f
>272c	80					.byte $80
>272d	0d					.byte $0d
>272e	10					.byte $10
>272f	04					.byte $04
>2730	31					.byte $31
>2731	3c					.byte $3c
>2732	08					.byte $08
>2733	3b					.byte $3b
>2734	3e					.byte $3e
>2735	3e					.byte $3e
>2736	0f					.byte $0f
>2737	8a					.byte $8a
>2738	74					.byte $74
>2739	80					.byte $80
>273a	0b					.byte $0b
>273b	1a					.byte $1a
>273c	04					.byte $04
>273d	31					.byte $31
>273e	34					.byte $34
>273f	10					.byte $10
>2740	3b					.byte $3b
>2741	3e					.byte $3e
>2742	3e					.byte $3e
>2743	0f					.byte $0f
>2744	80					.byte $80
>2745	0e					.byte $0e
>2746	24					.byte $24
>2747	04					.byte $04
>2748	42					.byte $42
>2749	43					.byte $43
>274a	19					.byte $19
>274b	96					.byte $96
>274c	73					.byte $73
>274d	75					.byte $75
>274e	72					.byte $72
>274f	74					.byte $74
>2750	ac					.byte $ac
>2751	17					.byte $17
>2752	80					.byte $80
>2753	0a					.byte $0a
>2754	2e					.byte $2e
>2755	04					.byte $04
>2756	42					.byte $42
>2757	43					.byte $43
>2758	19					.byte $19
>2759	96					.byte $96
>275a	72					.byte $72
>275b	74					.byte $74
>275c	80					.byte $80
>275d	0c					.byte $0c
>275e	38					.byte $38
>275f	04					.byte $04
>2760	42					.byte $42
>2761	43					.byte $43
>2762	19					.byte $19
>2763	96					.byte $96
>2764	73					.byte $73
>2765	75					.byte $75
>2766	72					.byte $72
>2767	74					.byte $74
>2768	80					.byte $80
>2769	0c					.byte $0c
>276a	42					.byte $42
>276b	04					.byte $04
>276c	42					.byte $42
>276d	43					.byte $43
>276e	19					.byte $19
>276f	96					.byte $96
>2770	72					.byte $72
>2771	74					.byte $74
>2772	ac					.byte $ac
>2773	17					.byte $17
>2774	80					.byte $80
>2775	07					.byte $07
>2776	4c					.byte $4c
>2777	04					.byte $04
>2778	43					.byte $43
>2779	30					.byte $30
>277a	17					.byte $17
>277b	80					.byte $80
>277c	0f					.byte $0f
>277d	56					.byte $56
>277e	04					.byte $04
>277f	3f					.byte $3f
>2780	37					.byte $37
>2781	0f					.byte $0f
>2782	c1					.byte $c1
>2783	3f					.byte $3f
>2784	37					.byte $37
>2785	00					.byte $00
>2786	c1					.byte $c1
>2787	38					.byte $38
>2788	3d					.byte $3d
>2789	17					.byte $17
>278a	80					.byte $80
>278b	0a					.byte $0a
>278c	60					.byte $60
>278d	04					.byte $04
>278e	31					.byte $31
>278f	38					.byte $38
>2790	13					.byte $13
>2791	af					.byte $af
>2792	7e					.byte $7e
>2793	7f					.byte $7f
>2794	80					.byte $80
>2795	0f					.byte $0f
>2796	6a					.byte $6a
>2797	04					.byte $04
>2798	39					.byte $39
>2799	42					.byte $42
>279a	11					.byte $11
>279b	42					.byte $42
>279c	3e					.byte $3e
>279d	3c					.byte $3c
>279e	34					.byte $34
>279f	32					.byte $32
>27a0	3e					.byte $3e
>27a1	33					.byte $33
>27a2	04					.byte $04
>27a3	80					.byte $80
>27a4	0f					.byte $0f
>27a5	74					.byte $74
>27a6	04					.byte $04
>27a7	39					.byte $39
>27a8	3c					.byte $3c
>27a9	0f					.byte $0f
>27aa	42					.byte $42
>27ab	3e					.byte $3e
>27ac	3c					.byte $3c
>27ad	34					.byte $34
>27ae	32					.byte $32
>27af	3e					.byte $3e
>27b0	33					.byte $33
>27b1	04					.byte $04
>27b2	80					.byte $80
>27b3	11					.byte $11
>27b4	7e					.byte $7e
>27b5	04					.byte $04
>27b6	39					.byte $39
>27b7	3c					.byte $3c
>27b8	0f					.byte $0f
>27b9	95					.byte $95
>27ba	42					.byte $42
>27bb	3e					.byte $3e
>27bc	3c					.byte $3c
>27bd	34					.byte $34
>27be	32					.byte $32
>27bf	3e					.byte $3e
>27c0	33					.byte $33
>27c1	04					.byte $04
>27c2	ae					.byte $ae
>27c3	80					.byte $80
>27c4	13					.byte $13
>27c5	88					.byte $88
>27c6	04					.byte $04
>27c7	39					.byte $39
>27c8	3c					.byte $3c
>27c9	0f					.byte $0f
>27ca	95					.byte $95
>27cb	42					.byte $42
>27cc	3e					.byte $3e
>27cd	3c					.byte $3c
>27ce	34					.byte $34
>27cf	32					.byte $32
>27d0	3e					.byte $3e
>27d1	33					.byte $33
>27d2	04					.byte $04
>27d3	ac					.byte $ac
>27d4	17					.byte $17
>27d5	ae					.byte $ae
>27d6	80					.byte $80
>27d7	15					.byte $15
>27d8	92					.byte $92
>27d9	04					.byte $04
>27da	38					.byte $38
>27db	3d					.byte $3d
>27dc	02					.byte $02
>27dd	c1					.byte $c1
>27de	33					.byte $33
>27df	34					.byte $34
>27e0	02					.byte $02
>27e1	c1					.byte $c1
>27e2	38					.byte $38
>27e3	3d					.byte $3d
>27e4	02					.byte $02
>27e5	00					.byte $00
>27e6	c1					.byte $c1
>27e7	33					.byte $33
>27e8	34					.byte $34
>27e9	02					.byte $02
>27ea	00					.byte $00
>27eb	80					.byte $80
>27ec	0b					.byte $0b
>27ed	9c					.byte $9c
>27ee	04					.byte $04
>27ef	39					.byte $39
>27f0	3c					.byte $3c
>27f1	0f					.byte $0f
>27f2	3b					.byte $3b
>27f3	3e					.byte $3e
>27f4	3e					.byte $3e
>27f5	0f					.byte $0f
>27f6	80					.byte $80
>27f7	05					.byte $05
>27f8	a6					.byte $a6
>27f9	04					.byte $04
>27fa	b2					.byte $b2
>27fb	80					.byte $80
>27fc	19					.byte $19
>27fd	b0					.byte $b0
>27fe	04					.byte $04
>27ff	c8					.byte $c8
>2800	c0					.byte $c0
>2801	60					.byte $60
>2802	08					.byte $08
>2803	4c					.byte $4c
>2804	4f					.byte $4f
>2805	4f					.byte $4f
>2806	50					.byte $50
>2807	3d					.byte $3d
>2808	00					.byte $00
>2809	ac					.byte $ac
>280a	3b					.byte $3b
>280b	3e					.byte $3e
>280c	3e					.byte $3e
>280d	0f					.byte $0f
>280e	ac					.byte $ac
>280f	54					.byte $54
>2810	3b					.byte $3b
>2811	3e					.byte $3e
>2812	3e					.byte $3e
>2813	0f					.byte $0f
>2814	80					.byte $80
>2815	00					.byte $00

;******  Return to file: basic.asm


;******  End of listing
