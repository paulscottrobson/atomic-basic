
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -q --m65xx -L asm.out/basic.lst -l asm.out/basic.lbl -o asm.out/basic.prg basic.asm
; Sat Dec 12 14:36:34 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: boot/x16/01constants.inc

=8							DataStackSize = 8
=16							HashTableSize = 16
=$00							ZeroPageStart = $00
=$20							DataStackStart = $20
=$800							DataStart = $800					; must be on a page boundary.
=$1000							CodeBase = $1000
=$9e00							EndMemory = $9E00

;******  Return to file: basic.asm


;******  Processing file: boot/common/02data.inc

>0000					codePtr:.fill 		3 						; code ptr - extra byte for paging.
>0003					tempShort:.fill 	1 						; used for v.short term saving.
>0004					temp0:	.fill 		2
>0006					temp1:	.fill 		2
>0008					temp2:	.fill 		2
>000a					temp3:	.fill 		2
>000c					temp4:	.fill 		2
>000e					StackPtr:.fill 		2						; highest byte allocated, stack works down.
>0010					LowMemory:.fill 	2 						; next byte available working up
>0020					esType:	.fill 		DataStackSize 			; bit 7 any reference, bit 6 byte reference, bit 0 string.
>0028					esInt0:	.fill 		DataStackSize		 	; 32 bit integer, also used for string address
>0030					esInt1:	.fill 		DataStackSize			; (16 bit only)
>0038					esInt2:	.fill 		DataStackSize
>0040					esInt3:	.fill 		DataStackSize
=$28					esStrLow = esInt0 							; String address synonym
=$30					esStrHigh = esInt1
>0800							.align 	256  						; these two must be on one page.
.0800					RootVariables:
>0800							.fill 	26*4
.0868					HashTable:
>0868							.fill 	HashTableSize*2
.0888					Seed32:
>0888							.fill 	4
.088c					Buffer:
>088c							.fill 	20
.08a0					ClockTicks:
>08a0							.fill 	4
.08a4					IToSCount:
>08a4							.fill 	1
.08a5					ChrBuffer:
>08a5							.fill 	2
.08a7					PrintCRFlag:
>08a7							.fill 	1
.08a8					ArrayEnabled:
>08a8							.fill 	1
.08a9					ProcTable:
>08a9							.fill 	2
.08ab					ParamCount:
>08ab							.fill 	1

;******  Return to file: basic.asm


;******  Processing file: boot/common/03stdmac.inc


;******  Return to file: basic.asm


;******  Processing file: boot/common/boot.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; initialise 6502 stac
.1002	9a		txs				txs
.1003	4c 06 10	jmp $1006			jmp 	ColdStart

;******  Return to file: basic.asm


;******  Processing file: interface/none/ifdummy.asm

.1006					ColdStart:
.1006	4c b1 13	jmp $13b1			jmp 	Command_RUN
.1009					WarmStart:
.1009	4c 09 10	jmp $1009			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: common/generated/keywords.inc

=$80					KWD_LESSLESSENDGREATERGREATER        = $80 ; 128
=$81					KWD_AND                              = $81 ; 129
=$82					KWD_OR                               = $82 ; 130
=$83					KWD_XOR                              = $83 ; 131
=$84					KWD_GREATER                          = $84 ; 132
=$85					KWD_LESS                             = $85 ; 133
=$86					KWD_GREATEREQUAL                     = $86 ; 134
=$87					KWD_LESSEQUAL                        = $87 ; 135
=$88					KWD_LESSGREATER                      = $88 ; 136
=$89					KWD_EQUAL                            = $89 ; 137
=$8a					KWD_PLUS                             = $8a ; 138
=$8b					KWD_MINUS                            = $8b ; 139
=$8c					KWD_ASTERISK                         = $8c ; 140
=$8d					KWD_SLASH                            = $8d ; 141
=$8e					KWD_PERCENT                          = $8e ; 142
=$8f					KWD_GREATERGREATER                   = $8f ; 143
=$90					KWD_LESSLESS                         = $90 ; 144
=$91					KWD_PLING                            = $91 ; 145
=$92					KWD_QUESTION                         = $92 ; 146
=$93					KWD_DOLLAR                           = $93 ; 147
=$94					KWD_TILDE                            = $94 ; 148
=$95					KWD_LPAREN                           = $95 ; 149
=$96					KWD_AMPERSAND                        = $96 ; 150
=$97					KWD_AT                               = $97 ; 151
=$98					KWD_LEN                              = $98 ; 152
=$99					KWD_SGN                              = $99 ; 153
=$9a					KWD_ABS                              = $9a ; 154
=$9b					KWD_RANDOM                           = $9b ; 155
=$9c					KWD_PAGE                             = $9c ; 156
=$9d					KWD_TRUE                             = $9d ; 157
=$9e					KWD_FALSE                            = $9e ; 158
=$9f					KWD_MIN                              = $9f ; 159
=$a0					KWD_MAX                              = $a0 ; 160
=$a1					KWD_SYS                              = $a1 ; 161
=$a2					KWD_CODE                             = $a2 ; 162
=$a3					KWD_TIMER                            = $a3 ; 163
=$a4					KWD_EVENT                            = $a4 ; 164
=$a5					KWD_GET                              = $a5 ; 165
=$a6					KWD_JOYPERIODX                       = $a6 ; 166
=$a7					KWD_JOYPERIODY                       = $a7 ; 167
=$a8					KWD_JOYPERIODBTN                     = $a8 ; 168
=$a9					KWD_INKEY                            = $a9 ; 169
=$aa					KWD_ALLOC                            = $aa ; 170
=$ab					KWD_CHR                              = $ab ; 171
=$ac					KWD_COMMA                            = $ac ; 172
=$ad					KWD_SEMICOLON                        = $ad ; 173
=$ae					KWD_RPAREN                           = $ae ; 174
=$af					KWD_PLUSPLUS                         = $af ; 175
=$b0					KWD_MINUSMINUS                       = $b0 ; 176
=$b1					KWD_LSQPAREN                         = $b1 ; 177
=$b2					KWD_RSQPAREN                         = $b2 ; 178
=$b3					KWD_IF                               = $b3 ; 179
=$b4					KWD_FOR                              = $b4 ; 180
=$b5					KWD_REPEAT                           = $b5 ; 181
=$b6					KWD_PROC                             = $b6 ; 182
=$b7					KWD_WHILE                            = $b7 ; 183
=$b8					KWD_ENDIF                            = $b8 ; 184
=$b9					KWD_NEXT                             = $b9 ; 185
=$ba					KWD_UNTIL                            = $ba ; 186
=$bb					KWD_ENDPROC                          = $bb ; 187
=$bc					KWD_WEND                             = $bc ; 188
=$bd					KWD_REM                              = $bd ; 189
=$be					KWD_LET                              = $be ; 190
=$bf					KWD_SQUOTE                           = $bf ; 191
=$c0					KWD_COLON                            = $c0 ; 192
=$c1					KWD_THEN                             = $c1 ; 193
=$c2					KWD_ELSE                             = $c2 ; 194
=$c3					KWD_TO                               = $c3 ; 195
=$c4					KWD_STEP                             = $c4 ; 196
=$c5					KWD_VDU                              = $c5 ; 197
=$c6					KWD_PRINT                            = $c6 ; 198
=$c7					KWD_CALL                             = $c7 ; 199
=$c8					KWD_LOCAL                            = $c8 ; 200
=$c9					KWD_GOTO                             = $c9 ; 201
=$ca					KWD_GOSUB                            = $ca ; 202
=$cb					KWD_RETURN                           = $cb ; 203
=$cc					KWD_ASSERT                           = $cc ; 204
=$cd					KWD_STOP                             = $cd ; 205
=$ce					KWD_END                              = $ce ; 206
=$cf					KWD_DIM                              = $cf ; 207
=$d0					KWD_CLEAR                            = $d0 ; 208
=$d1					KWD_LOAD                             = $d1 ; 209
=$d2					KWD_SAVE                             = $d2 ; 210
=$d3					KWD_LIST                             = $d3 ; 211
=$d4					KWD_NEW                              = $d4 ; 212
=$d5					KWD_RUN                              = $d5 ; 213

;******  Return to file: basic.asm


;******  Processing file: common/math/intmacros.inc


;******  Return to file: basic.asm


;******  Processing file: common/utility/stack.inc

=$14					SMGosub = $14 								; gosub marker (4 bytes, marker + position)
=$24					SMRepeat = $24 								; repeat marker (4 bytes, marker + position)
=$34					SMWhile = $34 								; while marker (4 bytes, marker + position)
=$4b					SMFor = $4B 								; for marker (11 bytes, see for.asm)
=$54					SMProcedure = $54 							; procedure marker (4 bytes, marker + position)
=$67					SMLocal = $67 								; local marker (7 bytes, marker, address, data)
=$0f					StackSizeMask = $0F 						; converts marker to bytes required.

;******  Return to file: basic.asm


;******  Processing file: common/commands/assert.asm

.100c					Command_Assert:
.100c	20 38 16	jsr $1638			jsr 	EvaluateBaseDeRef			; evaluate the thing being asserted.
.100f	20 23 1e	jsr $1e23			jsr 	Int32Zero 					; check if zero
.1012	f0 01		beq $1015			beq 	_CAError
.1014	60		rts				rts
.1015					_CAError:
.1015	4c 38 19	jmp $1938			jmp 	EHandlerAssert

;******  Return to file: basic.asm


;******  Processing file: common/commands/clear.asm

.1018					FindEnd:
.1018	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.101a	85 04		sta $04				sta 	temp0
.101c	a9 23		lda #$23			lda 	#(BasicProgram) >> 8
.101e	85 05		sta $05				sta 	1+(temp0)
.1020	98		tya				tya
.1021	48		pha				pha
.1022	a0 00		ldy #$00	_FELoop:ldy 	#0 							; look at offset
.1024	b1 04		lda ($04),y			lda 	(temp0),y
.1026	f0 0c		beq $1034			beq 	_FEExit 					; end if zero
.1028	18		clc				clc 								; add to position.
.1029	65 04		adc $04				adc 	temp0
.102b	85 04		sta $04				sta 	temp0
.102d	90 f3		bcc $1022			bcc 	_FELoop
.102f	e6 05		inc $05				inc 	temp0+1
.1031	4c 22 10	jmp $1022			jmp 	_FELoop
.1034					_FEExit:
.1034	68		pla				pla
.1035	a8		tay				tay
.1036	60		rts				rts
.1037					CommandClear:
.1037	8a		txa				txa
.1038	48		pha				pha
.1039	20 18 10	jsr $1018			jsr 	FindEnd 					; find end of memory
.103c	e6 04		inc $04				inc 	temp0 						; add 1, first free byte
.103e	d0 02		bne $1042			bne 	_CCSkip
.1040	e6 05		inc $05				inc 	temp0+1
.1042	a5 04		lda $04		_CCSkip:lda 	temp0 						; copy into low memory
.1044	85 10		sta $10				sta 	LowMemory
.1046	a5 05		lda $05				lda 	temp0+1
.1048	85 11		sta $11				sta 	LowMemory+1
.104a	a9 00		lda #$00			lda 	#(EndMemory) & $FF
.104c	85 0e		sta $0e				sta 	StackPtr
.104e	a9 9e		lda #$9e			lda 	#(EndMemory) >> 8
.1050	85 0f		sta $0f				sta 	1+(StackPtr)
.1052	a2 00		ldx #$00			ldx 	#0 							; blank hash table
.1054	8a		txa				txa
.1055					_CCErase:
.1055	9d 68 08	sta $0868,x			sta 	HashTable,x
.1058	e8		inx				inx
.1059	e0 20		cpx #$20			cpx 	#HashTableSize*2
.105b	d0 f8		bne $1055			bne 	_CCErase
.105d	a9 01		lda #$01			lda		#1 							; array works.
.105f	8d a8 08	sta $08a8			sta 	ArrayEnabled
.1062	68		pla				pla
.1063	aa		tax				tax
.1064	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/dim.asm

.1065					Command_Dim:
.1065	a9 00		lda #$00			lda 	#0 							; stops the term decoding array dim a(5) would return ref
.1067	8d a8 08	sta $08a8			sta 	ArrayEnabled 				; to A(5) otherwise :)
.106a	a9 07		lda #$07			lda 	#7							; get a term
.106c	aa		tax				tax
.106d	20 48 16	jsr $1648			jsr 	EvaluateLevelAX
.1070	b5 20		lda $20,x			lda 	esType,x 					; get type
.1072	c9 80		cmp #$80			cmp 	#$80 						; it must be an integer reference.
.1074	d0 47		bne $10bd			bne 	_CDSyntax
.1076	8d a8 08	sta $08a8			sta 	ArrayEnabled 				; reenable normal array behaviour.
.1079	b5 28		lda $28,x			lda 	esInt0,x 					; get variable addr -> temp0
.107b	85 04		sta $04				sta 	temp0
.107d	b5 30		lda $30,x			lda 	esInt1,x
.107f	85 05		sta $05				sta 	temp0+1
.1081	98		tya				tya
.1082	48		pha				pha
.1083	a0 00		ldy #$00			ldy 	#0
.1085	a5 10		lda $10				lda 	LowMemory
.1087	91 04		sta ($04),y			sta 	(temp0),y
.1089	c8		iny				iny
.108a	a5 11		lda $11				lda 	LowMemory+1
.108c	91 04		sta ($04),y			sta 	(temp0),y
.108e	c8		iny				iny
.108f	a9 00		lda #$00			lda 	#0
.1091	91 04		sta ($04),y			sta 	(temp0),y
.1093	c8		iny				iny
.1094	91 04		sta ($04),y			sta 	(temp0),y
.1096	68		pla				pla
.1097	a8		tay				tay
.1098	20 38 14	jsr $1438			jsr 	CheckLeftParen 				; get left bracket
.109b	20 3e 16	jsr $163e			jsr 	EvaluateTOSDeref 			; get the size to dimension
.109e	20 4a 14	jsr $144a			jsr 	CheckRightParen 			; do the right hand parenthesis
.10a1	b5 40		lda $40,x			lda 	esInt3,x 					; if -ve do not process.
.10a3	30 0c		bmi $10b1			bmi 	_CDNoSizeCalc
.10a5	f6 28		inc $28,x			inc 	esInt0,x 					; increment size by 1 (zero base so dim a(10) is 11 elements)
.10a7	d0 02		bne $10ab			bne 	_CDNoBump
.10a9	f6 30		inc $30,x			inc 	esInt1,x
.10ab					_CDNoBump:
.10ab	20 11 1e	jsr $1e11			jsr 	Int32ShiftLeft 				; x 4 (count => bytes)
.10ae	20 11 1e	jsr $1e11			jsr 	Int32ShiftLeft
.10b1					_CDNoSizeCalc:
.10b1	20 c0 10	jsr $10c0			jsr 	AllocMemStackCount 			; allocate that many bytes as per TOS.
.10b4	b1 00		lda ($00),y			lda 	(codePtr),y
.10b6	c8		iny				iny
.10b7	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; check if comma follows.
.10b9	f0 aa		beq $1065			beq 	Command_DIM 				; if so do more DIM.
.10bb	88		dey				dey
.10bc					_CDExit:
.10bc	60		rts				rts
.10bd					_CDSyntax:
.10bd	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax
.10c0					AllocMemStackCount:
.10c0	b5 40		lda $40,x			lda 	esInt3,x 					; if -ve do not advance lowmem pointer
.10c2	30 19		bmi $10dd			bmi 	_AMSCExit
.10c4	d0 18		bne $10de			bne 	AllocError 					; otherwise 2 MSB must be zero, 64k RAM space.
.10c6	b5 38		lda $38,x			lda 	esInt2,x
.10c8	d0 14		bne $10de			bne 	AllocError
.10ca	18		clc				clc
.10cb	b5 28		lda $28,x			lda 	esInt0,x 					; add size to pos.
.10cd	65 10		adc $10				adc 	LowMemory
.10cf	85 10		sta $10				sta 	LowMemory
.10d1	b5 30		lda $30,x			lda 	esInt1,x
.10d3	65 11		adc $11				adc 	LowMemory+1
.10d5	85 11		sta $11				sta 	LowMemory+1
.10d7	b0 05		bcs $10de			bcs 	AllocError 					; overflow.
.10d9	c5 0f		cmp $0f				cmp 	StackPtr+1 					; got into SP page.
.10db	b0 01		bcs $10de			bcs 	AllocError
.10dd					_AMSCExit:
.10dd	60		rts				rts
.10de					AllocError:
.10de	4c ba 19	jmp $19ba			jmp 	EHandlerMemory

;******  Return to file: basic.asm


;******  Processing file: common/commands/for.asm

.10e1					Command_FOR:
.10e1	a9 4b		lda #$4b			lda 	#SMFor 						; allocate the space.
.10e3	20 67 20	jsr $2067			jsr 	StackOpen
.10e6	20 6b 12	jsr $126b			jsr 	Command_LET 				; do the same as LET.
.10e9	20 44 14	jsr $1444			jsr 	CheckTO 					; check TO something.
.10ec	a2 01		ldx #$01			ldx 	#1 							; keep the variable address in stack 0
.10ee	20 3e 16	jsr $163e			jsr 	EvaluateTOSDeRef			; get terminal value in stack 1
.10f1	98		tya				tya
.10f2	48		pha				pha
.10f3	a0 04		ldy #$04			ldy 	#4
.10f5	a5 28		lda $28				lda		esInt0 						; the address of the index into 4 and 5
.10f7	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10f9	c8		iny				iny
.10fa	a5 30		lda $30				lda		esInt1
.10fc	91 0e		sta ($0e),y			sta 	(StackPtr),y
.10fe	c8		iny				iny
.10ff	a9 01		lda #$01			lda 	#1  						; the default step in 6
.1101	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1103	c8		iny				iny
.1104	a5 29		lda $29				lda		esInt0+1 					; terminal value in 7 to 11.
.1106	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1108	c8		iny				iny
.1109	a5 31		lda $31				lda		esInt1+1
.110b	91 0e		sta ($0e),y			sta 	(StackPtr),y
.110d	c8		iny				iny
.110e	a5 39		lda $39				lda		esInt2+1
.1110	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1112	c8		iny				iny
.1113	a5 41		lda $41				lda		esInt3+1
.1115	91 0e		sta ($0e),y			sta 	(StackPtr),y
.1117	68		pla				pla
.1118	a8		tay				tay
.1119	b1 00		lda ($00),y			lda 	(codePtr),y 				; followed by STEP.
.111b	c9 c4		cmp #$c4			cmp 	#KWD_STEP
.111d	d0 0e		bne $112d			bne 	_CFDone
.111f	c8		iny				iny									; skip over step.
.1120	20 3e 16	jsr $163e			jsr 	EvaluateTOSDeref 			; get step
.1123	98		tya				tya
.1124	48		pha				pha
.1125	b5 28		lda $28,x			lda 	esInt0,x 					; copy it into step (bit lazy here)
.1127	a0 06		ldy #$06			ldy 	#6
.1129	91 0e		sta ($0e),y			sta 	(StackPtr),y
.112b	68		pla				pla
.112c	a8		tay				tay
.112d					_CFDone:
.112d	20 bb 20	jsr $20bb			jsr 	StackSavePosition 			; save position.
.1130	60		rts				rts
.1131					Command_NEXT:
.1131	a9 4b		lda #$4b			lda 	#SMFor 						; check NEXT
.1133	20 8c 20	jsr $208c			jsr 	StackCheck
.1136	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it NEXT <index>
.1138	30 1e		bmi $1158			bmi 	_CNNoIndex
.113a	c9 60		cmp #$60			cmp 	#$60
.113c	b0 1a		bcs $1158			bcs 	_CNNoIndex
.113e	a2 00		ldx #$00			ldx 	#0 							; start on stack
.1140	a9 07		lda #$07			lda 	#7  						; get a term
.1142	20 48 16	jsr $1648			jsr 	EvaluateLevelAX 			; this is the variable/parameter to localise.
.1145	98		tya				tya
.1146	48		pha				pha
.1147	a0 04		ldy #$04			ldy 	#4 							; check same variable
.1149	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.114b	d5 28		cmp $28,x			cmp 	esInt0,x
.114d	d0 72		bne $11c1			bne 	_CNBadIndex
.114f	c8		iny				iny
.1150	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.1152	d5 30		cmp $30,x			cmp 	esInt1,x
.1154	d0 6b		bne $11c1			bne 	_CNBadIndex
.1156	68		pla				pla
.1157	a8		tay				tay
.1158					_CNNoIndex:
.1158	98		tya				tya
.1159	48		pha				pha
.115a	a0 04		ldy #$04			ldy 	#4 							; make temp0 point to the index
.115c	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.115e	85 04		sta $04				sta 	temp0
.1160	c8		iny				iny
.1161	b1 0e		lda ($0e),y			lda 	(StackPtr),y
.1163	85 05		sta $05				sta 	temp0+1
.1165	c8		iny				iny
.1166	a2 00		ldx #$00			ldx 	#0 							; X is the sign of the step.
.1168	b1 0e		lda ($0e),y			lda 	(StackPtr),y 				; get the step.
.116a	85 09		sta $09				sta 	temp2+1 					; save for later.
.116c	10 01		bpl $116f			bpl 	_CNSignX
.116e	ca		dex				dex
.116f					_CNSignX:
.116f	18		clc				clc 								; add to the LSB
.1170	a0 00		ldy #$00			ldy 	#0
.1172	71 04		adc ($04),y			adc 	(temp0),y
.1174	91 04		sta ($04),y			sta 	(temp0),y
.1176					_CNPropogate:
.1176	c8		iny				iny  								; add the sign extended in X to the rest.
.1177	8a		txa				txa
.1178	71 04		adc ($04),y			adc 	(temp0),y
.117a	91 04		sta ($04),y			sta 	(temp0),y
.117c	c8		iny				iny
.117d	8a		txa				txa
.117e	71 04		adc ($04),y			adc 	(temp0),y
.1180	91 04		sta ($04),y			sta 	(temp0),y
.1182	c8		iny				iny
.1183	8a		txa				txa
.1184	71 04		adc ($04),y			adc 	(temp0),y
.1186	91 04		sta ($04),y			sta 	(temp0),y
.1188	18		clc				clc 								; point temp1 to the terminal value.
.1189	a5 0e		lda $0e				lda 	StackPtr
.118b	69 07		adc #$07			adc 	#7
.118d	85 06		sta $06				sta 	temp1
.118f	a9 00		lda #$00			lda 	#0
.1191	85 08		sta $08				sta 	temp2 						; clear temp2, which is the OR of all the subtractions.
.1193	a8		tay				tay 								; and clear the Y register again.
.1194	65 0f		adc $0f				adc 	StackPtr+1
.1196	85 07		sta $07				sta 	temp1+1
.1198	38		sec				sec 								; calculate current - limit oring interim values.
.1199	20 cb 11	jsr $11cb			jsr 	_CNCompare
.119c	20 cb 11	jsr $11cb			jsr 	_CNCompare
.119f	20 cb 11	jsr $11cb			jsr 	_CNCompare
.11a2	20 cb 11	jsr $11cb			jsr 	_CNCompare
.11a5	50 02		bvc $11a9			bvc 	_CNNoOverflow 				; converts to a signed comparison on the sign bit.
.11a7	49 80		eor #$80			eor 	#$80
.11a9					_CNNoOverflow:
.11a9	a4 09		ldy $09				ldy 	temp2+1						; get step back
.11ab	30 17		bmi $11c4			bmi 	_CNCheckDownto
.11ad	c9 00		cmp #$00			cmp 	#0
.11af	30 0a		bmi $11bb			bmi 	_CNLoopRound 				; loop round if < =
.11b1	a5 08		lda $08				lda 	temp2
.11b3	f0 06		beq $11bb			beq 	_CNLoopRound
.11b5					_CNLoopExit:
.11b5	68		pla				pla
.11b6	a8		tay				tay
.11b7	20 97 20	jsr $2097			jsr		StackClose 					; delete from stack and continue
.11ba	60		rts				rts
.11bb					_CNLoopRound:
.11bb	68		pla				pla
.11bc	a8		tay				tay
.11bd	20 ab 20	jsr $20ab			jsr 	StackLoadPosition			; go back to the loop top
.11c0	60		rts				rts
.11c1					_CNBadIndex:
.11c1	4c 5c 19	jmp $195c			jmp 	EHandlerBadIndex
.11c4					_CNCheckDownto:
.11c4	c9 00		cmp #$00			cmp 	#0
.11c6	10 f3		bpl $11bb			bpl 	_CNLoopRound
.11c8	4c b5 11	jmp $11b5			jmp 	_CNLoopExit
.11cb					_CNCompare:
.11cb	b1 04		lda ($04),y			lda 	(temp0),y 					; do the subtraction - compare don't care about answer
.11cd	f1 06		sbc ($06),y			sbc 	(temp1),y
.11cf	05 08		ora $08				ora 	temp2 						; Or into temp2 (does not affect carry)
.11d1	85 08		sta $08				sta 	temp2
.11d3	c8		iny				iny
.11d4	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/gosub.asm

.11d5					Command_Gosub:
.11d5	20 38 16	jsr $1638			jsr 	EvaluateBaseDeRef			; get the target line #
.11d8	a9 14		lda #$14			lda 	#SMGosub 					; gosub marker allocate 4 bytes.
.11da	20 67 20	jsr $2067			jsr 	StackOpen 					; create on stack.
.11dd	20 bb 20	jsr $20bb			jsr 	StackSavePosition 			; save position.
.11e0	4c f7 11	jmp $11f7			jmp 	GotoTOS 					; and use the GOTO code.
.11e3					Command_Return:
.11e3	a9 14		lda #$14			lda 	#SMGosub 					; check the stack matches
.11e5	20 8c 20	jsr $208c			jsr 	StackCheck
.11e8	d0 07		bne $11f1			bne 	_RTError
.11ea	20 ab 20	jsr $20ab			jsr 	StackLoadPosition 			; load the position back
.11ed	20 97 20	jsr $2097			jsr 	StackClose 					; close the frame.
.11f0	60		rts				rts
.11f1					_RTError:
.11f1	4c de 19	jmp $19de			jmp 	EHandlerNoGosub

;******  Return to file: basic.asm


;******  Processing file: common/commands/goto.asm

.11f4					Command_Goto:
.11f4	20 38 16	jsr $1638			jsr 	EvaluateBaseDeRef			; get the target line #
.11f7					GotoTOS:
.11f7	20 0a 12	jsr $120a			jsr 	FindGoto
.11fa	90 0b		bcc $1207			bcc 	GotoError 					; not found
.11fc	a5 04		lda $04				lda		temp0 						; copy new line address
.11fe	85 00		sta $00				sta 	codePtr
.1200	a5 05		lda $05				lda 	temp0+1
.1202	85 01		sta $01				sta 	codePtr+1
.1204	a0 03		ldy #$03			ldy 	#3 							; first token.
.1206	60		rts				rts
.1207					GotoError:
.1207	4c aa 19	jmp $19aa			jmp 	EHandlerLineNumber
.120a					FindGoto:
.120a	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.120c	85 04		sta $04				sta 	temp0
.120e	a9 23		lda #$23			lda 	#(BasicProgram) >> 8
.1210	85 05		sta $05				sta 	1+(temp0)
.1212					_FGLoop:
.1212	a0 00		ldy #$00			ldy 	#0 							; look at link
.1214	b1 04		lda ($04),y			lda 	(temp0),y
.1216	18		clc				clc
.1217	f0 0f		beq $1228			beq 	_FGExit
.1219	c8		iny				iny 								; compare line.low
.121a	b1 04		lda ($04),y			lda 	(temp0),y
.121c	d5 28		cmp $28,x			cmp 	esInt0,x
.121e	d0 09		bne $1229			bne 	_FGNext
.1220	c8		iny				iny 								; compare line.high
.1221	b1 04		lda ($04),y			lda 	(temp0),y
.1223	d5 30		cmp $30,x			cmp 	esInt1,x
.1225	d0 02		bne $1229			bne 	_FGNext
.1227	38		sec				sec
.1228					_FGExit:
.1228	60		rts				rts
.1229					_FGNext:
.1229	a0 00		ldy #$00			ldy 	#0
.122b	18		clc				clc
.122c	b1 04		lda ($04),y			lda 	(temp0),y
.122e	65 04		adc $04				adc 	temp0
.1230	85 04		sta $04				sta 	temp0
.1232	90 de		bcc $1212			bcc 	_FGLoop
.1234	e6 05		inc $05				inc 	temp0+1
.1236	4c 12 12	jmp $1212			jmp 	_FGLoop

;******  Return to file: basic.asm


;******  Processing file: common/commands/if.asm

.1239					Command_IF:
.1239	20 38 16	jsr $1638			jsr 	EvaluateBaseDeRef			; get the target address
.123c	b1 00		lda ($00),y			lda 	(codePtr),y 				; is it followed by THEN ?
.123e	c9 c1		cmp #$c1			cmp 	#KWD_THEN
.1240	d0 15		bne $1257			bne 	StructureIF
.1242	c8		iny				iny 								; skip THEN
.1243	20 23 1e	jsr $1e23			jsr 	Int32Zero 					; is it true ?
.1246	f0 0c		beq $1254			beq 	_IfFalse
.1248	b1 00		lda ($00),y			lda 	(codePtr),y 				; if THEN <const> do GOTO.
.124a	30 04		bmi $1250			bmi 	_CIFExit
.124c	c9 70		cmp #$70			cmp 	#$70
.124e	b0 01		bcs $1251			bcs 	_CIFGoto
.1250					_CIFExit:
.1250	60		rts				rts 								; otherwise carry on.
.1251					_CIFGoto:
.1251	4c f4 11	jmp $11f4			jmp 	Command_GOTO
.1254					_IfFalse:
.1254	4c d2 13	jmp $13d2			jmp 	CommandNextLine
.1257					StructureIF:
.1257	20 23 1e	jsr $1e23			jsr 	Int32Zero 					; is it true ?
.125a	f0 01		beq $125d			beq 	_SIFSkip 					; if non-zero then skip to ELSE/ENDIF
.125c	60		rts				rts 								; else continue.
.125d					_SIFSkip:
.125d	a9 c2		lda #$c2			lda	 	#KWD_ELSE 					; test failed, go to ELSE or ENDIF whichever comes first.
.125f	a2 b8		ldx #$b8			ldx 	#KWD_ENDIF
.1261	4c 19 20	jmp $2019			jmp		ScanForward
.1264					Command_ELSE:
.1264	a2 b8		ldx #$b8			ldx 	#KWD_ENDIF
.1266	8a		txa				txa
.1267	4c 19 20	jmp $2019			jmp		ScanForward
.126a					Command_ENDIF:
.126a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/let.asm

.126b					Command_LET:
.126b	a2 00		ldx #$00			ldx 	#0 							; start on stack
.126d	a9 04		lda #$04			lda 	#4  						; this means ! ? and $ binary operators only work.
.126f	20 48 16	jsr $1648			jsr 	EvaluateLevelAX 			; this is the LHS
.1272	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.1274	10 2f		bpl $12a5			bpl 	_CLSyntax 					; if not, syntax error.
.1276	20 3e 14	jsr $143e			jsr 	CheckEquals 				; check equals follows.
.1279	e8		inx				inx 								; get the right hand side.
.127a	20 3e 16	jsr $163e			jsr 	EvaluateTOSDeRef
.127d	ca		dex				dex
.127e	b5 28		lda $28,x			lda 	esInt0,x 					; copy target address to temp0
.1280	85 04		sta $04				sta 	temp0
.1282	b5 30		lda $30,x			lda 	esInt1,x
.1284	85 05		sta $05				sta 	temp0+1
.1286	b5 20		lda $20,x			lda 	esType,x 					; what sort of reference ?
.1288	0a		asl a				asl 	a 							; will now be $00 integer $80 byte $02 string.
.1289	f0 22		beq $12ad			beq 	_CLIntCopy
.128b	30 1b		bmi $12a8			bmi 	_CLByteCopy
.128d	b5 29		lda $29,x			lda 	esInt0+1,x 					; source -> temp1
.128f	85 06		sta $06				sta 	temp1
.1291	b5 31		lda $31,x			lda 	esInt1+1,x
.1293	85 07		sta $07				sta 	temp1+1
.1295	98		tya				tya
.1296	48		pha				pha
.1297	a0 00		ldy #$00			ldy 	#0
.1299					_CLStringCopy:
.1299	b1 06		lda ($06),y			lda 	(temp1),y
.129b	91 04		sta ($04),y			sta 	(temp0),y
.129d	f0 03		beq $12a2			beq 	_CLCopyExit 				; copied trailing NULL
.129f	c8		iny				iny
.12a0	d0 f7		bne $1299			bne 	_CLStringCopy 				; it could run riot.
.12a2					_CLCopyExit:
.12a2	68		pla				pla
.12a3	a8		tay				tay
.12a4	60		rts				rts
.12a5					_CLSyntax:
.12a5	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax
.12a8					_CLByteCopy:
.12a8	b5 29		lda $29,x			lda 	esInt0+1,x 					; get the byte to write.
.12aa	81 04		sta ($04,x)			sta 	(temp0,x)					; write, taking advantage of X = 0
.12ac	60		rts				rts
.12ad					_CLIntCopy:
.12ad	e8		inx				inx
.12ae	20 b2 12	jsr $12b2			jsr 	CopyTOSToTemp0
.12b1	60		rts				rts
.12b2					CopyTOSToTemp0:
.12b2	98		tya				tya
.12b3	48		pha				pha
.12b4	a0 00		ldy #$00			ldy 	#0
.12b6	b5 28		lda $28,x			lda 	esInt0,x
.12b8	91 04		sta ($04),y			sta 	(temp0),y
.12ba	c8		iny				iny
.12bb	b5 30		lda $30,x			lda 	esInt1,x
.12bd	91 04		sta ($04),y			sta 	(temp0),y
.12bf	c8		iny				iny
.12c0	b5 38		lda $38,x			lda 	esInt2,x
.12c2	91 04		sta ($04),y			sta 	(temp0),y
.12c4	c8		iny				iny
.12c5	b5 40		lda $40,x			lda 	esInt3,x
.12c7	91 04		sta ($04),y			sta 	(temp0),y
.12c9	68		pla				pla
.12ca	a8		tay				tay
.12cb	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/new.asm

.12cc					Command_New:
.12cc	a9 00		lda #$00			lda 	#0 							; clear program
.12ce	8d 00 23	sta $2300			sta 	BasicProgram
.12d1	4c 37 10	jmp $1037			jmp 	CommandClear				; clear variables etc.

;******  Return to file: basic.asm


;******  Processing file: common/commands/print.asm

.12d4					Command_Print:
.12d4					_CPRLoop:
.12d4	a9 00		lda #$00			lda 	#0 							; zero the print CRFlag
.12d6					_CPRSetFlag:
.12d6	8d a7 08	sta $08a7			sta 	PrintCRFlag
.12d9	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token.
.12db	c9 80		cmp #$80			cmp 	#$80						; if EOL exit.
.12dd	f0 5d		beq $133c			beq 	_CPRExit
.12df	c9 c0		cmp #$c0			cmp 	#KWD_COLON 					; if colon exit
.12e1	f0 59		beq $133c			beq 	_CPRExit
.12e3	c9 60		cmp #$60			cmp 	#$60 						; if $60  it is a string.
.12e5	f0 38		beq $131f			beq 	_CPRString
.12e7	c9 00		cmp #$00			cmp 	#$00 						; if -ve go to token
.12e9	30 04		bmi $12ef			bmi 	_CPRToken
.12eb	c9 70		cmp #$70			cmp 	#$70 						; is it a number, if so print as decimal.
.12ed	b0 14		bcs $1303			bcs 	_CPRDecimal
.12ef					_CPRToken:
.12ef	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the token ID and skip it.
.12f1	c8		iny				iny
.12f2	c9 ad		cmp #$ad			cmp 	#KWD_SEMICOLON 				; semicolon goes to set flag which is now non zero
.12f4	f0 e0		beq $12d6			beq 	_CPRSetFlag
.12f6	c9 bf		cmp #$bf			cmp 	#KWD_SQUOTE 				; single quote is CR.
.12f8	f0 34		beq $132e			beq 	_CPRNewLine
.12fa	c9 96		cmp #$96			cmp 	#KWD_AMPERSAND 				; &x means print in hex
.12fc	f0 09		beq $1307			beq 	_CPRHexaDecimal
.12fe	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; comma is tab (possibly space)
.1300	f0 32		beq $1334			beq 	_CPRTab
.1302	88		dey				dey 								; undo the skip.
.1303					_CPRDecimal:
.1303	a9 8a		lda #$8a			lda 	#10+128
.1305	d0 3e		bne $1345			bne 	_CPRPrintInteger
.1307					_CPRHexaDecimal:
.1307	a9 10		lda #$10			lda 	#16
.1309	d0 3a		bne $1345			bne 	_CPRPrintInteger
.130b					_CPRStringExpr:
.130b	68		pla				pla 								; chuck the base.
.130c	8a		txa				txa
.130d	48		pha				pha
.130e	98		tya				tya
.130f	48		pha				pha
.1310	b4 28		ldy $28,x			ldy 	esInt0,x
.1312	b5 30		lda $30,x			lda 	esInt1,x
.1314	aa		tax				tax
.1315	20 ad 14	jsr $14ad			jsr 	PrintXYString
.1318	68		pla				pla
.1319	a8		tay				tay
.131a	68		pla				pla
.131b	aa		tax				tax
.131c	4c d4 12	jmp $12d4			jmp 	_CPRLoop
.131f					_CPRString:
.131f	c8		iny				iny 								; move to start of string.
.1320	c8		iny				iny
.1321					_CPRStringLoop:
.1321	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character and bump
.1323	c8		iny				iny
.1324	c9 00		cmp #$00			cmp 	#0 							; end of string, loop back.
.1326	f0 ac		beq $12d4			beq 	_CPRLoop
.1328	20 57 22	jsr $2257			jsr 	XTPrintA 					; print it and try next character.
.132b	4c 21 13	jmp $1321			jmp 	_CPRStringLoop
.132e					_CPRNewLine:
.132e	20 47 22	jsr $2247			jsr 	XTPrintCR
.1331	4c d4 12	jmp $12d4			jmp 	_CPRLoop
.1334					_CPRTab:
.1334	20 4f 22	jsr $224f			jsr 	XTPrintTab
.1337	a9 01		lda #$01			lda 	#1
.1339	4c d6 12	jmp $12d6			jmp 	_CPRSetFlag
.133c					_CPRExit:
.133c	ad a7 08	lda $08a7			lda 	PrintCRFlag 				; check flag.
.133f	d0 03		bne $1344			bne 	_CPRNoNL
.1341	20 47 22	jsr $2247			jsr 	XTPrintCR
.1344					_CPRNoNL:
.1344	60		rts				rts
.1345					_CPRPrintInteger:
.1345	48		pha				pha 								; save base on stack
.1346	20 38 16	jsr $1638			jsr 	EvaluateBaseDeref 			; evaluate whatever it is.
.1349	b5 20		lda $20,x			lda 	esType,x 					; is it a string expression ?
.134b	4a		lsr a				lsr 	a
.134c	b0 bd		bcs $130b			bcs 	_CPRStringExpr
.134e	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.1350	85 04		sta $04				sta 	temp0
.1352	a9 08		lda #$08			lda 	#(buffer) >> 8
.1354	85 05		sta $05				sta 	1+(temp0)
.1356	68		pla				pla
.1357	20 58 1d	jsr $1d58			jsr 	Int32ToString 				; convert in the buffer.
.135a	8a		txa				txa
.135b	48		pha				pha
.135c	a2 00		ldx #$00			ldx 	#0
.135e					_CPROutBuffer:
.135e	bd 8c 08	lda $088c,x			lda 	buffer,x
.1361	f0 06		beq $1369			beq 	_CPROBExit
.1363	20 57 22	jsr $2257			jsr 	XTPrintA
.1366	e8		inx				inx
.1367	d0 f5		bne $135e			bne 	_CPROutBuffer
.1369					_CPROBExit:
.1369	68		pla				pla
.136a	aa		tax				tax
.136b	4c d4 12	jmp $12d4			jmp 	_CPRLoop

;******  Return to file: basic.asm


;******  Processing file: common/commands/rem.asm

.136e					Command_Rem:
.136e					Command_Rem2:
.136e	b1 00		lda ($00),y			lda 	(codePtr),y
.1370	c9 80		cmp #$80			cmp 	#$80 						; end of line.
.1372	f0 0a		beq $137e			beq 	_RemExit
.1374	c9 c0		cmp #$c0			cmp 	#KWD_COLON
.1376	f0 06		beq $137e			beq 	_RemExit
.1378	20 7f 13	jsr $137f			jsr 	AdvancePointer
.137b	4c 6e 13	jmp $136e			jmp 	Command_Rem
.137e					_RemExit:
.137e	60		rts				rts
.137f					AdvancePointer:
.137f	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at token
.1381	c9 01		cmp #$01			cmp 	#$01 						; quoted string
.1383	f0 02		beq $1387			beq 	_APString
.1385	c8		iny				iny 								; advance and return.
.1386	60		rts				rts
.1387					_APString:
.1387	98		tya				tya 								; and length to position
.1388	c8		iny				iny
.1389	18		clc				clc
.138a	71 00		adc ($00),y			adc 	(codePtr),y
.138c	a8		tay				tay
.138d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/repeat.asm

.138e					Command_Repeat:
.138e	a9 24		lda #$24			lda 	#SMRepeat 					; repeat marker allocate 4 bytes.
.1390	20 67 20	jsr $2067			jsr 	StackOpen 					; create on stack.
.1393	20 bb 20	jsr $20bb			jsr 	StackSavePosition 			; save position.
.1396	60		rts				rts
.1397					Command_Until:
.1397	a9 24		lda #$24			lda 	#SMRepeat 					; check the stack matches
.1399	20 8c 20	jsr $208c			jsr 	StackCheck
.139c	d0 10		bne $13ae			bne 	_CUError
.139e	20 38 16	jsr $1638			jsr 	EvaluateBaseDeRef			; get the conditional
.13a1	20 23 1e	jsr $1e23			jsr 	Int32Zero
.13a4	f0 04		beq $13aa			beq 	_CULoopBack
.13a6	20 97 20	jsr $2097			jsr 	StackClose 					; close the frame.
.13a9	60		rts				rts
.13aa					_CULoopBack:
.13aa	20 ab 20	jsr $20ab			jsr 	StackLoadPosition			; go back until true
.13ad	60		rts				rts
.13ae					_CUError:
.13ae	4c 0e 1a	jmp $1a0e			jmp 	EHandlerNoRepeat

;******  Return to file: basic.asm


;******  Processing file: common/commands/run.asm

.13b1					Command_Run:
.13b1	20 37 10	jsr $1037			jsr 	CommandClear 				; clear variables, memory pointers, hash table.
.13b4	20 9d 1f	jsr $1f9d			jsr 	BuildProcedureList 			; build procedure cache.
.13b7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.13b9	85 00		sta $00				sta 	codePtr
.13bb	a9 23		lda #$23			lda 	#(BasicProgram) >> 8
.13bd	85 01		sta $01				sta 	1+(codePtr)
.13bf	a0 00		ldy #$00			ldy 	#0 							; check if off end of program.
.13c1	b1 00		lda ($00),y			lda 	(codePtr),y
.13c3	f0 28		beq $13ed			beq 	Command_End
.13c5	a0 03		ldy #$03			ldy 	#3 							; start at this offset.
.13c7					CommandNextCommand:
.13c7	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first token ... see if it is a token.
.13c9	10 1b		bpl $13e6			bpl 	CommandTryLet				; if not, try LET as a default.
.13cb	c8		iny				iny 								; advance past it.
.13cc	20 75 17	jsr $1775			jsr 	ExecuteCommand 				; execute the command
.13cf	4c c7 13	jmp $13c7			jmp 	CommandNextCommand
.13d2					CommandNextLine:
.13d2	a0 00		ldy #$00			ldy 	#0 							; get offset and add
.13d4	b1 00		lda ($00),y			lda 	(codePtr),y
.13d6	18		clc				clc
.13d7	65 00		adc $00				adc 	codePtr
.13d9	85 00		sta $00				sta 	codePtr
.13db	90 02		bcc $13df			bcc 	_CSLExit
.13dd	e6 01		inc $01				inc 	codePtr+1
.13df					_CSLExit:
.13df	b1 00		lda ($00),y			lda 	(codePtr),y 				; reached end of code ?
.13e1	f0 0a		beq $13ed			beq 	Command_End
.13e3	a0 03		ldy #$03			ldy 	#3 							; 3rd position next line.
.13e5	60		rts				rts
.13e6					CommandTryLet:
.13e6	20 6b 12	jsr $126b			jsr 	Command_LET
.13e9	4c c7 13	jmp $13c7			jmp 	CommandNextCommand
.13ec					Command_Colon:
.13ec	60		rts				rts
.13ed					Command_End:
.13ed	4c 09 10	jmp $1009			jmp 	WarmStart
.13f0					Command_Stop:
.13f0	4c 61 1a	jmp $1a61			jmp 	EHandlerStop

;******  Return to file: basic.asm


;******  Processing file: common/commands/vdu.asm

.13f3					Command_Vdu:
.13f3	20 38 16	jsr $1638			jsr 	EvaluateBaseDeRef			; evaluate the thing being asserted.
.13f6	b5 28		lda $28,x			lda 	esInt0,x 					; get the byte
.13f8	20 57 22	jsr $2257			jsr 	XTPrintA 					; and print it
.13fb	b1 00		lda ($00),y			lda 	(codePtr),y 				; if comma follows
.13fd	c8		iny				iny
.13fe	c9 ac		cmp #$ac			cmp 	#KWD_COMMA
.1400	f0 f1		beq $13f3			beq 	Command_Vdu 				; loop back roun.
.1402	88		dey				dey
.1403	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/commands/while.asm

.1404					Command_While:
.1404	a9 34		lda #$34			lda 	#SMWhile 					; gosub marker allocate 4 bytes.
.1406	20 67 20	jsr $2067			jsr 	StackOpen 					; create on stack.
.1409	88		dey				dey
.140a	20 bb 20	jsr $20bb			jsr 	StackSavePosition 			; save position before the WHILE.
.140d	c8		iny				iny
.140e	20 38 16	jsr $1638			jsr 	EvaluateBaseDeRef			; get the conditional
.1411	20 23 1e	jsr $1e23			jsr 	Int32Zero
.1414	f0 01		beq $1417			beq 	_CWFail
.1416	60		rts				rts
.1417					_CWFail:
.1417	20 97 20	jsr $2097			jsr 	StackClose 					; close the just opened position.
.141a	a9 bc		lda #$bc			lda 	#KWD_WEND 					; scan forward past WEND.
.141c	aa		tax				tax
.141d	20 19 20	jsr $2019			jsr 	ScanForward
.1420	60		rts				rts
.1421					Command_Wend:
.1421	a9 34		lda #$34			lda 	#SMWhile 					; check the stack matches
.1423	20 8c 20	jsr $208c			jsr 	StackCheck
.1426	d0 07		bne $142f			bne 	_CWError
.1428	20 ab 20	jsr $20ab			jsr 	StackLoadPosition			; go back until true
.142b	20 97 20	jsr $2097			jsr 	StackClose 					; close the frame.
.142e	60		rts				rts
.142f					_CWError:
.142f	4c 26 1a	jmp $1a26			jmp 	EHandlerNoWhile

;******  Return to file: basic.asm


;******  Processing file: common/errors/checksyntax.asm

.1432					CheckComma:
.1432	48		pha				pha
.1433	a9 ac		lda #$ac			lda 	#KWD_COMMA
.1435	4c 50 14	jmp $1450			jmp 	CheckSyntax
.1438					CheckLeftParen:
.1438	48		pha				pha
.1439	a9 95		lda #$95			lda 	#KWD_LPAREN
.143b	4c 50 14	jmp $1450			jmp 	CheckSyntax
.143e					CheckEquals:
.143e	48		pha				pha
.143f	a9 89		lda #$89			lda 	#KWD_EQUAL
.1441	4c 50 14	jmp $1450			jmp 	CheckSyntax
.1444					CheckTO:
.1444	48		pha				pha
.1445	a9 c3		lda #$c3			lda 	#KWD_TO
.1447	4c 50 14	jmp $1450			jmp 	CheckSyntax
.144a					CheckRightParen:
.144a	48		pha				pha
.144b	a9 ae		lda #$ae			lda 	#KWD_RPAREN
.144d	4c 50 14	jmp $1450			jmp 	CheckSyntax
.1450					CheckSyntax:
.1450	d1 00		cmp ($00),y			cmp 	(codePtr),y
.1452	d0 03		bne $1457			bne 	_CSFail
.1454	c8		iny				iny
.1455	68		pla				pla
.1456	60		rts				rts
.1457					_CSFail:
.1457	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax
.145a					NoOp1:
.145a					NoOp2:
.145a					NoOp3:
.145a					NoOp6:
.145a					NoOp7:
.145a					NoOp8:
.145a					NoOp9:
.145a	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/errors/errorhandler.asm

.145d					ErrorHandler:
.145d	84 0a		sty $0a				sty 	temp3
.145f	68		pla				pla 								; line addr into XY.
.1460	a8		tay				tay
.1461	68		pla				pla
.1462	aa		tax				tax
.1463	c8		iny				iny
.1464	d0 01		bne $1467			bne 	_EHNoBump
.1466	e8		inx				inx
.1467					_EHNoBump:
.1467	20 ad 14	jsr $14ad			jsr 	PrintXYString 				; print it
.146a	a0 00		ldy #$00			ldy 	#0 							; if offset = 0 (e.g. not in program)
.146c	b1 00		lda ($00),y			lda 	(codePtr),y
.146e	f0 30		beq $14a0			beq 	_GoWarm 					; no line #
.1470	20 a8 14	jsr $14a8			jsr 	PrintSpace
.1473	a9 40		lda #$40			lda 	#'@'
.1475	20 37 22	jsr $2237			jsr 	XTPrintAC
.1478	20 a8 14	jsr $14a8			jsr 	PrintSpace
.147b	a2 00		ldx #$00			ldx 	#0 							; set up for ITOA conversion
.147d	c8		iny				iny
.147e	b1 00		lda ($00),y			lda 	(codePtr),y
.1480	95 28		sta $28,x			sta 	esInt0,x
.1482	c8		iny				iny
.1483	b1 00		lda ($00),y			lda 	(codePtr),y
.1485	95 30		sta $30,x			sta 	esInt1,x
.1487	8a		txa				txa
.1488	95 38		sta $38,x			sta 	esInt2,x
.148a	95 40		sta $40,x			sta 	esInt3,x
.148c	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.148e	85 04		sta $04				sta 	temp0
.1490	a9 08		lda #$08			lda 	#(buffer) >> 8
.1492	85 05		sta $05				sta 	1+(temp0)
.1494	a9 0a		lda #$0a			lda 	#10 						; convert base 10.
.1496	20 58 1d	jsr $1d58			jsr 	Int32ToString
.1499	a2 08		ldx #$08			ldx 	#buffer >> 8
.149b	a0 8c		ldy #$8c			ldy 	#buffer & $FF
.149d	20 ad 14	jsr $14ad			jsr 	PrintXYString
.14a0					_GoWarm:
.14a0	a5 0a		lda $0a				lda 	temp3
.14a2	4c 09 10	jmp $1009			jmp 	WarmStart
.14a5					InstructionUndefined:
.14a5	4c 3c 1a	jmp $1a3c			jmp 	EHandlerNotImplemented
.14a8					PrintSpace:
.14a8	a9 20		lda #$20			lda 	#32
.14aa	4c 37 22	jmp $2237			jmp 	XTPrintAC
.14ad					PrintXYString:
.14ad	48		pha				pha
.14ae	84 04		sty $04				sty 	temp0
.14b0	86 05		stx $05				stx 	temp0+1
.14b2	a0 00		ldy #$00			ldy 	#0
.14b4					_PXYSLoop:
.14b4	b1 04		lda ($04),y			lda 	(temp0),y
.14b6	20 37 22	jsr $2237			jsr 	XTPrintAC
.14b9	c8		iny				iny
.14ba	b1 04		lda ($04),y			lda 	(temp0),y
.14bc	d0 f6		bne $14b4			bne 	_PXYSLoop
.14be	a4 04		ldy $04				ldy 	temp0
.14c0	a6 05		ldx $05				ldx 	temp0+1
.14c2	68		pla				pla
.14c3	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary1.asm

.14c4					BinaryAdd:
.14c4	20 00 17	jsr $1700			jsr		DeRefBoth
.14c7	20 ed 1c	jsr $1ced			jsr 	Int32Add
.14ca	a9 00		lda #$00			lda 	#0
.14cc	95 20		sta $20,x			sta 	esType,x
.14ce	60		rts				rts
.14cf					BinarySub:
.14cf	20 00 17	jsr $1700			jsr		DeRefBoth
.14d2	20 07 1d	jsr $1d07			jsr 	Int32Sub
.14d5	a9 00		lda #$00			lda 	#0
.14d7	95 20		sta $20,x			sta 	esType,x
.14d9	60		rts				rts
.14da					BinaryMult:
.14da	20 00 17	jsr $1700			jsr		DeRefBoth
.14dd	20 21 1d	jsr $1d21			jsr 	Int32Multiply
.14e0	a9 00		lda #$00			lda 	#0
.14e2	95 20		sta $20,x			sta 	esType,x
.14e4	60		rts				rts
.14e5					BinaryDivide:
.14e5	20 00 17	jsr $1700			jsr		DeRefBoth
.14e8	20 01 15	jsr $1501			jsr		CheckDivisorNonZero
.14eb	20 0a 1c	jsr $1c0a			jsr 	Int32SDivide
.14ee	a9 00		lda #$00			lda 	#0
.14f0	95 20		sta $20,x			sta 	esType,x
.14f2	60		rts				rts
.14f3					BinaryModulus:
.14f3	20 00 17	jsr $1700			jsr		DeRefBoth
.14f6	20 01 15	jsr $1501			jsr 	CheckDivisorNonZero
.14f9	20 79 1c	jsr $1c79			jsr		Int32Modulus
.14fc	a9 00		lda #$00			lda 	#0
.14fe	95 20		sta $20,x			sta 	esType,x
.1500	60		rts				rts
.1501					CheckDivisorNonZero:
.1501	e8		inx				inx
.1502	20 23 1e	jsr $1e23			jsr 	Int32Zero
.1505	f0 02		beq $1509			beq 	_BDivZero
.1507	ca		dex				dex
.1508	60		rts				rts
.1509					_BDivZero:
.1509	4c 98 19	jmp $1998			jmp 	EHandlerDivideZero
.150c					BinaryXor:
.150c	20 00 17	jsr $1700			jsr		DeRefBoth
.150f	20 be 1b	jsr $1bbe			jsr 	Int32Xor
.1512	a9 00		lda #$00			lda 	#0
.1514	95 20		sta $20,x			sta 	esType,x
.1516	60		rts				rts
.1517					BinaryOr:
.1517	20 00 17	jsr $1700			jsr		DeRefBoth
.151a	20 a5 1b	jsr $1ba5			jsr 	Int32Or
.151d	a9 00		lda #$00			lda 	#0
.151f	95 20		sta $20,x			sta 	esType,x
.1521	60		rts				rts
.1522					BinaryAnd:
.1522	20 00 17	jsr $1700			jsr		DeRefBoth
.1525	20 8c 1b	jsr $1b8c			jsr 	Int32And
.1528	a9 00		lda #$00			lda 	#0
.152a	95 20		sta $20,x			sta 	esType,x
.152c	60		rts				rts
.152d					BinaryShiftLeft:
.152d	20 00 17	jsr $1700			jsr		DeRefBoth
.1530	20 5a 15	jsr $155a			jsr 	CheckShiftParam2
.1533	d0 21		bne $1556			bne 	BinaryShiftZero
.1535					BSLLoop:
.1535	d6 29		dec $29,x			dec 	esInt0+1,x
.1537	30 18		bmi $1551			bmi 	BinaryShiftExit
.1539	20 11 1e	jsr $1e11			jsr 	Int32ShiftLeft
.153c	4c 35 15	jmp $1535			jmp 	BSLLoop
.153f					BinaryShiftRight:
.153f	20 00 17	jsr $1700			jsr		DeRefBoth
.1542	20 5a 15	jsr $155a			jsr 	CheckShiftParam2
.1545	d0 0f		bne $1556			bne 	BinaryShiftZero
.1547					BSRLoop:
.1547	d6 29		dec $29,x			dec 	esInt0+1,x
.1549	30 06		bmi $1551			bmi 	BinaryShiftExit
.154b	20 1a 1e	jsr $1e1a			jsr 	Int32ShiftRight
.154e	4c 47 15	jmp $1547			jmp 	BSRLoop
.1551					BinaryShiftExit:
.1551	a9 00		lda #$00			lda 	#0
.1553	95 20		sta $20,x			sta 	esType,x
.1555	60		rts				rts
.1556					BinaryShiftZero:
.1556	20 fc 1d	jsr $1dfc			jsr 	Int32False
.1559	60		rts				rts
.155a					CheckShiftParam2:
.155a	b5 29		lda $29,x			lda 	esInt0+1,x 					; if value >= 32 then result is zero
.155c	29 e0		and #$e0			and 	#$E0
.155e	15 31		ora $31,x			ora 	esInt1+1,x
.1560	15 39		ora $39,x			ora 	esInt2+1,x
.1562	15 41		ora $41,x			ora 	esInt3+1,x
.1564	60		rts				rts
.1565					IndirectWord:
.1565	20 00 17	jsr $1700			jsr		DeRefBoth
.1568	20 ed 1c	jsr $1ced			jsr 	Int32Add
.156b	a9 80		lda #$80			lda 	#$80 						; make it a reference
.156d	95 20		sta $20,x			sta 	esType,x
.156f	60		rts				rts
.1570					IndirectByte:
.1570	20 00 17	jsr $1700			jsr		DeRefBoth
.1573	20 ed 1c	jsr $1ced			jsr 	Int32Add
.1576	a9 c0		lda #$c0			lda 	#$C0 						; type is set to byte reference.
.1578	95 20		sta $20,x			sta 	esType,x
.157a	60		rts				rts
.157b					IndirectString:
.157b	20 00 17	jsr $1700			jsr		DeRefBoth
.157e	20 ed 1c	jsr $1ced			jsr 	Int32Add
.1581	a9 81		lda #$81			lda 	#$81 						; type is set to string reference.
.1583	95 20		sta $20,x			sta 	esType,x
.1585	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary2.asm

.1586					Binary_Equal:
.1586	20 b6 15	jsr $15b6			jsr 	TestEqual
.1589	b0 04		bcs $158f			bcs 	CompTrue
.158b					CompFalse:
.158b	20 fc 1d	jsr $1dfc			jsr 	Int32False
.158e	60		rts				rts
.158f					CompTrue
.158f	20 f8 1d	jsr $1df8			jsr 	Int32True
.1592	60		rts				rts
.1593					Binary_NotEqual:
.1593	20 b6 15	jsr $15b6			jsr 	TestEqual
.1596	90 f7		bcc $158f			bcc 	CompTrue
.1598	b0 f1		bcs $158b			bcs 	CompFalse
.159a					Binary_Less:
.159a	20 cd 15	jsr $15cd			jsr 	TestLess
.159d	b0 f0		bcs $158f			bcs 	CompTrue
.159f	90 ea		bcc $158b			bcc 	CompFalse
.15a1					Binary_GreaterEqual:
.15a1	20 cd 15	jsr $15cd			jsr 	TestLess
.15a4	90 e9		bcc $158f			bcc 	CompTrue
.15a6	b0 e3		bcs $158b			bcs 	CompFalse
.15a8					Binary_LessEqual:
.15a8	20 ca 15	jsr $15ca			jsr 	TestLessSwap
.15ab	90 e2		bcc $158f			bcc 	CompTrue
.15ad	b0 dc		bcs $158b			bcs 	CompFalse
.15af					Binary_Greater:
.15af	20 ca 15	jsr $15ca			jsr 	TestLessSwap
.15b2	b0 db		bcs $158f			bcs 	CompTrue
.15b4	90 d5		bcc $158b			bcc 	CompFalse
.15b6					TestEqual:
.15b6	20 e4 15	jsr $15e4			jsr 	TypeCheck
.15b9	c9 00		cmp #$00			cmp 	#0
.15bb	f0 0a		beq $15c7			beq 	_TEInteger
.15bd	20 0d 16	jsr $160d			jsr 	StringCompare
.15c0	c9 00		cmp #$00			cmp 	#0
.15c2	38		sec				sec
.15c3	f0 01		beq $15c6			beq 	_TEZero
.15c5	18		clc				clc
.15c6					_TEZero
.15c6	60		rts				rts
.15c7					_TEInteger:
.15c7	4c d7 1b	jmp $1bd7			jmp 	Int32Equal
.15ca					TestLessSwap:
.15ca	20 f1 15	jsr $15f1			jsr 	SwapTopStack
.15cd					TestLess:
.15cd	20 e4 15	jsr $15e4			jsr 	TypeCheck
.15d0	c9 00		cmp #$00			cmp 	#0
.15d2	f0 0d		beq $15e1			beq 	_TLInteger
.15d4	20 0d 16	jsr $160d			jsr 	StringCompare
.15d7	c9 00		cmp #$00			cmp 	#0
.15d9	38		sec				sec
.15da	30 01		bmi $15dd			bmi 	_TELess
.15dc	18		clc				clc
.15dd					_TELess:
.15dd	60		rts				rts
.15de	4c 3c 1a	jmp $1a3c			jmp 	EHandlerNotImplemented
.15e1					_TLInteger:
.15e1	4c f1 1b	jmp $1bf1			jmp 	Int32Less
.15e4					TypeCheck:
.15e4	20 00 17	jsr $1700			jsr 	DerefBoth
.15e7	b5 20		lda $20,x			lda 	esType,x
.15e9	d5 21		cmp $21,x			cmp 	esType+1,x
.15eb	d0 01		bne $15ee			bne 	_TCMismatch
.15ed	60		rts				rts
.15ee					_TCMismatch:
.15ee	4c 79 1a	jmp $1a79			jmp 	EHandlerTypeMismatch
.15f1					SwapTopStack:
.15f1	a9 06		lda #$06			lda 	#6
.15f3	85 03		sta $03				sta 	tempShort
.15f5	8a		txa				txa
.15f6	48		pha				pha
.15f7					_TLSLoop:
.15f7	b5 20		lda $20,x			lda 	esType,x
.15f9	48		pha				pha
.15fa	b5 21		lda $21,x			lda 	esType+1,x
.15fc	95 20		sta $20,x			sta 	esType,x
.15fe	68		pla				pla
.15ff	95 21		sta $21,x			sta 	esType+1,x
.1601	8a		txa				txa
.1602	18		clc				clc
.1603	69 08		adc #$08			adc 	#DataStackSize
.1605	aa		tax				tax
.1606	c6 03		dec $03				dec 	tempShort
.1608	d0 ed		bne $15f7			bne 	_TLSLoop
.160a	68		pla				pla
.160b	aa		tax				tax
.160c	60		rts				rts
.160d					StringCompare:
.160d	b5 28		lda $28,x			lda 	esInt0,x 					; copy addresses.
.160f	85 04		sta $04				sta 	temp0
.1611	b5 30		lda $30,x			lda 	esInt1,x
.1613	85 05		sta $05				sta 	temp0+1
.1615	b5 29		lda $29,x			lda 	esInt0+1,x
.1617	85 06		sta $06				sta 	temp1
.1619	b5 31		lda $31,x			lda 	esInt1+1,x
.161b	85 07		sta $07				sta 	temp1+1
.161d	84 03		sty $03				sty 	tempShort
.161f	a0 ff		ldy #$ff			ldy 	#255
.1621	c8		iny		_SCLoop:iny
.1622	b1 04		lda ($04),y			lda 	(temp0),y 					; check match return +ve/-ve if fail.
.1624	38		sec				sec
.1625	f1 06		sbc ($06),y			sbc 	(temp1),y
.1627	d0 04		bne $162d			bne 	_SCExit
.1629	b1 04		lda ($04),y			lda 	(temp0),y 					; matched zero, then exit with zero
.162b	d0 f4		bne $1621			bne 	_SCLoop
.162d					_SCExit:
.162d	a4 03		ldy $03				ldy 	tempShort
.162f	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/evaluate.asm

.1630					EvaluateTerm:
.1630	a9 0f		lda #$0f			lda 	#15
.1632	20 48 16	jsr $1648			jsr 	EvaluateLevelAX
.1635	4c 05 17	jmp $1705			jmp 	DeRefTop
.1638					EvaluateBaseDeRef:
.1638	20 44 16	jsr $1644			jsr 	EvaluateBase
.163b	4c 05 17	jmp $1705			jmp 	DeRefTop
.163e					EvaluateTOSDeRef:
.163e	20 46 16	jsr $1646			jsr 	EvaluateTOS
.1641	4c 05 17	jmp $1705			jmp 	DeRefTop
.1644					EvaluateBase:
.1644	a2 00		ldx #$00			ldx 	#0 							; reset Stack index
.1646					EvaluateTOS:
.1646	a9 00		lda #$00			lda 	#0 							; start from lowest level.
.1648					EvaluateLevelAX:
.1648	48		pha				pha 								; save level on stack
.1649	a9 00		lda #$00			lda 	#0 							; erase the current stack level
.164b	95 28		sta $28,x			sta 	esInt0,x
.164d	95 30		sta $30,x			sta 	esInt1,x
.164f	95 38		sta $38,x			sta 	esInt2,x
.1651	95 40		sta $40,x			sta 	esInt3,x
.1653	95 20		sta $20,x			sta 	esType,x 					; default to integer.
.1655	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next token/element.
.1657	30 59		bmi $16b2			bmi 	EBNotVariable 				; if $80-$FF it is a token.
.1659	c9 70		cmp #$70			cmp 	#$70 						; if $70-$7F it is a constant
.165b	90 06		bcc $1663			bcc 	_EBNotConstant
.165d					_EBConstant:
.165d	20 44 17	jsr $1744			jsr 	ExtractConstant
.1660	4c 86 16	jmp $1686			jmp 	EBHaveTerm
.1663					_EBNotConstant:
.1663	c9 60		cmp #$60			cmp 	#$60 						; 60 is a string.
.1665	f0 06		beq $166d			beq 	_EBHaveString
.1667	20 3b 21	jsr $213b			jsr 	VariableAccess
.166a	4c 86 16	jmp $1686			jmp 	EBHaveTerm
.166d					_EBHaveString:
.166d	98		tya				tya 								; put codePtr + 2 in the address, it's a string.
.166e	18		clc				clc
.166f	69 02		adc #$02			adc 	#2
.1671	65 00		adc $00				adc 	codePtr
.1673	95 28		sta $28,x			sta 	esInt0,x
.1675	a5 01		lda $01				lda 	codePtr+1
.1677	69 00		adc #$00			adc 	#0
.1679	95 30		sta $30,x			sta 	esInt1,x
.167b	f6 20		inc $20,x			inc 	esType,x 					; make the type a string.
.167d	98		tya				tya 								; position in A
.167e	c8		iny				iny 								; point to offset and add it
.167f	18		clc				clc
.1680	71 00		adc ($00),y			adc 	(codePtr),y
.1682	a8		tay				tay
.1683	4c 86 16	jmp $1686			jmp 	EBHaveTerm 				; do the term code.
.1686					EBHaveTerm:
.1686	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next element.
.1688	10 26		bpl $16b0			bpl 	_EBPopExit 					; needs to be a token to continue.
.168a	84 03		sty $03				sty 	tempShort
.168c	a8		tay				tay
.168d	b9 0a 1a	lda $1a0a,y			lda 	KeywordTypes-$80,y 			; get the type of the keyword.
.1690	a4 03		ldy $03				ldy 	tempShort
.1692	c9 10		cmp #$10			cmp 	#16 						; not a binary operator.
.1694	b0 1a		bcs $16b0			bcs 	_EBPopExit
.1696	85 03		sta $03				sta 	tempShort 					; save level of new operator.
.1698	68		pla				pla 								; restore current level.
.1699	c5 03		cmp $03				cmp 	tempShort 					; if current >= operator then exit
.169b	b0 14		bcs $16b1			bcs 	_EBExit
.169d	48		pha				pha 								; push level on stack.
.169e	b1 00		lda ($00),y			lda		(codePtr),y					; get the token ID and skip
.16a0	c8		iny				iny
.16a1	48		pha				pha 								; put that on the stack.
.16a2	e8		inx				inx 								; do the term in the next stack level.
.16a3	a5 03		lda $03				lda 	tempShort 					; get the level of the operator.
.16a5	20 48 16	jsr $1648			jsr 	EvaluateLevelAX
.16a8	ca		dex				dex
.16a9	68		pla				pla 								; get token ID
.16aa	20 75 17	jsr $1775			jsr 	ExecuteCommand 				; execute command A.
.16ad	4c 86 16	jmp $1686			jmp 	EBHaveTerm 					; keep going round
.16b0					_EBPopExit:
.16b0	68		pla				pla
.16b1					_EBExit:
.16b1	60		rts				rts
.16b2					EBNotVariable:
.16b2	84 03		sty $03				sty 	tempShort 					; get the type
.16b4	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.16b6	a8		tay				tay
.16b7	b9 0a 1a	lda $1a0a,y			lda 	KeywordTypes-$80,y
.16ba	a4 03		ldy $03				ldy 	tempShort
.16bc	29 40		and #$40			and 	#$40 						; check unary function
.16be	d0 37		bne $16f7			bne 	_EBExecUnaryFunction
.16c0	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.16c2	c8		iny				iny
.16c3	c9 8b		cmp #$8b			cmp 	#KWD_MINUS
.16c5	f0 0f		beq $16d6			beq 	_EBNegate
.16c7	c9 91		cmp #$91			cmp 	#KWD_PLING
.16c9	f0 14		beq $16df			beq 	_EBUnaryReference
.16cb	c9 92		cmp #$92			cmp 	#KWD_QUESTION
.16cd	f0 10		beq $16df			beq 	_EBUnaryReference
.16cf	c9 93		cmp #$93			cmp 	#KWD_DOLLAR
.16d1	f0 0c		beq $16df			beq 	_EBUnaryReference
.16d3					_EBError:
.16d3	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax
.16d6					_EBNegate:
.16d6	20 30 16	jsr $1630			jsr 	EvaluateTerm
.16d9	20 b6 1d	jsr $1db6			jsr 	Int32Negate
.16dc	4c 86 16	jmp $1686			jmp 	EBHaveTerm
.16df					_EBUnaryReference:
.16df	48		pha				pha 								; save keyword
.16e0	20 30 16	jsr $1630			jsr 	EvaluateTerm 				; get the address to case.
.16e3	68		pla				pla
.16e4	49 91		eor #$91			eor 	#KWD_PLING 					; is it pling, then will now be zero.
.16e6	f0 08		beq $16f0			beq 	_EBSetType
.16e8	49 02		eor #$02			eor 	#KWD_DOLLAR^KWD_PLING 		; if was dollar will now be zero
.16ea	f0 02		beq $16ee			beq 	_EBSetString
.16ec	a9 41		lda #$41			lda 	#$41 						; will end up as $C0
.16ee					_EBSetString:
.16ee	49 01		eor #$01			eor 	#$01 						; will end up as $81
.16f0					_EBSetType:
.16f0	09 80		ora #$80			ora 	#$80 						; make it a reference.
.16f2	95 20		sta $20,x			sta 	esType,x
.16f4	4c 86 16	jmp $1686			jmp 	EBHaveTerm
.16f7					_EBExecUnaryFunction:
.16f7	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the function token.
.16f9	c8		iny				iny
.16fa	20 75 17	jsr $1775			jsr 	ExecuteCommand 				; and do it.
.16fd	4c 86 16	jmp $1686			jmp 	EBHaveTerm
.1700					DeRefBoth:
.1700	e8		inx				inx
.1701	20 05 17	jsr $1705			jsr 	DeRefTop
.1704	ca		dex				dex
.1705					DeRefTop:
.1705	b5 20		lda $20,x			lda 	esType,x 					; is it a reference ?
.1707	10 3a		bpl $1743			bpl 	_DRTExit
.1709	29 7f		and #$7f			and 	#$7F 						; clear the reference bit and write back.
.170b	95 20		sta $20,x			sta 	esType,x
.170d	4a		lsr a				lsr 	a 							; if string, exit. Strings are always references
.170e	b0 33		bcs $1743			bcs 	_DRTExit
.1710	b5 28		lda $28,x			lda 	esInt0,x 					; copy address over.
.1712	85 04		sta $04				sta 	temp0
.1714	b5 30		lda $30,x			lda 	esInt1,x
.1716	85 05		sta $05				sta 	temp0+1
.1718	98		tya				tya
.1719	48		pha				pha
.171a	a0 00		ldy #$00			ldy 	#0
.171c	b1 04		lda ($04),y			lda 	(temp0),y
.171e	95 28		sta $28,x			sta 	esInt0,x
.1720	b5 20		lda $20,x			lda 	esType,x 					; is it now zero, e.g. it's a !
.1722	f0 0c		beq $1730			beq 	_DRTPling
.1724	98		tya				tya 								; clear upper 3 bytes
.1725	95 30		sta $30,x			sta 	esInt1,x
.1727	95 38		sta $38,x			sta 	esInt2,x
.1729	95 40		sta $40,x			sta 	esInt3,x
.172b	95 20		sta $20,x			sta 	esType,x
.172d	4c 41 17	jmp $1741			jmp	 	_DRTExit2
.1730					_DRTPling:
.1730	94 20		sty $20,x			sty 	esType,x 					; make it an integer
.1732	c8		iny				iny
.1733	b1 04		lda ($04),y			lda 	(temp0),y 					; copy 4 bytes.
.1735	95 30		sta $30,x			sta 	esInt1,x
.1737	c8		iny				iny
.1738	b1 04		lda ($04),y			lda 	(temp0),y
.173a	95 38		sta $38,x			sta 	esInt2,x
.173c	c8		iny				iny
.173d	b1 04		lda ($04),y			lda 	(temp0),y
.173f	95 40		sta $40,x			sta 	esInt3,x
.1741					_DRTExit2:
.1741	68		pla				pla
.1742	a8		tay				tay
.1743					_DRTExit:
.1743	60		rts				rts
.1744					ExtractConstant:
.1744	a9 00		lda #$00			lda 	#0 							; count of number of hex digits read.
.1746	85 03		sta $03				sta 	tempShort 					; use tempShort for that
.1748	8a		txa				txa
.1749	48		pha				pha
.174a					_EBConstLoop:
.174a	e6 03		inc $03				inc 	tempShort 					; bump the hex digit count.
.174c	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character.
.174e	29 f0		and #$f0			and 	#$F0 						; check it is 70-7F
.1750	c9 70		cmp #$70			cmp 	#$70
.1752	d0 1e		bne $1772			bne 	_EBConstEnd
.1754	a5 03		lda $03				lda 	tempShort 					; check LSB of digit count
.1756	4a		lsr a				lsr 	a
.1757	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the digit and bump
.1759	c8		iny				iny
.175a	90 06		bcc $1762			bcc		_EBConstHigh 				; goes in upper byte.
.175c	29 0f		and #$0f			and 	#$0F
.175e	95 28		sta $28,x			sta 	esInt0,x 					; and write it out.
.1760	10 e8		bpl $174a			bpl 	_EBConstLoop 				; try next one.
.1762					_EBConstHigh:
.1762	0a		asl a				asl 	a
.1763	0a		asl a				asl 	a
.1764	0a		asl a				asl 	a
.1765	0a		asl a				asl 	a
.1766	15 28		ora $28,x			ora 	esInt0,x 					; put into upper 4 bits
.1768	95 28		sta $28,x			sta 	esInt0,x
.176a	8a		txa				txa 								; move to next slot in data stack.
.176b	18		clc				clc
.176c	69 08		adc #$08			adc 	#DataStackSize
.176e	aa		tax				tax
.176f	4c 4a 17	jmp $174a			jmp 	_EBConstLoop
.1772					_EBConstEnd:
.1772	68		pla				pla
.1773	aa		tax				tax
.1774	60		rts				rts
.1775					ExecuteCommand:
.1775	85 03		sta $03				sta 	tempShort  					; needs making 65C02 specific.
.1777	8a		txa				txa
.1778	48		pha				pha
.1779	a6 03		ldx $03				ldx 	tempShort
.177b	bd 60 1a	lda $1a60,x			lda 	TokenVectorLow-$80,x
.177e	85 04		sta $04				sta 	temp0
.1780	bd b6 1a	lda $1ab6,x			lda 	TokenVectorHigh-$80,x
.1783	85 05		sta $05				sta 	temp0+1
.1785	68		pla				pla
.1786	aa		tax				tax
.1787	6c 04 00	jmp ($0004)			jmp 	(temp0)

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/unary.asm

.178a					UnaryPage:
.178a	20 a1 17	jsr $17a1			jsr 	UnaryFalse 					; set all to zero/int
.178d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.178f	95 28		sta $28,x			sta 	esInt0,x
.1791	a9 23		lda #$23			lda 	#BasicProgram >> 8
.1793	95 30		sta $30,x			sta 	esInt1,x
.1795	60		rts				rts
.1796					UnaryParenthesis:
.1796	20 46 16	jsr $1646			jsr 	EvaluateTOS					; evaluate expression
.1799	20 4a 14	jsr $144a			jsr 	CheckRightParen				; check for )
.179c	60		rts				rts
.179d					UnaryTrue:
.179d	20 f8 1d	jsr $1df8			jsr 	Int32True
.17a0	60		rts				rts
.17a1					UnaryFalse:
.17a1	20 fc 1d	jsr $1dfc			jsr 	Int32False
.17a4	60		rts				rts
.17a5					UnaryAbs:
.17a5	20 30 16	jsr $1630			jsr 	EvaluateTerm				; work out value required and dispatch
.17a8	20 b1 1d	jsr $1db1			jsr		Int32Absolute
.17ab	a9 00		lda #$00			lda 	#0
.17ad	95 20		sta $20,x			sta 	esType,x
.17af	60		rts				rts
.17b0					UnarySys:
.17b0	20 30 16	jsr $1630			jsr 	EvaluateTerm				; address to call
.17b3	b5 28		lda $28,x			lda 	esInt0,x 					; copy call address
.17b5	85 04		sta $04				sta 	temp0
.17b7	b5 30		lda $30,x			lda 	esInt1,x
.17b9	85 05		sta $05				sta 	temp0+1
.17bb	8a		txa				txa
.17bc	48		pha				pha
.17bd	98		tya				tya
.17be	48		pha				pha
.17bf	ad 00 08	lda $0800			lda 	('A'-'A')*4+RootVariables 	; load AXY
.17c2	ae 5c 08	ldx $085c			ldx 	('X'-'A')*4+RootVariables
.17c5	ac 60 08	ldy $0860			ldy 	('Y'-'A')*4+RootVariables
.17c8	20 ea 17	jsr $17ea			jsr 	_USCall						; call code
.17cb	8d 00 08	sta $0800			sta 	('A'-'A')*4+RootVariables 	; save AXY
.17ce	8e 5c 08	stx $085c			stx 	('X'-'A')*4+RootVariables
.17d1	8c 60 08	sty $0860			sty 	('Y'-'A')*4+RootVariables
.17d4	68		pla				pla
.17d5	a8		tay				tay
.17d6	68		pla				pla
.17d7	aa		tax				tax
.17d8	ad 00 08	lda $0800			lda 	('A'-'A')*4+RootVariables 	; return A.
.17db	95 28		sta $28,x			sta 	esInt0,x
.17dd	a9 00		lda #$00			lda 	#0
.17df	95 30		sta $30,x			sta 	esInt1,x
.17e1	95 38		sta $38,x			sta 	esInt2,x
.17e3	95 40		sta $40,x			sta 	esInt3,x
.17e5	a9 00		lda #$00			lda 	#0
.17e7	95 20		sta $20,x			sta 	esType,x
.17e9	60		rts				rts
.17ea	6c 04 00	jmp ($0004)	_USCall:jmp 	(temp0)
.17ed					UnarySgn1:
.17ed	20 30 16	jsr $1630			jsr 	EvaluateTerm				; work out value required and dispatch
.17f0	20 e9 1d	jsr $1de9			jsr 	Int32Sign
.17f3	a9 00		lda #$00			lda 	#0
.17f5	95 20		sta $20,x			sta 	esType,x
.17f7	60		rts				rts
.17f8					UnaryNot:
.17f8	20 30 16	jsr $1630			jsr 	EvaluateTerm				; work out value required and dispatch
.17fb	20 d0 1d	jsr $1dd0			jsr 	Int32Not
.17fe	a9 00		lda #$00			lda 	#0
.1800	95 20		sta $20,x			sta 	esType,x
.1802	60		rts				rts
.1803					UnaryMin:
.1803	38		sec				sec 								; min indicated with CS
.1804	b0 01		bcs $1807			bcs 	UnaryMax+1
.1806					UnaryMax:
.1806	18		clc				clc 								; max is CC.
.1807	08		php				php 								; save what we're doing.
.1808	20 38 14	jsr $1438			jsr 	CheckLeftParen 				; check for (, required here
.180b	20 3e 16	jsr $163e			jsr 	EvaluateTOSDeRef			; evaluate expression
.180e	e8		inx				inx
.180f	20 32 14	jsr $1432			jsr 	CheckComma
.1812	20 3e 16	jsr $163e			jsr 	EvaluateTOSDeRef
.1815	20 00 17	jsr $1700			jsr 	DerefBoth 					; dereference them.
.1818	ca		dex				dex
.1819	20 4a 14	jsr $144a			jsr 	CheckRightParen
.181c	20 f1 1b	jsr $1bf1			jsr 	Int32Less 					; is p1 < p2, CS if true.
.181f	a9 00		lda #$00			lda 	#0 							; put into A, now 1 if <, 0 if >
.1821	69 00		adc #$00			adc 	#0
.1823	28		plp				plp
.1824	69 00		adc #$00			adc 	#0 							; toggle bit 0 for Min.
.1826	4a		lsr a				lsr 	a 							; put into carry
.1827	90 03		bcc $182c			bcc 	_UMinMaxExit 				; if clear just exit.
.1829	20 f1 15	jsr $15f1			jsr 	SwapTopStack 				; swap two values over.
.182c					_UMinMaxExit:
.182c	a9 00		lda #$00			lda 	#0
.182e	95 20		sta $20,x			sta 	esType,x
.1830	60		rts				rts
.1831					UTypeError:
.1831	4c 79 1a	jmp $1a79			jmp 	EHandlerTypeMismatch
.1834					UnaryRefToValue:
.1834	a9 0f		lda #$0f			lda 	#15
.1836	20 48 16	jsr $1648			jsr 	EvaluateLevelAX 			; get a term.
.1839	b5 20		lda $20,x			lda 	esType,x
.183b	10 f4		bpl $1831			bpl 	UTypeError 					; not a reference
.183d	29 7f		and #$7f			and 	#$7F 						; clear reference bit.
.183f	95 20		sta $20,x			sta 	esType,x 					; overwrite type
.1841	a9 00		lda #$00			lda 	#0
.1843	95 20		sta $20,x			sta 	esType,x
.1845	60		rts				rts
.1846					UnaryHexMarker:
.1846	4c 30 16	jmp $1630			jmp 	EvaluateTerm
.1849					UnaryRandom:
.1849	20 2c 1e	jsr $1e2c			jsr 	Int32Random 				; random #
.184c	a9 00		lda #$00			lda 	#0
.184e	95 20		sta $20,x			sta 	esType,x
.1850	60		rts				rts
.1851					UnaryLen:
.1851	20 30 16	jsr $1630			jsr 	EvaluateTerm				; work out value required and dispatch
.1854	b5 28		lda $28,x			lda 	esInt0,x 					; copy addr to temp0
.1856	85 04		sta $04				sta 	temp0
.1858	b5 30		lda $30,x			lda 	esInt1,x
.185a	85 05		sta $05				sta 	temp0+1
.185c	20 a1 17	jsr $17a1			jsr 	UnaryFalse 					; sets return to int zero.
.185f	98		tya				tya
.1860	48		pha				pha
.1861	a0 00		ldy #$00			ldy 	#0
.1863					_ULCheck:
.1863	b1 04		lda ($04),y			lda 	(temp0),y
.1865	f0 03		beq $186a			beq 	_ULFound
.1867	c8		iny				iny
.1868	d0 f9		bne $1863			bne 	_ULCheck
.186a					_ULFound:
.186a	94 28		sty $28,x			sty 	esInt0,x 					; update result
.186c	68		pla				pla
.186d	a8		tay				tay
.186e	60		rts				rts
.186f	60		rts				rts
.1870					UnaryChr:
.1870	20 30 16	jsr $1630			jsr 	EvaluateTerm				; work out value required and dereference
.1873	b5 28		lda $28,x			lda 	esInt0,x 					; get char code
.1875	8d a5 08	sta $08a5			sta 	ChrBuffer 					; put into buffer.
.1878	a9 00		lda #$00			lda 	#0
.187a	8d a6 08	sta $08a6			sta 	ChrBuffer+1 				; make ASCIIZ
.187d	a9 a5		lda #$a5			lda 	#ChrBuffer & $FF 			; set address
.187f	95 28		sta $28,x			sta 	esInt0,x
.1881	a9 08		lda #$08			lda 	#ChrBuffer >> 8
.1883	95 30		sta $30,x			sta 	esInt1,x
.1885	f6 20		inc $20,x			inc 	esType,x 					; makes it a string
.1887	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/alloc.asm

.1888					Unary_Alloc:
.1888	20 30 16	jsr $1630			jsr 	EvaluateTerm				; memory to allocate
.188b	a5 10		lda $10				lda 	LowMemory 					; push low memory ons tack.
.188d	48		pha				pha
.188e	a5 11		lda $11				lda 	LowMemory+1
.1890	48		pha				pha
.1891	20 c0 10	jsr $10c0			jsr 	AllocMemStackCount 			; allocate memory (in DIM code)
.1894	68		pla				pla 								; update stack entry
.1895	95 30		sta $30,x			sta 	esInt1,x
.1897	68		pla				pla
.1898	95 28		sta $28,x			sta 	esInt0,x
.189a	a9 00		lda #$00			lda 	#0
.189c	95 38		sta $38,x			sta 	esInt2,x
.189e	95 40		sta $40,x			sta 	esInt3,x
.18a0	95 20		sta $20,x			sta 	esType,x
.18a2	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/event.asm

.18a3					Event_Function:
.18a3	20 38 14	jsr $1438			jsr 	CheckLeftParen 				; check for (
.18a6	a9 04		lda #$04			lda 	#4  						; this means ! ? and $ binary operators only work.
.18a8	20 48 16	jsr $1648			jsr 	EvaluateLevelAX 			; this is the event variable.
.18ab	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.18ad	10 5d		bpl $190c			bpl 	_EFSyntax 					; if not, syntax error.
.18af	20 32 14	jsr $1432			jsr 	CheckComma
.18b2	e8		inx				inx
.18b3	20 3e 16	jsr $163e			jsr 	EvaluateTOSDeRef 			; get the rate
.18b6	ca		dex				dex
.18b7	20 4a 14	jsr $144a			jsr 	CheckRightParen 			; closing bracket.
.18ba	20 1b 22	jsr $221b			jsr 	XTUpdateClock
.18bd	98		tya				tya
.18be	48		pha				pha
.18bf	b5 28		lda $28,x			lda 	esInt0,x 					; point temp0 to the variable
.18c1	85 04		sta $04				sta 	temp0
.18c3	b5 30		lda $30,x			lda 	esInt1,x
.18c5	85 05		sta $05				sta 	temp0+1
.18c7	a0 00		ldy #$00			ldy 	#0 							; check if zero, if so initialise/return FLASE
.18c9	b1 04		lda ($04),y			lda 	(temp0),y
.18cb	c8		iny				iny
.18cc	11 04		ora ($04),y			ora 	(temp0),y
.18ce	f0 1b		beq $18eb			beq 	_EFInitialise
.18d0	a0 00		ldy #$00			ldy 	#0 							; calc timer - variable
.18d2	ad a0 08	lda $08a0			lda 	ClockTicks
.18d5	d1 04		cmp ($04),y			cmp 	(temp0),y
.18d7	c8		iny				iny
.18d8	ad a1 08	lda $08a1			lda 	ClockTicks+1
.18db	f1 04		sbc ($04),y			sbc 	(temp0),y
.18dd	10 06		bpl $18e5			bpl 	_EFFire						; if >= reset and return TRUE
.18df	20 fc 1d	jsr $1dfc			jsr 	Int32False					; otherwise just return FALSE
.18e2	4c 09 19	jmp $1909			jmp 	_EFExit
.18e5					_EFFire:
.18e5	20 f8 1d	jsr $1df8			jsr 	Int32True
.18e8	4c ee 18	jmp $18ee			jmp 	_EFResetTimer
.18eb					_EFInitialise:
.18eb	20 fc 1d	jsr $1dfc			jsr 	Int32False 					; return FALSE
.18ee					_EFResetTimer:
.18ee	a0 00		ldy #$00			ldy 	#0 							; reset the variable to clock + rate.
.18f0	18		clc				clc
.18f1	ad a0 08	lda $08a0			lda 	ClockTicks
.18f4	75 29		adc $29,x			adc 	esInt0+1,x
.18f6	91 04		sta ($04),y			sta 	(temp0),y
.18f8	c8		iny				iny
.18f9	ad a1 08	lda $08a1			lda 	ClockTicks+1
.18fc	75 31		adc $31,x			adc 	esInt1+1,x
.18fe	91 04		sta ($04),y			sta 	(temp0),y
.1900	88		dey				dey									; check zero
.1901	11 04		ora ($04),y			ora 	(temp0),y
.1903	d0 04		bne $1909			bne 	_EFExit
.1905	a9 01		lda #$01			lda 	#1 							; if so set it to 1.
.1907	91 04		sta ($04),y			sta 	(temp0),y
.1909					_EFExit:
.1909	68		pla				pla
.190a	a8		tay				tay
.190b	60		rts				rts
.190c					_EFSyntax:
.190c	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/functions/keyboard.asm

.190f					Unary_Inkey:
.190f	20 0b 22	jsr $220b			jsr 	XTGetKey
.1912	95 28		sta $28,x			sta 	esInt0,x
.1914	4c 0b 1e	jmp $1e0b			jmp 	Int32Set8Bit
.1917					Unary_Get:
.1917	20 0f 19	jsr $190f			jsr 	Unary_Inkey
.191a	b5 28		lda $28,x			lda 	esInt0,x
.191c	f0 f9		beq $1917			beq 	Unary_Get
.191e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/functions/timer.asm

.191f					Unary_Timer:
.191f	20 1b 22	jsr $221b			jsr 	XTUpdateClock
.1922	ad a0 08	lda $08a0			lda 	ClockTicks
.1925	95 28		sta $28,x			sta 	esInt0,x
.1927	ad a1 08	lda $08a1			lda 	ClockTicks+1
.192a	95 30		sta $30,x			sta 	esInt1,x
.192c	ad a2 08	lda $08a2			lda 	ClockTicks+2
.192f	95 38		sta $38,x			sta 	esInt2,x
.1931	a9 00		lda #$00			lda 	#0
.1933	95 40		sta $40,x			sta 	esInt3,x
.1935	95 20		sta $20,x			sta 	esType,x
.1937	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/generated/errors.asm

.1938					EHandlerAssert:
.1938	20 5d 14	jsr $145d		jsr	ErrorHandler
>193b	41 73 73 65 72 74 20 46			.text "Assert Failed",0
>1943	61 69 6c 65 64 00
.1949					EHandlerBadAIndex:
.1949	20 5d 14	jsr $145d		jsr	ErrorHandler
>194c	42 61 64 20 41 72 72 61			.text "Bad Array Index",0
>1954	79 20 49 6e 64 65 78 00
.195c					EHandlerBadIndex:
.195c	20 5d 14	jsr $145d		jsr	ErrorHandler
>195f	57 72 6f 6e 67 20 4e 65			.text "Wrong Next index",0
>1967	78 74 20 69 6e 64 65 78 00
.1970					EHandlerBadProc:
.1970	20 5d 14	jsr $145d		jsr	ErrorHandler
>1973	55 6e 6b 6e 6f 77 6e 20			.text "Unknown Procedure",0
>197b	50 72 6f 63 65 64 75 72 65 00
.1985					EHandlerClosure:
.1985	20 5d 14	jsr $145d		jsr	ErrorHandler
>1988	53 74 72 75 63 74 75 72			.text "Structure Error",0
>1990	65 20 45 72 72 6f 72 00
.1998					EHandlerDivideZero:
.1998	20 5d 14	jsr $145d		jsr	ErrorHandler
>199b	44 69 76 69 64 65 20 62			.text "Divide by Zero",0
>19a3	79 20 5a 65 72 6f 00
.19aa					EHandlerLineNumber:
.19aa	20 5d 14	jsr $145d		jsr	ErrorHandler
>19ad	55 6e 6b 6e 6f 77 6e 20			.text "Unknown line",0
>19b5	6c 69 6e 65 00
.19ba					EHandlerMemory:
.19ba	20 5d 14	jsr $145d		jsr	ErrorHandler
>19bd	49 6e 73 75 66 66 69 63			.text "Insufficient Memory",0
>19c5	69 65 6e 74 20 4d 65 6d 6f 72 79 00
.19d1					EHandlerNoArray:
.19d1	20 5d 14	jsr $145d		jsr	ErrorHandler
>19d4	42 61 64 20 41 72 72 61			.text "Bad Array",0
>19dc	79 00
.19de					EHandlerNoGosub:
.19de	20 5d 14	jsr $145d		jsr	ErrorHandler
>19e1	52 65 74 75 72 6e 20 77			.text "Return without Gosub",0
>19e9	69 74 68 6f 75 74 20 47 6f 73 75 62 00
.19f6					EHandlerNoProc:
.19f6	20 5d 14	jsr $145d		jsr	ErrorHandler
>19f9	45 6e 64 50 72 6f 63 20			.text "EndProc without Proc",0
>1a01	77 69 74 68 6f 75 74 20 50 72 6f 63 00
.1a0e					EHandlerNoRepeat:
.1a0e	20 5d 14	jsr $145d		jsr	ErrorHandler
>1a11	55 6e 74 69 6c 20 77 69			.text "Until without Repeat",0
>1a19	74 68 6f 75 74 20 52 65 70 65 61 74 00
.1a26					EHandlerNoWhile:
.1a26	20 5d 14	jsr $145d		jsr	ErrorHandler
>1a29	57 65 6e 64 20 77 69 74			.text "Wend without While",0
>1a31	68 6f 75 74 20 57 68 69 6c 65 00
.1a3c					EHandlerNotImplemented:
.1a3c	20 5d 14	jsr $145d		jsr	ErrorHandler
>1a3f	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>1a47	65 6d 65 6e 74 65 64 00
.1a4f					EHandlerParameters:
.1a4f	20 5d 14	jsr $145d		jsr	ErrorHandler
>1a52	42 61 64 20 50 61 72 61			.text "Bad Parameters",0
>1a5a	6d 65 74 65 72 73 00
.1a61					EHandlerStop:
.1a61	20 5d 14	jsr $145d		jsr	ErrorHandler
>1a64	53 74 6f 70 00				.text "Stop",0
.1a69					EHandlerSyntax:
.1a69	20 5d 14	jsr $145d		jsr	ErrorHandler
>1a6c	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>1a74	72 72 6f 72 00
.1a79					EHandlerTypeMismatch:
.1a79	20 5d 14	jsr $145d		jsr	ErrorHandler
>1a7c	54 79 70 65 20 4d 69 73			.text "Type Mismatch",0
>1a84	6d 61 74 63 68 00

;******  Return to file: basic.asm


;******  Processing file: common/generated/keytypes.asm

.1a8a					KeywordTypes:
>1a8a	81					.byte $81 ; $80 <<end>>
>1a8b	01					.byte $01 ; $81 and
>1a8c	01					.byte $01 ; $82 or
>1a8d	01					.byte $01 ; $83 xor
>1a8e	02					.byte $02 ; $84 >
>1a8f	02					.byte $02 ; $85 <
>1a90	02					.byte $02 ; $86 >=
>1a91	02					.byte $02 ; $87 <=
>1a92	02					.byte $02 ; $88 <>
>1a93	02					.byte $02 ; $89 =
>1a94	03					.byte $03 ; $8a +
>1a95	03					.byte $03 ; $8b -
>1a96	04					.byte $04 ; $8c *
>1a97	04					.byte $04 ; $8d /
>1a98	04					.byte $04 ; $8e %
>1a99	04					.byte $04 ; $8f >>
>1a9a	04					.byte $04 ; $90 <<
>1a9b	05					.byte $05 ; $91 !
>1a9c	05					.byte $05 ; $92 ?
>1a9d	05					.byte $05 ; $93 $
>1a9e	40					.byte $40 ; $94 ~
>1a9f	40					.byte $40 ; $95 (
>1aa0	40					.byte $40 ; $96 &
>1aa1	40					.byte $40 ; $97 @
>1aa2	40					.byte $40 ; $98 len
>1aa3	40					.byte $40 ; $99 sgn
>1aa4	40					.byte $40 ; $9a abs
>1aa5	40					.byte $40 ; $9b random
>1aa6	40					.byte $40 ; $9c page
>1aa7	40					.byte $40 ; $9d true
>1aa8	40					.byte $40 ; $9e false
>1aa9	40					.byte $40 ; $9f min
>1aaa	40					.byte $40 ; $a0 max
>1aab	40					.byte $40 ; $a1 sys
>1aac	40					.byte $40 ; $a2 code
>1aad	40					.byte $40 ; $a3 timer
>1aae	40					.byte $40 ; $a4 event
>1aaf	40					.byte $40 ; $a5 get
>1ab0	40					.byte $40 ; $a6 joy.x
>1ab1	40					.byte $40 ; $a7 joy.y
>1ab2	40					.byte $40 ; $a8 joy.btn
>1ab3	40					.byte $40 ; $a9 inkey
>1ab4	40					.byte $40 ; $aa alloc
>1ab5	40					.byte $40 ; $ab chr
>1ab6	81					.byte $81 ; $ac ,
>1ab7	81					.byte $81 ; $ad ;
>1ab8	81					.byte $81 ; $ae )
>1ab9	81					.byte $81 ; $af ++
>1aba	81					.byte $81 ; $b0 --
>1abb	81					.byte $81 ; $b1 [
>1abc	81					.byte $81 ; $b2 ]
>1abd	82					.byte $82 ; $b3 if
>1abe	82					.byte $82 ; $b4 for
>1abf	82					.byte $82 ; $b5 repeat
>1ac0	82					.byte $82 ; $b6 proc
>1ac1	82					.byte $82 ; $b7 while
>1ac2	80					.byte $80 ; $b8 endif
>1ac3	80					.byte $80 ; $b9 next
>1ac4	80					.byte $80 ; $ba until
>1ac5	80					.byte $80 ; $bb endproc
>1ac6	80					.byte $80 ; $bc wend
>1ac7	81					.byte $81 ; $bd rem
>1ac8	81					.byte $81 ; $be let
>1ac9	81					.byte $81 ; $bf '
>1aca	81					.byte $81 ; $c0 :
>1acb	81					.byte $81 ; $c1 then
>1acc	81					.byte $81 ; $c2 else
>1acd	81					.byte $81 ; $c3 to
>1ace	81					.byte $81 ; $c4 step
>1acf	81					.byte $81 ; $c5 vdu
>1ad0	81					.byte $81 ; $c6 print
>1ad1	81					.byte $81 ; $c7 call
>1ad2	81					.byte $81 ; $c8 local
>1ad3	81					.byte $81 ; $c9 goto
>1ad4	81					.byte $81 ; $ca gosub
>1ad5	81					.byte $81 ; $cb return
>1ad6	81					.byte $81 ; $cc assert
>1ad7	81					.byte $81 ; $cd stop
>1ad8	81					.byte $81 ; $ce end
>1ad9	81					.byte $81 ; $cf dim
>1ada	81					.byte $81 ; $d0 clear
>1adb	81					.byte $81 ; $d1 load
>1adc	81					.byte $81 ; $d2 save
>1add	81					.byte $81 ; $d3 list
>1ade	81					.byte $81 ; $d4 new
>1adf	81					.byte $81 ; $d5 run

;******  Return to file: basic.asm


;******  Processing file: common/generated/vectors.asm

.1ae0					TokenVectorLow:
>1ae0	d2					.byte CommandNextLine & $FF            ; <<end>>
>1ae1	22					.byte BinaryAnd & $FF                  ; and
>1ae2	17					.byte BinaryOr & $FF                   ; or
>1ae3	0c					.byte BinaryXor & $FF                  ; xor
>1ae4	af					.byte Binary_Greater & $FF             ; >
>1ae5	9a					.byte Binary_Less & $FF                ; <
>1ae6	a1					.byte Binary_GreaterEqual & $FF        ; >=
>1ae7	a8					.byte Binary_LessEqual & $FF           ; <=
>1ae8	93					.byte Binary_NotEqual & $FF            ; <>
>1ae9	86					.byte Binary_Equal & $FF               ; =
>1aea	c4					.byte BinaryAdd & $FF                  ; +
>1aeb	cf					.byte BinarySub & $FF                  ; -
>1aec	da					.byte BinaryMult & $FF                 ; *
>1aed	e5					.byte BinaryDivide & $FF               ; /
>1aee	f3					.byte BinaryModulus & $FF              ; %
>1aef	3f					.byte BinaryShiftRight & $FF           ; >>
>1af0	2d					.byte BinaryShiftLeft & $FF            ; <<
>1af1	65					.byte IndirectWord & $FF               ; !
>1af2	70					.byte IndirectByte & $FF               ; ?
>1af3	7b					.byte IndirectString & $FF             ; $
>1af4	f8					.byte UnaryNot & $FF                   ; ~
>1af5	96					.byte UnaryParenthesis & $FF           ; (
>1af6	46					.byte UnaryHexMarker & $FF             ; &
>1af7	34					.byte UnaryRefToValue & $FF            ; @
>1af8	51					.byte UnaryLen & $FF                   ; len
>1af9	ed					.byte UnarySgn1 & $FF                  ; sgn
>1afa	a5					.byte UnaryAbs & $FF                   ; abs
>1afb	49					.byte UnaryRandom & $FF                ; random
>1afc	8a					.byte UnaryPage & $FF                  ; page
>1afd	9d					.byte UnaryTrue & $FF                  ; true
>1afe	a1					.byte UnaryFalse & $FF                 ; false
>1aff	03					.byte UnaryMin & $FF                   ; min
>1b00	06					.byte UnaryMax & $FF                   ; max
>1b01	b0					.byte UnarySys & $FF                   ; sys
>1b02	a5					.byte InstructionUndefined & $FF       ; code
>1b03	1f					.byte Unary_Timer & $FF                ; timer
>1b04	a3					.byte Event_Function & $FF             ; event
>1b05	17					.byte Unary_Get & $FF                  ; get
>1b06	a5					.byte InstructionUndefined & $FF       ; joy.x
>1b07	a5					.byte InstructionUndefined & $FF       ; joy.y
>1b08	a5					.byte InstructionUndefined & $FF       ; joy.btn
>1b09	0f					.byte Unary_Inkey & $FF                ; inkey
>1b0a	88					.byte Unary_Alloc & $FF                ; alloc
>1b0b	70					.byte UnaryChr & $FF                   ; chr
>1b0c	5a					.byte NoOp1 & $FF                      ; ,
>1b0d	5a					.byte NoOp2 & $FF                      ; ;
>1b0e	5a					.byte NoOp3 & $FF                      ; )
>1b0f	a5					.byte InstructionUndefined & $FF       ; ++
>1b10	a5					.byte InstructionUndefined & $FF       ; --
>1b11	a5					.byte InstructionUndefined & $FF       ; [
>1b12	a5					.byte InstructionUndefined & $FF       ; ]
>1b13	39					.byte Command_IF & $FF                 ; if
>1b14	e1					.byte Command_FOR & $FF                ; for
>1b15	8e					.byte Command_Repeat & $FF             ; repeat
>1b16	5a					.byte NoOp6 & $FF                      ; proc
>1b17	04					.byte Command_While & $FF              ; while
>1b18	6a					.byte Command_ENDIF & $FF              ; endif
>1b19	31					.byte Command_NEXT & $FF               ; next
>1b1a	97					.byte Command_Until & $FF              ; until
>1b1b	3a					.byte Command_EndProc & $FF            ; endproc
>1b1c	21					.byte Command_Wend & $FF               ; wend
>1b1d	6e					.byte Command_Rem & $FF                ; rem
>1b1e	6b					.byte Command_LET & $FF                ; let
>1b1f	6e					.byte Command_Rem2 & $FF               ; '
>1b20	ec					.byte Command_Colon & $FF              ; :
>1b21	5a					.byte NoOp7 & $FF                      ; then
>1b22	64					.byte Command_ELSE & $FF               ; else
>1b23	5a					.byte NoOp8 & $FF                      ; to
>1b24	5a					.byte NoOp9 & $FF                      ; step
>1b25	f3					.byte Command_Vdu & $FF                ; vdu
>1b26	d4					.byte Command_Print & $FF              ; print
>1b27	60					.byte Command_Call & $FF               ; call
>1b28	4e					.byte Command_Local & $FF              ; local
>1b29	f4					.byte Command_Goto & $FF               ; goto
>1b2a	d5					.byte Command_Gosub & $FF              ; gosub
>1b2b	e3					.byte Command_Return & $FF             ; return
>1b2c	0c					.byte Command_Assert & $FF             ; assert
>1b2d	f0					.byte Command_Stop & $FF               ; stop
>1b2e	ed					.byte Command_End & $FF                ; end
>1b2f	65					.byte Command_Dim & $FF                ; dim
>1b30	37					.byte CommandClear & $FF               ; clear
>1b31	a5					.byte InstructionUndefined & $FF       ; load
>1b32	a5					.byte InstructionUndefined & $FF       ; save
>1b33	a5					.byte InstructionUndefined & $FF       ; list
>1b34	cc					.byte Command_New & $FF                ; new
>1b35	b1					.byte Command_Run & $FF                ; run
.1b36					TokenVectorHigh:
>1b36	13					.byte CommandNextLine >> 8             ; <<end>>
>1b37	15					.byte BinaryAnd >> 8                   ; and
>1b38	15					.byte BinaryOr >> 8                    ; or
>1b39	15					.byte BinaryXor >> 8                   ; xor
>1b3a	15					.byte Binary_Greater >> 8              ; >
>1b3b	15					.byte Binary_Less >> 8                 ; <
>1b3c	15					.byte Binary_GreaterEqual >> 8         ; >=
>1b3d	15					.byte Binary_LessEqual >> 8            ; <=
>1b3e	15					.byte Binary_NotEqual >> 8             ; <>
>1b3f	15					.byte Binary_Equal >> 8                ; =
>1b40	14					.byte BinaryAdd >> 8                   ; +
>1b41	14					.byte BinarySub >> 8                   ; -
>1b42	14					.byte BinaryMult >> 8                  ; *
>1b43	14					.byte BinaryDivide >> 8                ; /
>1b44	14					.byte BinaryModulus >> 8               ; %
>1b45	15					.byte BinaryShiftRight >> 8            ; >>
>1b46	15					.byte BinaryShiftLeft >> 8             ; <<
>1b47	15					.byte IndirectWord >> 8                ; !
>1b48	15					.byte IndirectByte >> 8                ; ?
>1b49	15					.byte IndirectString >> 8              ; $
>1b4a	17					.byte UnaryNot >> 8                    ; ~
>1b4b	17					.byte UnaryParenthesis >> 8            ; (
>1b4c	18					.byte UnaryHexMarker >> 8              ; &
>1b4d	18					.byte UnaryRefToValue >> 8             ; @
>1b4e	18					.byte UnaryLen >> 8                    ; len
>1b4f	17					.byte UnarySgn1 >> 8                   ; sgn
>1b50	17					.byte UnaryAbs >> 8                    ; abs
>1b51	18					.byte UnaryRandom >> 8                 ; random
>1b52	17					.byte UnaryPage >> 8                   ; page
>1b53	17					.byte UnaryTrue >> 8                   ; true
>1b54	17					.byte UnaryFalse >> 8                  ; false
>1b55	18					.byte UnaryMin >> 8                    ; min
>1b56	18					.byte UnaryMax >> 8                    ; max
>1b57	17					.byte UnarySys >> 8                    ; sys
>1b58	14					.byte InstructionUndefined >> 8        ; code
>1b59	19					.byte Unary_Timer >> 8                 ; timer
>1b5a	18					.byte Event_Function >> 8              ; event
>1b5b	19					.byte Unary_Get >> 8                   ; get
>1b5c	14					.byte InstructionUndefined >> 8        ; joy.x
>1b5d	14					.byte InstructionUndefined >> 8        ; joy.y
>1b5e	14					.byte InstructionUndefined >> 8        ; joy.btn
>1b5f	19					.byte Unary_Inkey >> 8                 ; inkey
>1b60	18					.byte Unary_Alloc >> 8                 ; alloc
>1b61	18					.byte UnaryChr >> 8                    ; chr
>1b62	14					.byte NoOp1 >> 8                       ; ,
>1b63	14					.byte NoOp2 >> 8                       ; ;
>1b64	14					.byte NoOp3 >> 8                       ; )
>1b65	14					.byte InstructionUndefined >> 8        ; ++
>1b66	14					.byte InstructionUndefined >> 8        ; --
>1b67	14					.byte InstructionUndefined >> 8        ; [
>1b68	14					.byte InstructionUndefined >> 8        ; ]
>1b69	12					.byte Command_IF >> 8                  ; if
>1b6a	10					.byte Command_FOR >> 8                 ; for
>1b6b	13					.byte Command_Repeat >> 8              ; repeat
>1b6c	14					.byte NoOp6 >> 8                       ; proc
>1b6d	14					.byte Command_While >> 8               ; while
>1b6e	12					.byte Command_ENDIF >> 8               ; endif
>1b6f	11					.byte Command_NEXT >> 8                ; next
>1b70	13					.byte Command_Until >> 8               ; until
>1b71	1f					.byte Command_EndProc >> 8             ; endproc
>1b72	14					.byte Command_Wend >> 8                ; wend
>1b73	13					.byte Command_Rem >> 8                 ; rem
>1b74	12					.byte Command_LET >> 8                 ; let
>1b75	13					.byte Command_Rem2 >> 8                ; '
>1b76	13					.byte Command_Colon >> 8               ; :
>1b77	14					.byte NoOp7 >> 8                       ; then
>1b78	12					.byte Command_ELSE >> 8                ; else
>1b79	14					.byte NoOp8 >> 8                       ; to
>1b7a	14					.byte NoOp9 >> 8                       ; step
>1b7b	13					.byte Command_Vdu >> 8                 ; vdu
>1b7c	12					.byte Command_Print >> 8               ; print
>1b7d	1e					.byte Command_Call >> 8                ; call
>1b7e	1f					.byte Command_Local >> 8               ; local
>1b7f	11					.byte Command_Goto >> 8                ; goto
>1b80	11					.byte Command_Gosub >> 8               ; gosub
>1b81	11					.byte Command_Return >> 8              ; return
>1b82	10					.byte Command_Assert >> 8              ; assert
>1b83	13					.byte Command_Stop >> 8                ; stop
>1b84	13					.byte Command_End >> 8                 ; end
>1b85	10					.byte Command_Dim >> 8                 ; dim
>1b86	10					.byte CommandClear >> 8                ; clear
>1b87	14					.byte InstructionUndefined >> 8        ; load
>1b88	14					.byte InstructionUndefined >> 8        ; save
>1b89	14					.byte InstructionUndefined >> 8        ; list
>1b8a	12					.byte Command_New >> 8                 ; new
>1b8b	13					.byte Command_Run >> 8                 ; run

;******  Return to file: basic.asm


;******  Processing file: common/math/int32binary.asm

.1b8c					Int32And:
.1b8c	b5 28		lda $28,x			lda 	esInt0,x
.1b8e	35 29		and $29,x			and 	esInt0+1,x
.1b90	95 28		sta $28,x			sta 	esInt0,x
.1b92	b5 30		lda $30,x			lda 	esInt1,x
.1b94	35 31		and $31,x			and 	esInt1+1,x
.1b96	95 30		sta $30,x			sta 	esInt1,x
.1b98	b5 38		lda $38,x			lda 	esInt2,x
.1b9a	35 39		and $39,x			and 	esInt2+1,x
.1b9c	95 38		sta $38,x			sta 	esInt2,x
.1b9e	b5 40		lda $40,x			lda 	esInt3,x
.1ba0	35 41		and $41,x			and 	esInt3+1,x
.1ba2	95 40		sta $40,x			sta 	esInt3,x
.1ba4	60		rts				rts
.1ba5					Int32Or:
.1ba5	b5 28		lda $28,x			lda 	esInt0,x
.1ba7	15 29		ora $29,x			ora 	esInt0+1,x
.1ba9	95 28		sta $28,x			sta 	esInt0,x
.1bab	b5 30		lda $30,x			lda 	esInt1,x
.1bad	15 31		ora $31,x			ora 	esInt1+1,x
.1baf	95 30		sta $30,x			sta 	esInt1,x
.1bb1	b5 38		lda $38,x			lda 	esInt2,x
.1bb3	15 39		ora $39,x			ora 	esInt2+1,x
.1bb5	95 38		sta $38,x			sta 	esInt2,x
.1bb7	b5 40		lda $40,x			lda 	esInt3,x
.1bb9	15 41		ora $41,x			ora 	esInt3+1,x
.1bbb	95 40		sta $40,x			sta 	esInt3,x
.1bbd	60		rts				rts
.1bbe					Int32Xor:
.1bbe	b5 28		lda $28,x			lda 	esInt0,x
.1bc0	55 29		eor $29,x			eor 	esInt0+1,x
.1bc2	95 28		sta $28,x			sta 	esInt0,x
.1bc4	b5 30		lda $30,x			lda 	esInt1,x
.1bc6	55 31		eor $31,x			eor 	esInt1+1,x
.1bc8	95 30		sta $30,x			sta 	esInt1,x
.1bca	b5 38		lda $38,x			lda 	esInt2,x
.1bcc	55 39		eor $39,x			eor 	esInt2+1,x
.1bce	95 38		sta $38,x			sta 	esInt2,x
.1bd0	b5 40		lda $40,x			lda 	esInt3,x
.1bd2	55 41		eor $41,x			eor 	esInt3+1,x
.1bd4	95 40		sta $40,x			sta 	esInt3,x
.1bd6	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32compare.asm

.1bd7					Int32Equal:
.1bd7	b5 28		lda $28,x			lda 	esInt0,x
.1bd9	d5 29		cmp $29,x			cmp 	esInt0+1,x
.1bdb	d0 2b		bne $1c08			bne 	Int32CFail
.1bdd	b5 30		lda $30,x			lda 	esInt1,x
.1bdf	d5 31		cmp $31,x			cmp 	esInt1+1,x
.1be1	d0 25		bne $1c08			bne 	Int32CFail
.1be3	b5 38		lda $38,x			lda 	esInt2,x
.1be5	d5 39		cmp $39,x			cmp 	esInt2+1,x
.1be7	d0 1f		bne $1c08			bne 	Int32CFail
.1be9	b5 40		lda $40,x			lda 	esInt3,x
.1beb	d5 41		cmp $41,x			cmp 	esInt3+1,x
.1bed	d0 19		bne $1c08			bne 	Int32CFail
.1bef					Int32CSucceed:
.1bef	38		sec				sec
.1bf0	60		rts				rts
.1bf1					Int32Less:
.1bf1	38		sec				sec
.1bf2	b5 28		lda $28,x			lda		esInt0,x
.1bf4	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1bf6	b5 30		lda $30,x			lda		esInt1,x
.1bf8	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1bfa	b5 38		lda $38,x			lda		esInt2,x
.1bfc	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1bfe	b5 40		lda $40,x			lda		esInt3,x
.1c00	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1c02	50 02		bvc $1c06			bvc 	_I32LNoOverflow
.1c04	49 80		eor #$80			eor 	#$80
.1c06					_I32LNoOverflow
.1c06	30 e7		bmi $1bef			bmi 	Int32CSucceed
.1c08					Int32CFail:
.1c08	18		clc				clc
.1c09	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32divide.asm

.1c0a					Int32SDivide:
.1c0a	98		tya				tya  								; save Y, which is the count of negations
.1c0b	48		pha				pha
.1c0c	a0 00		ldy #$00			ldy 	#0 							; zero count
.1c0e	20 26 1c	jsr $1c26			jsr 	_Int32SRemSign 				; unsign TOS
.1c11	e8		inx				inx 								; unsign TOS+1
.1c12	20 26 1c	jsr $1c26			jsr 	_Int32SRemSign
.1c15	ca		dex				dex
.1c16	98		tya				tya 								; save sign count on stack
.1c17	48		pha				pha
.1c18	20 2f 1c	jsr $1c2f			jsr 	Int32UDivide 				; unsigned division
.1c1b	68		pla				pla 								; get sign count back
.1c1c	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.1c1e	f0 03		beq $1c23			beq 	_I32SNoNeg
.1c20	20 b6 1d	jsr $1db6			jsr 	Int32Negate
.1c23					_I32SNoNeg:
.1c23	68		pla				pla 								; restoe Y and exit
.1c24	a8		tay				tay
.1c25	60		rts				rts
.1c26					_Int32SRemSign:
.1c26	b5 40		lda $40,x			lda 	esInt3,x 					; is it -ve
.1c28	10 04		bpl $1c2e			bpl 	_Int32SRSExit
.1c2a	c8		iny				iny 								; increment the sign count
.1c2b	20 b6 1d	jsr $1db6			jsr 	Int32Negate 				; negate the value.
.1c2e					_Int32SRSExit:
.1c2e	60		rts				rts
.1c2f					Int32UDivide:
.1c2f	e8		inx				inx 								; clear A
.1c30	e8		inx				inx
.1c31	20 fc 1d	jsr $1dfc			jsr 	Int32False
.1c34	ca		dex				dex
.1c35	ca		dex				dex
.1c36	98		tya				tya 								; save Y on the stack
.1c37	48		pha				pha
.1c38	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.1c3a					_Int32UDLoop:
.1c3a	16 28		asl $28,x			asl 	esInt0,x					; shift QA left. First Q
.1c3c	36 30		rol $30,x			rol 	esInt1,x
.1c3e	36 38		rol $38,x			rol 	esInt2,x
.1c40	36 40		rol $40,x			rol 	esInt3,x
.1c42	36 2a		rol $2a,x			rol 	esInt0+2,x 					; then A.
.1c44	36 32		rol $32,x			rol 	esInt1+2,x
.1c46	36 3a		rol $3a,x			rol 	esInt2+2,x
.1c48	36 42		rol $42,x			rol 	esInt3+2,x
.1c4a	38		sec				sec 								; calculate A-M saving result on the stack
.1c4b	b5 2a		lda $2a,x			lda 	esInt0+2,x
.1c4d	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1c4f	48		pha				pha
.1c50	b5 32		lda $32,x			lda 	esInt1+2,x
.1c52	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1c54	48		pha				pha
.1c55	b5 3a		lda $3a,x			lda 	esInt2+2,x
.1c57	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1c59	48		pha				pha
.1c5a	b5 42		lda $42,x			lda 	esInt3+2,x
.1c5c	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1c5e	90 10		bcc $1c70			bcc		_Int32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.1c60	95 42		sta $42,x			sta 	esInt3+2,x 					; write result back to A
.1c62	68		pla				pla
.1c63	95 3a		sta $3a,x			sta 	esInt2+2,x
.1c65	68		pla				pla
.1c66	95 32		sta $32,x			sta 	esInt1+2,x
.1c68	68		pla				pla
.1c69	95 2a		sta $2a,x			sta 	esInt0+2,x
.1c6b	f6 28		inc $28,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.1c6d	4c 73 1c	jmp $1c73			jmp 	_Int32Next 					; do the next iteration
.1c70					_Int32NoSubtract:
.1c70	68		pla				pla
.1c71	68		pla				pla
.1c72	68		pla				pla
.1c73					_Int32Next:
.1c73	88		dey				dey 								; do this 32 times.
.1c74	d0 c4		bne $1c3a			bne 	_Int32UDLoop
.1c76	68		pla				pla 								; restore Y and exit
.1c77	a8		tay				tay
.1c78	60		rts				rts
.1c79					Int32Modulus:
.1c79	20 2f 1c	jsr $1c2f			jsr 	Int32UDivide 				; do the division.
.1c7c	b5 42		lda $42,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.1c7e	95 40		sta $40,x			sta 	esInt3,x
.1c80	b5 3a		lda $3a,x			lda 	esInt2+2,x
.1c82	95 38		sta $38,x			sta 	esInt2,x
.1c84	b5 32		lda $32,x			lda 	esInt1+2,x
.1c86	95 30		sta $30,x			sta 	esInt1,x
.1c88	b5 2a		lda $2a,x			lda 	esInt0+2,x
.1c8a	95 28		sta $28,x			sta 	esInt0,x
.1c8c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32fromstr.asm

.1c8d					Int32FromString:
.1c8d	85 03		sta $03				sta 	tempShort 					; save base
.1c8f	98		tya				tya
.1c90	48		pha				pha
.1c91	a0 00		ldy #$00			ldy 	#0 							; set index into string being read
.1c93	b1 04		lda ($04),y			lda 	(temp0),y 					; look at first character
.1c95	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.1c97	d0 01		bne $1c9a			bne 	_I32FSNotNegative
.1c99	c8		iny				iny 								; if so consume it.
.1c9a					_I32FSNotNegative:
.1c9a	a5 03		lda $03				lda 	tempShort 					; get the base back.
.1c9c	c0 00		cpy #$00			cpy 	#0 							; if we read a -ve (e.g. Y != 0)
.1c9e	f0 02		beq $1ca2			beq 	_I32FSNN2
.1ca0	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.1ca2					_I32FSNN2:
.1ca2	48		pha				pha 								; save base + final sign on stack.
.1ca3	20 fc 1d	jsr $1dfc			jsr 	Int32False 					; zero the return value.
.1ca6					I32FSMainLoop:
.1ca6	68		pla				pla 								; get the base back into tempshort
.1ca7	48		pha				pha
.1ca8	29 7f		and #$7f			and 	#$7F
.1caa	85 03		sta $03				sta 	tempShort
.1cac	b1 04		lda ($04),y			lda 	(temp0),y 					; look at next character.
.1cae	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.1cb0	90 02		bcc $1cb4			bcc 	_I32FSNotLC
.1cb2	e9 20		sbc #$20			sbc 	#32
.1cb4					_I32FSNotLC:
.1cb4	38		sec				sec 								; subtract 48 (ASCII "0")
.1cb5	e9 30		sbc #$30			sbc 	#"0"
.1cb7	90 26		bcc $1cdf			bcc 	_I32FSDone 					; nothing more to do.
.1cb9	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.1cbb	90 06		bcc $1cc3			bcc 	_I32FSValidate
.1cbd	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.1cbf	90 1e		bcc $1cdf			bcc 	_I32FSDone
.1cc1	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.1cc3					_I32FSValidate:
.1cc3	c5 03		cmp $03				cmp 	tempShort 					; compare against the base.
.1cc5	b0 18		bcs $1cdf			bcs 	_I32FSDone 					; sorry, too large for this base.
.1cc7	48		pha				pha 								; save the new digit value.
.1cc8	e8		inx				inx 								; put base into next slot.
.1cc9	a5 03		lda $03				lda 	tempShort
.1ccb	20 0b 1e	jsr $1e0b			jsr 	Int32Set8Bit
.1cce	ca		dex				dex
.1ccf	20 21 1d	jsr $1d21			jsr 	Int32Multiply 				; multiply current by the base
.1cd2	e8		inx				inx
.1cd3	68		pla				pla  								; put additive into next slot
.1cd4	20 0b 1e	jsr $1e0b			jsr 	Int32Set8Bit
.1cd7	ca		dex				dex
.1cd8	20 ed 1c	jsr $1ced			jsr 	Int32Add 					; and add it
.1cdb	c8		iny				iny 								; look at next character
.1cdc	4c a6 1c	jmp $1ca6			jmp 	I32FSMainLoop 				; and go round again.
.1cdf					_I32FSDone:
.1cdf	68		pla				pla 								; get base/final sign back
.1ce0	10 04		bpl $1ce6			bpl 	_I32FSNN3
.1ce2	88		dey				dey 								; one fewer character to allow for the - prefix.
.1ce3	20 b6 1d	jsr $1db6			jsr 	Int32Negate 				; negate the result.
.1ce6					_I32FSNN3:
.1ce6	84 03		sty $03				sty 	tempShort 					; save the count of characters read
.1ce8	68		pla				pla
.1ce9	a8		tay				tay
.1cea	a5 03		lda $03				lda 	tempShort 					; get the count of characters read into A and exit
.1cec	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32math.asm

.1ced					Int32Add:
.1ced	18		clc				clc
.1cee	b5 28		lda $28,x			lda 	esInt0,x
.1cf0	75 29		adc $29,x			adc 	esInt0+1,x
.1cf2	95 28		sta $28,x			sta 	esInt0,x
.1cf4	b5 30		lda $30,x			lda 	esInt1,x
.1cf6	75 31		adc $31,x			adc 	esInt1+1,x
.1cf8	95 30		sta $30,x			sta 	esInt1,x
.1cfa	b5 38		lda $38,x			lda 	esInt2,x
.1cfc	75 39		adc $39,x			adc 	esInt2+1,x
.1cfe	95 38		sta $38,x			sta 	esInt2,x
.1d00	b5 40		lda $40,x			lda 	esInt3,x
.1d02	75 41		adc $41,x			adc 	esInt3+1,x
.1d04	95 40		sta $40,x			sta 	esInt3,x
.1d06	60		rts				rts
.1d07					Int32Sub:
.1d07	38		sec				sec
.1d08	b5 28		lda $28,x			lda 	esInt0,x
.1d0a	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1d0c	95 28		sta $28,x			sta 	esInt0,x
.1d0e	b5 30		lda $30,x			lda 	esInt1,x
.1d10	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1d12	95 30		sta $30,x			sta 	esInt1,x
.1d14	b5 38		lda $38,x			lda 	esInt2,x
.1d16	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1d18	95 38		sta $38,x			sta 	esInt2,x
.1d1a	b5 40		lda $40,x			lda 	esInt3,x
.1d1c	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1d1e	95 40		sta $40,x			sta 	esInt3,x
.1d20	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32multiply.asm

.1d21					Int32Multiply:
.1d21	e8		inx				inx 								; copy 2nd -> 3rd
.1d22	20 47 1d	jsr $1d47			jsr 	Int32CopyUp
.1d25	ca		dex				dex
.1d26	20 47 1d	jsr $1d47			jsr 	Int32CopyUp 				; copy 1st -> 2nd
.1d29	20 fc 1d	jsr $1dfc			jsr 	Int32False 					; zero 1st.
.1d2c					_I32Loop:
.1d2c	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.1d2e	29 01		and #$01			and 	#1
.1d30	f0 03		beq $1d35			beq 	_I32NoAdd 					; if set
.1d32	20 ed 1c	jsr $1ced			jsr 	Int32Add 					; add 2nd to 1st.
.1d35					_I32NoAdd:
.1d35	e8		inx				inx 								; shift 2nd left
.1d36	20 11 1e	jsr $1e11			jsr 	Int32ShiftLeft
.1d39	e8		inx				inx  								; shift 3rd right
.1d3a	20 1a 1e	jsr $1e1a			jsr 	Int32ShiftRight
.1d3d	20 23 1e	jsr $1e23			jsr 	Int32Zero 					; check if zero.
.1d40	08		php				php 								; save status bits
.1d41	ca		dex				dex 	 							; point back to 1st
.1d42	ca		dex				dex
.1d43	28		plp				plp 								; get status bits
.1d44	d0 e6		bne $1d2c			bne 	_I32Loop 					; if non-zero keep going.
.1d46	60		rts				rts
.1d47					Int32CopyUp:
.1d47	b5 28		lda $28,x			lda 	esInt0,x
.1d49	95 29		sta $29,x			sta 	esInt0+1,x
.1d4b	b5 30		lda $30,x			lda 	esInt1,x
.1d4d	95 31		sta $31,x			sta 	esInt1+1,x
.1d4f	b5 38		lda $38,x			lda 	esInt2,x
.1d51	95 39		sta $39,x			sta 	esInt2+1,x
.1d53	b5 40		lda $40,x			lda 	esInt3,x
.1d55	95 41		sta $41,x			sta 	esInt3+1,x
.1d57	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32tostr.asm

.1d58					Int32ToString:
.1d58	48		pha				pha 								; save base
.1d59	85 03		sta $03				sta 	tempShort 					; save target base.
.1d5b	a9 00		lda #$00			lda 	#0
.1d5d	8d a4 08	sta $08a4			sta 	IToSCount 					; clear character count.
.1d60	98		tya				tya
.1d61	48		pha				pha
.1d62	a5 03		lda $03				lda 	tempShort 					; check if we are signed conversion
.1d64	10 10		bpl $1d76			bpl 	_I32TSUnsigned
.1d66	48		pha				pha 								; save base on stack.
.1d67	b5 40		lda $40,x			lda 	esInt3,x 					; is it actually negative
.1d69	10 08		bpl $1d73			bpl 	_I32TSNoFlip
.1d6b	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.1d6d	20 a2 1d	jsr $1da2			jsr 	I32WriteCharacter
.1d70	20 b6 1d	jsr $1db6			jsr 	Int32Negate 				; negate the value.
.1d73					_I32TSNoFlip:
.1d73	68		pla				pla 								; get the base back
.1d74	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.1d76					_I32TSUnsigned:
.1d76	20 7d 1d	jsr $1d7d			jsr 	I32DivideWrite 				; recursive code to output string.
.1d79	68		pla				pla
.1d7a	a8		tay				tay
.1d7b	68		pla				pla
.1d7c	60		rts				rts
.1d7d					I32DivideWrite:
.1d7d	48		pha				pha 								; save the divisor/base
.1d7e	e8		inx				inx 								; write in the dividing position.
.1d7f	20 0b 1e	jsr $1e0b			jsr 	Int32Set8Bit
.1d82	ca		dex				dex
.1d83	20 2f 1c	jsr $1c2f			jsr 	Int32UDivide 				; divide number by base.
.1d86	68		pla				pla 								; get the base into Y
.1d87	a8		tay				tay
.1d88	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.1d8a	48		pha				pha
.1d8b	20 23 1e	jsr $1e23			jsr 	Int32Zero 					; is the result zero ?
.1d8e	f0 04		beq $1d94			beq 	_I32NoRecurse 				; if so, don't recurse.
.1d90	98		tya				tya 								; put base into A
.1d91	20 7d 1d	jsr $1d7d			jsr 	I32DivideWrite 				; and jsr the dividor recursively.
.1d94					_I32NoRecurse:
.1d94	68		pla				pla 								; get the remainder back
.1d95	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.1d97	90 02		bcc $1d9b			bcc 	_I32NotHex
.1d99	69 06		adc #$06			adc 	#7-1
.1d9b					_I32NotHex:
.1d9b	18		clc				clc 								; make it ASCII
.1d9c	69 30		adc #$30			adc 	#48
.1d9e	20 a2 1d	jsr $1da2			jsr 	I32WriteCharacter 			; write the character out
.1da1	60		rts				rts 								; and exit.
.1da2					I32WriteCharacter:
.1da2	ac a4 08	ldy $08a4			ldy 	IToSCount 					; get position
.1da5	91 04		sta ($04),y			sta 	(temp0),y 					; write out with trailing 0
.1da7	c8		iny				iny
.1da8	a9 00		lda #$00			lda 	#0
.1daa	91 04		sta ($04),y			sta 	(temp0),y
.1dac	ee a4 08	inc $08a4			inc 	IToSCount 					; bump count
.1daf	60		rts				rts
.1db0	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32unary.asm

.1db1					Int32Absolute:
.1db1	b5 40		lda $40,x			lda 	esInt3,x 					; use negate code if -ve.
.1db3	30 01		bmi $1db6			bmi 	Int32Negate
.1db5	60		rts				rts
.1db6					Int32Negate:
.1db6	38		sec				sec
.1db7	a9 00		lda #$00			lda 	#0
.1db9	f5 28		sbc $28,x			sbc 	esInt0,x
.1dbb	95 28		sta $28,x			sta 	esInt0,x
.1dbd	a9 00		lda #$00			lda 	#0
.1dbf	f5 30		sbc $30,x			sbc 	esInt1,x
.1dc1	95 30		sta $30,x			sta 	esInt1,x
.1dc3	a9 00		lda #$00			lda 	#0
.1dc5	f5 38		sbc $38,x			sbc 	esInt2,x
.1dc7	95 38		sta $38,x			sta 	esInt2,x
.1dc9	a9 00		lda #$00			lda 	#0
.1dcb	f5 40		sbc $40,x			sbc 	esInt3,x
.1dcd	95 40		sta $40,x			sta 	esInt3,x
.1dcf	60		rts				rts
.1dd0					Int32Not:
.1dd0	b5 28		lda $28,x			lda 	esInt0,x
.1dd2	49 ff		eor #$ff			eor 	#$FF
.1dd4	95 28		sta $28,x			sta 	esInt0,x
.1dd6	b5 30		lda $30,x			lda 	esInt1,x
.1dd8	49 ff		eor #$ff			eor 	#$FF
.1dda	95 30		sta $30,x			sta 	esInt1,x
.1ddc	b5 38		lda $38,x			lda 	esInt2,x
.1dde	49 ff		eor #$ff			eor 	#$FF
.1de0	95 38		sta $38,x			sta 	esInt2,x
.1de2	b5 40		lda $40,x			lda 	esInt3,x
.1de4	49 ff		eor #$ff			eor 	#$FF
.1de6	95 40		sta $40,x			sta 	esInt3,x
.1de8	60		rts				rts
.1de9					Int32Sign:
.1de9	b5 40		lda $40,x			lda 	esInt3,x					; look at MSB
.1deb	30 0b		bmi $1df8			bmi 	Int32True 					; if set return -1 (true)
.1ded	20 23 1e	jsr $1e23			jsr 	Int32Zero 					; is it zero ?
.1df0	f0 0a		beq $1dfc			beq 	Int32False 					; if zero return 0 (false)
.1df2	20 fc 1d	jsr $1dfc			jsr 	Int32False 					; > 0 return 1
.1df5	f6 28		inc $28,x			inc 	esInt0,x
.1df7	60		rts				rts
.1df8					Int32True:
.1df8	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.1dfa	d0 02		bne $1dfe			bne 	Int32WriteAll
.1dfc					Int32False:
.1dfc	a9 00		lda #$00			lda 	#0
.1dfe					Int32WriteAll:
.1dfe	95 28		sta $28,x			sta 	esInt0,x
.1e00					Int32Write123:
.1e00	95 30		sta $30,x			sta 	esInt1,x
.1e02	95 38		sta $38,x			sta 	esInt2,x
.1e04	95 40		sta $40,x			sta 	esInt3,x
.1e06	a9 00		lda #$00			lda 	#$00						; and make it an integer
.1e08	95 20		sta $20,x			sta 	esType,x
.1e0a	60		rts				rts
.1e0b					Int32Set8Bit:
.1e0b	95 28		sta $28,x			sta 	esInt0,x
.1e0d	a9 00		lda #$00			lda 	#0
.1e0f	f0 ef		beq $1e00			beq		Int32Write123
.1e11					Int32ShiftLeft:
.1e11	16 28		asl $28,x			asl 	esInt0,x
.1e13	36 30		rol $30,x			rol	 	esInt1,x
.1e15	36 38		rol $38,x			rol	 	esInt2,x
.1e17	36 40		rol $40,x			rol	 	esInt3,x
.1e19	60		rts				rts
.1e1a					Int32ShiftRight:
.1e1a	56 40		lsr $40,x			lsr 	esInt3,x
.1e1c	76 38		ror $38,x			ror 	esInt2,x
.1e1e	76 30		ror $30,x			ror 	esInt1,x
.1e20	76 28		ror $28,x			ror 	esInt0,x
.1e22	60		rts				rts
.1e23					Int32Zero:
.1e23	b5 28		lda $28,x			lda 	esInt0,x
.1e25	15 30		ora $30,x			ora 	esInt1,x
.1e27	15 38		ora $38,x			ora 	esInt2,x
.1e29	15 40		ora $40,x			ora 	esInt3,x
.1e2b	60		rts				rts
.1e2c					Int32Random:
.1e2c	98		tya				tya
.1e2d	48		pha				pha
.1e2e	a0 07		ldy #$07			ldy 	#7
.1e30	ad 88 08	lda $0888			lda 	Seed32+0
.1e33	d0 03		bne $1e38			bne 	_Random1
.1e35	a8		tay				tay
.1e36	a9 aa		lda #$aa			lda		#$AA
.1e38					_Random1:
.1e38	0a		asl a				asl 	a
.1e39	2e 89 08	rol $0889			rol 	Seed32+1
.1e3c	2e 8a 08	rol $088a			rol 	Seed32+2
.1e3f	2e 8b 08	rol $088b			rol 	Seed32+3
.1e42	90 02		bcc $1e46			bcc 	_Random2
.1e44	49 c5		eor #$c5			eor 	#$C5
.1e46					_Random2:
.1e46	88		dey				dey
.1e47	d0 ef		bne $1e38			bne 	_Random1
.1e49	8d 88 08	sta $0888			sta 	Seed32+0
.1e4c	95 28		sta $28,x			sta 	esInt0,x
.1e4e	ad 89 08	lda $0889			lda 	Seed32+1
.1e51	95 30		sta $30,x			sta 	esInt1,x
.1e53	ad 8a 08	lda $088a			lda 	Seed32+2
.1e56	95 38		sta $38,x			sta 	esInt2,x
.1e58	ad 8b 08	lda $088b			lda 	Seed32+3
.1e5b	95 40		sta $40,x			sta 	esInt3,x
.1e5d	68		pla				pla
.1e5e	a8		tay				tay
.1e5f	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/procedures/call.asm

.1e60					Command_Call:
.1e60	98		tya				tya 								; Y offset - 4
.1e61	38		sec				sec
.1e62	e9 04		sbc #$04			sbc 	#4
.1e64	18		clc				clc
.1e65	65 00		adc $00				adc 	codePtr 					; add to CodePtr -> temp1
.1e67	85 06		sta $06				sta 	temp1
.1e69	a5 01		lda $01				lda 	codePtr+1
.1e6b	69 00		adc #$00			adc 	#0
.1e6d	85 07		sta $07				sta 	temp1+1
.1e6f	a2 00		ldx #$00			ldx 	#0
.1e71					_CCCalcHash:
.1e71	8a		txa				txa 								; which is simple additive
.1e72	18		clc				clc
.1e73	71 00		adc ($00),y			adc 	(codePtr),y
.1e75	aa		tax				tax
.1e76	b1 00		lda ($00),y			lda 	(codePtr),y 				; until added end marker.
.1e78	c8		iny				iny
.1e79	c9 30		cmp #$30			cmp 	#$30
.1e7b	b0 f4		bcs $1e71			bcs 	_CCCalCHash
.1e7d	8a		txa				txa
.1e7e	48		pha				pha
.1e7f	20 38 14	jsr $1438			jsr 	CheckLeftParen 				; check for opening parameter bracket.
.1e82	a2 00		ldx #$00			ldx 	#0 							; actually start at 1 with pre-increment.
.1e84					_CCEvaluateParameters:
.1e84	b1 00		lda ($00),y			lda 	(codePtr),y 				; hit )
.1e86	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN
.1e88	f0 13		beq $1e9d			beq 	_CCHaveParams
.1e8a					_CCNextParam:
.1e8a	e8		inx				inx 								; first parameter goes in offset #1.
.1e8b	20 48 16	jsr $1648			jsr 	EvaluateLevelAX 			; evaluate and derefernce.
.1e8e	20 05 17	jsr $1705			jsr 	DeRefTop
.1e91	b1 00		lda ($00),y			lda 	(codePtr),y 				; check if followed by a comma
.1e93	c8		iny				iny
.1e94	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; if so go back
.1e96	f0 f2		beq $1e8a			beq 	_CCNextParam
.1e98	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN 				; if not ) error
.1e9a	d0 45		bne $1ee1			bne 	_CCSyntax
.1e9c	88		dey				dey 								; point (codePtr),y to the )
.1e9d					_CCHaveParams:
.1e9d	8e ab 08	stx $08ab			stx 	ParamCount 					; save number of parameters evaluated.
.1ea0	68		pla				pla 								; put the hash into temp2
.1ea1	85 08		sta $08				sta 	temp2
.1ea3	98		tya				tya
.1ea4	48		pha				pha
.1ea5	ad a9 08	lda $08a9			lda 	ProcTable 					; copy ProcTable to temp0
.1ea8	85 04		sta $04				sta 	temp0
.1eaa	ad aa 08	lda $08aa			lda 	ProcTable+1
.1ead	85 05		sta $05				sta 	temp0+1
.1eaf					_CCCheckLoop:
.1eaf	a0 01		ldy #$01			ldy 	#1 							; check the MSB of the line entry, if zero, then not found.
.1eb1	b1 04		lda ($04),y			lda 	(temp0),y
.1eb3	f0 2f		beq $1ee4			beq 	_CCNoProc
.1eb5	85 0b		sta $0b				sta 	temp3+1 					; save in temp3+1
.1eb7	c8		iny				iny 								; get the hash
.1eb8	b1 04		lda ($04),y			lda 	(temp0),y
.1eba	c5 08		cmp $08				cmp 	temp2 						; does it match ?
.1ebc	d0 15		bne $1ed3			bne 	_CCNext
.1ebe	a0 00		ldy #$00			ldy 	#0 							; get LSB into temp3
.1ec0	b1 04		lda ($04),y			lda 	(temp0),y
.1ec2	85 0a		sta $0a				sta 	temp3
.1ec4	a0 03		ldy #$03			ldy 	#3 							; start offset 4 pre-increment.
.1ec6					_CCCompare:
.1ec6	c8		iny				iny 								; check match
.1ec7	b1 0a		lda ($0a),y			lda 	(temp3),y
.1ec9	d1 06		cmp ($06),y			cmp 	(temp1),y
.1ecb	d0 06		bne $1ed3			bne 	_CCNext
.1ecd	c9 30		cmp #$30			cmp 	#$30 						; stop if reached actual match.
.1ecf	b0 f5		bcs $1ec6			bcs 	_CCCompare
.1ed1	90 17		bcc $1eea			bcc 	_CCFound 					; yes, a match.
.1ed3					_CCNext:
.1ed3	18		clc				clc 								; go four on, table size.
.1ed4	a5 04		lda $04				lda 	temp0
.1ed6	69 04		adc #$04			adc 	#4
.1ed8	85 04		sta $04				sta 	temp0
.1eda	90 d3		bcc $1eaf			bcc 	_CCCheckLoop
.1edc	e6 05		inc $05				inc 	temp0+1
.1ede	4c af 1e	jmp $1eaf			jmp 	_CCCheckLoop
.1ee1					_CCSyntax:
.1ee1	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax
.1ee4					_CCNoProc:
.1ee4	4c 70 19	jmp $1970			jmp 	EHandlerBadProc
.1ee7					_CCParamErr:
.1ee7	4c 4f 1a	jmp $1a4f			jmp 	EHandlerParameters
.1eea					_CCFound:
.1eea	68		pla				pla
.1eeb	a8		tay				tay
.1eec	c8		iny				iny 								; now point to the token after it
.1eed	a9 54		lda #$54			lda 	#SMProcedure				; open a procedure frame
.1eef	20 67 20	jsr $2067			jsr 	StackOpen
.1ef2	20 bb 20	jsr $20bb			jsr 	StackSavePosition 			; save return address on the stack.
.1ef5	a0 03		ldy #$03			ldy 	#3 							; get the offset to the start of the parameter list
.1ef7	b1 04		lda ($04),y			lda 	(temp0),y
.1ef9	a8		tay				tay
.1efa	a5 0a		lda $0a				lda 	temp3 						; copy start of line into code Ptr
.1efc	85 00		sta $00				sta 	codePtr
.1efe	a5 0b		lda $0b				lda		temp3+1
.1f00	85 01		sta $01				sta 	codePtr+1
.1f02	a2 00		ldx #$00			ldx 	#0
.1f04					_CCSaveParams:
.1f04	b1 00		lda ($00),y			lda 	(codePtr),y 				; found the right bracket
.1f06	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN
.1f08	f0 29		beq $1f33			beq 	_CCExit
.1f0a					_CCParamLoop:
.1f0a	e8		inx				inx 								; point to the parameter we will save
.1f0b	20 67 1f	jsr $1f67			jsr 	GetLocalTerm 				; get and localise a parameter. Address to copy to is in temp0.
.1f0e	98		tya				tya
.1f0f	48		pha				pha
.1f10	a0 00		ldy #$00			ldy 	#0
.1f12	b5 28		lda $28,x			lda 	esInt0,x
.1f14	91 04		sta ($04),y			sta 	(temp0),y
.1f16	c8		iny				iny
.1f17	b5 30		lda $30,x			lda 	esInt1,x
.1f19	91 04		sta ($04),y			sta 	(temp0),y
.1f1b	c8		iny				iny
.1f1c	b5 38		lda $38,x			lda 	esInt2,x
.1f1e	91 04		sta ($04),y			sta 	(temp0),y
.1f20	c8		iny				iny
.1f21	b5 40		lda $40,x			lda 	esInt3,x
.1f23	91 04		sta ($04),y			sta 	(temp0),y
.1f25	68		pla				pla
.1f26	a8		tay				tay
.1f27	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and skip next
.1f29	c8		iny				iny
.1f2a	c9 ac		cmp #$ac			cmp 	#KWD_COMMA 					; if , go round again.
.1f2c	f0 dc		beq $1f0a			beq 	_CCParamLoop
.1f2e	c9 ae		cmp #$ae			cmp 	#KWD_RPAREN 				; should be )
.1f30	d0 af		bne $1ee1			bne 	_CCSyntax
.1f32	88		dey				dey 								; Y now points to )
.1f33					_CCExit:
.1f33	ec ab 08	cpx $08ab			cpx 	ParamCount 					; parameters match
.1f36	d0 af		bne $1ee7			bne 	_CCParamErr
.1f38	c8		iny				iny 								; skip the right bracket
.1f39	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/procedures/endproc.asm

.1f3a					Command_EndProc:
.1f3a	20 ce 20	jsr $20ce			jsr 	StackPopLocals 				; restore local variables.
.1f3d	a9 54		lda #$54			lda 	#SMProcedure				; check TOS is PROC
.1f3f	20 8c 20	jsr $208c			jsr 	StackCheck
.1f42	d0 07		bne $1f4b			bne 	_EPError
.1f44	20 ab 20	jsr $20ab			jsr 	StackLoadPosition 			; restore position and drop
.1f47	20 97 20	jsr $2097			jsr 	StackClose
.1f4a	60		rts				rts
.1f4b					_EPError:
.1f4b	4c f6 19	jmp $19f6			jmp 	EHandlerNoProc

;******  Return to file: basic.asm


;******  Processing file: common/procedures/local.asm

.1f4e					Command_Local:
.1f4e	20 67 1f	jsr $1f67			jsr 	GetLocalTerm 				; get a local variable.
.1f51	98		tya				tya
.1f52	48		pha				pha
.1f53	a0 00		ldy #$00			ldy 	#0 							; erase the variable.
.1f55	98		tya				tya
.1f56					_CLClear:
.1f56	91 04		sta ($04),y			sta 	(temp0),y
.1f58	c8		iny				iny
.1f59	c0 04		cpy #$04			cpy 	#4
.1f5b	d0 f9		bne $1f56			bne 	_CLClear
.1f5d	68		pla				pla
.1f5e	a8		tay				tay
.1f5f	b1 00		lda ($00),y			lda 	(codePtr),y					; check comma
.1f61	c8		iny				iny
.1f62	c9 ac		cmp #$ac			cmp 	#KWD_COMMA
.1f64	f0 e8		beq $1f4e			beq 	Command_Local
.1f66	60		rts				rts
.1f67					GetLocalTerm:
.1f67	8a		txa				txa
.1f68	48		pha				pha
.1f69	a2 00		ldx #$00			ldx 	#0 							; start on stack
.1f6b	a9 07		lda #$07			lda 	#7  						; get a term
.1f6d	20 48 16	jsr $1648			jsr 	EvaluateLevelAX 			; this is the variable/parameter to localise.
.1f70	b5 20		lda $20,x			lda 	esType,x 					; which should be a reference of some sort
.1f72	10 26		bpl $1f9a			bpl 	_GLTSyntax 					; if not, syntax error.
.1f74	98		tya				tya
.1f75	48		pha				pha
.1f76	a9 67		lda #$67			lda 	#SMLocal 					; create stack frame.
.1f78	20 67 20	jsr $2067			jsr 	StackOpen
.1f7b	a0 05		ldy #$05			ldy 	#5
.1f7d	b5 28		lda $28,x			lda 	esInt0,x 					; copy address to temp0 and to stack+5,stack+6
.1f7f	85 04		sta $04				sta 	temp0
.1f81	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1f83	b5 30		lda $30,x			lda 	esInt1,x
.1f85	85 05		sta $05				sta 	temp0+1
.1f87	c8		iny				iny
.1f88	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1f8a	a0 00		ldy #$00			ldy 	#0 							; now copy data into stack1-4
.1f8c					_GLTCopy:
.1f8c	b1 04		lda ($04),y			lda 	(temp0),y
.1f8e	c8		iny				iny
.1f8f	91 0e		sta ($0e),y			sta 	(stackPtr),y
.1f91	c0 04		cpy #$04			cpy 	#4
.1f93	d0 f7		bne $1f8c			bne 	_GLTCopy
.1f95	68		pla				pla
.1f96	a8		tay				tay
.1f97	68		pla				pla
.1f98	aa		tax				tax
.1f99	60		rts				rts
.1f9a					_GLTSyntax:
.1f9a	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/procedures/scanproc.asm

.1f9d					BuildProcedureList:
.1f9d	a5 10		lda $10				lda 	LowMemory 					; starts at low memory
.1f9f	8d a9 08	sta $08a9			sta 	ProcTable
.1fa2	a5 11		lda $11				lda 	LowMemory+1
.1fa4	8d aa 08	sta $08aa			sta 	ProcTable+1
.1fa7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.1fa9	85 04		sta $04				sta 	temp0
.1fab	a9 23		lda #$23			lda 	#(BasicProgram) >> 8
.1fad	85 05		sta $05				sta 	1+(temp0)
.1faf					_BPLLoop:
.1faf	a0 00		ldy #$00			ldy 	#0
.1fb1	b1 04		lda ($04),y			lda 	(temp0),y 					; reached then end ?
.1fb3	f0 49		beq $1ffe			beq 	_BPLExit
.1fb5	a0 03		ldy #$03			ldy 	#3 							; look to see if it is PROC
.1fb7	b1 04		lda ($04),y			lda 	(temp0),y
.1fb9	c9 b6		cmp #$b6			cmp 	#KWD_PROC
.1fbb	f0 10		beq $1fcd			beq 	_BPLFoundProc
.1fbd					_BPLNext:
.1fbd	a0 00		ldy #$00			ldy 	#0 							; next line.
.1fbf	18		clc				clc
.1fc0	b1 04		lda ($04),y			lda 	(temp0),y
.1fc2	65 04		adc $04				adc 	temp0
.1fc4	85 04		sta $04				sta 	temp0
.1fc6	90 e7		bcc $1faf			bcc 	_BPLLoop
.1fc8	e6 05		inc $05				inc 	temp0+1
.1fca	4c af 1f	jmp $1faf			jmp 	_BPLLoop
.1fcd					_BPLFoundProc:
.1fcd	a9 00		lda #$00			lda 	#0 							; for calculating the hash.
.1fcf	85 06		sta $06				sta 	temp1
.1fd1	a0 04		ldy #$04			ldy 	#4
.1fd3					_BPLCalcHash:
.1fd3	18		clc				clc 								; add the tokens making the identifier to make an 8 bit hash.
.1fd4	a5 06		lda $06				lda 	temp1
.1fd6	71 04		adc ($04),y			adc 	(temp0),y
.1fd8	85 06		sta $06				sta 	temp1
.1fda	b1 04		lda ($04),y			lda 	(temp0),y
.1fdc	c8		iny				iny
.1fdd	c9 30		cmp #$30			cmp		#$30
.1fdf	b0 f2		bcs $1fd3			bcs 	_BPLCalcHash
.1fe1	b1 04		lda ($04),y			lda 	(temp0),y 					; check for (
.1fe3	c9 95		cmp #$95			cmp 	#KWD_LPAREN
.1fe5	d0 2f		bne $2016			bne 	BPSyntax
.1fe7	c8		iny				iny 								; first char after (
.1fe8					_BPLAddRecord:
.1fe8	a5 04		lda $04				lda 	temp0 						; write address of line (+0,+1)
.1fea	20 07 20	jsr $2007			jsr 	WriteBPL
.1fed	a5 05		lda $05				lda 	temp0+1
.1fef	20 07 20	jsr $2007			jsr 	WriteBPL
.1ff2	a5 06		lda $06				lda 	temp1 						; write out sum hash (+2)
.1ff4	20 07 20	jsr $2007			jsr 	WriteBPL
.1ff7	98		tya				tya 								; offset to first character of parameter (+3)
.1ff8	20 07 20	jsr $2007			jsr 	WriteBPL
.1ffb	4c bd 1f	jmp $1fbd			jmp 	_BPLNext
.1ffe					_BPLExit:
.1ffe	a9 00		lda #$00			lda 	#0 							; write two zeros indicating end.
.2000	20 07 20	jsr $2007			jsr 	WriteBPL
.2003	20 07 20	jsr $2007			jsr 	WriteBPL
.2006	60		rts				rts
.2007					WriteBPL:
.2007	84 03		sty $03				sty 	tempShort
.2009	a0 00		ldy #$00			ldy 	#0
.200b	91 10		sta ($10),y			sta 	(LowMemory),y
.200d	e6 10		inc $10				inc 	LowMemory
.200f	d0 02		bne $2013			bne 	_WBPLExit
.2011	e6 11		inc $11				inc 	LowMemory+1
.2013					_WBPLExit:
.2013	a4 03		ldy $03				ldy 	tempShort
.2015	60		rts				rts
.2016					BPSyntax:
.2016	4c 69 1a	jmp $1a69			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/utility/scanner.asm

.2019					ScanForward:
.2019	85 0a		sta $0a				sta 	temp3 						; save tokens to search in temp3/temp3+1
.201b	86 0b		stx $0b				stx 	temp3+1
.201d	a9 00		lda #$00			lda 	#0 							; temp2 counts structure levels.
.201f	85 08		sta $08				sta 	temp2
.2021	b1 00		lda ($00),y	_SFLoop:lda 	(codePtr),y 				; look at the high token.
.2023	c9 80		cmp #$80			cmp 	#$80
.2025	f0 13		beq $203a			beq 	_SFNextLine 				; if $80 go to next line.
.2027	b0 17		bcs $2040			bcs  	_SFFoundCommand				; if -ve its a token
.2029	c9 60		cmp #$60			cmp 	#$60 						; if $60 it's a string.
.202b	f0 04		beq $2031			beq 	_SFSkipString
.202d					_SFNextToken:
.202d	c8		iny				iny
.202e	4c 21 20	jmp $2021			jmp 	_SFLoop
.2031					_SFSkipString:
.2031	98		tya				tya
.2032	c8		iny				iny
.2033	18		clc				clc
.2034	71 00		adc ($00),y			adc 	(codePtr),y
.2036	a8		tay				tay
.2037	4c 21 20	jmp $2021			jmp 	_SFLoop
.203a					_SFNextLine:
.203a	20 d2 13	jsr $13d2			jsr 	CommandNextLine
.203d	4c 21 20	jmp $2021			jmp 	_SFLoop
.2040					_SFFoundCommand:
.2040	a5 08		lda $08				lda 	temp2 						; structure level is non-zero then don't check
.2042	d0 0a		bne $204e			bne 	_SFNoCheck
.2044	b1 00		lda ($00),y			lda 	(codePtr),y  				; get the token.
.2046	c5 0a		cmp $0a				cmp 	temp3 						; if it matches either, then we win.
.2048	f0 18		beq $2062			beq 	_SFFoundEnd
.204a	c5 0b		cmp $0b				cmp 	temp3+1
.204c	f0 14		beq $2062			beq 	_SFFoundEnd
.204e					_SFNoCheck:
.204e	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the token
.2050	aa		tax				tax 								; get its type
.2051	bd 0a 1a	lda $1a0a,x			lda 	KeywordTypes-$80,x
.2054	10 d7		bpl $202d			bpl		_SFNextToken 				; not a command
.2056	38		sec				sec
.2057	e9 81		sbc #$81			sbc 	#$81 						; this is now -1 if close, 0 normal, 1 open.
.2059	18		clc				clc
.205a	65 08		adc $08				adc 	temp2 						; add to structure level
.205c	85 08		sta $08				sta 	temp2
.205e	30 04		bmi $2064			bmi		_SFBalance
.2060	10 cb		bpl $202d			bpl 	_SFNextToken
.2062					_SFFoundEnd:
.2062	c8		iny				iny									; skip over the token
.2063	60		rts				rts
.2064					_SFBalance:
.2064	4c 85 19	jmp $1985			jmp 	EHandlerClosure

;******  Return to file: basic.asm


;******  Processing file: common/utility/stack.asm

.2067					StackOpen:
.2067	85 03		sta $03				sta 	tempShort 					; save it
.2069	29 0f		and #$0f			and 	#StackSizeMask 				; bytes to subtract.
.206b	49 ff		eor #$ff			eor 	#$FF 						; add to stack pointer, 2's complement
.206d	38		sec				sec
.206e	65 0e		adc $0e				adc 	StackPtr
.2070	85 0e		sta $0e				sta 	StackPtr
.2072	a5 0f		lda $0f				lda 	StackPtr+1
.2074	69 ff		adc #$ff			adc 	#$FF
.2076	85 0f		sta $0f				sta 	StackPtr+1
.2078	98		tya				tya
.2079	48		pha				pha
.207a	a0 00		ldy #$00			ldy 	#0 							; write marker at offset 0
.207c	a5 03		lda $03				lda 	tempShort
.207e	91 0e		sta ($0e),y			sta 	(StackPtr),y
.2080	68		pla				pla
.2081	a8		tay				tay
.2082	a5 11		lda $11				lda 	LowMemory+1 				; check memory available
.2084	c5 0f		cmp $0f				cmp 	StackPtr+1
.2086	b0 01		bcs $2089			bcs		_SOMemory
.2088	60		rts				rts
.2089					_SOMemory:
.2089	4c ba 19	jmp $19ba			jmp 	EHandlerMemory
.208c					StackCheck:
.208c	84 03		sty $03				sty 	tempShort
.208e	a0 00		ldy #$00			ldy 	#0 							; eor with marker
.2090	51 0e		eor ($0e),y			eor 	(StackPtr),y
.2092	a4 03		ldy $03				ldy 	tempShort
.2094	c9 00		cmp #$00			cmp 	#0 							; set Z flag
.2096	60		rts				rts
.2097					StackClose:
.2097	98		tya				tya
.2098	48		pha				pha
.2099	a0 00		ldy #$00			ldy 	#0
.209b	b1 0e		lda ($0e),y			lda 	(StackPtr),y 				; get type back
.209d	29 0f		and #$0f			and 	#StackSizeMask 				; bytes to add
.209f	18		clc				clc
.20a0	65 0e		adc $0e				adc 	StackPtr
.20a2	85 0e		sta $0e				sta 	StackPtr
.20a4	90 02		bcc $20a8			bcc 	_SCSkip
.20a6	e6 0f		inc $0f				inc 	StackPtr+1
.20a8					_SCSkip:
.20a8	68		pla				pla
.20a9	a8		tay				tay
.20aa	60		rts				rts
.20ab					StackLoadPosition:
.20ab	a0 03		ldy #$03			ldy 	#3 							; read in codePtr from 3,2
.20ad	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20af	85 01		sta $01				sta 	codePtr+1
.20b1	88		dey				dey
.20b2	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20b4	85 00		sta $00				sta 	codePtr
.20b6	88		dey				dey
.20b7	b1 0e		lda ($0e),y			lda 	(stackPtr),y 				; restore offset in line
.20b9	a8		tay				tay
.20ba	60		rts				rts
.20bb					StackSavePosition:
.20bb	98		tya				tya 								; get position in A
.20bc	a0 01		ldy #$01			ldy 	#1
.20be	91 0e		sta ($0e),y			sta 	(stackPtr),y 				; write it out.
.20c0	48		pha				pha 								; save to stack
.20c1	c8		iny				iny 								; write line position
.20c2	a5 00		lda $00				lda 	codePtr
.20c4	91 0e		sta ($0e),y			sta 	(stackPtr),y
.20c6	c8		iny				iny
.20c7	a5 01		lda $01				lda 	codePtr+1
.20c9	91 0e		sta ($0e),y			sta 	(stackPtr),y
.20cb	68		pla				pla
.20cc	a8		tay				tay
.20cd	60		rts				rts
.20ce					StackPopLocals:
.20ce	a0 00		ldy #$00			ldy 	#0 							; check if TOS is a local record
.20d0	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20d2	c9 67		cmp #$67			cmp 	#SMLocal
.20d4	d0 1c		bne $20f2			bne 	_SPLExit
.20d6	a0 05		ldy #$05			ldy 	#5 							; copy local address to temp0
.20d8	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20da	85 04		sta $04				sta 	temp0
.20dc	c8		iny				iny
.20dd	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20df	85 05		sta $05				sta 	temp0+1
.20e1	a0 04		ldy #$04			ldy 	#4 							; start copying back
.20e3					_SPLLoop:
.20e3	b1 0e		lda ($0e),y			lda 	(stackPtr),y
.20e5	88		dey				dey
.20e6	91 04		sta ($04),y			sta 	(temp0),y
.20e8	c0 00		cpy #$00			cpy 	#0
.20ea	d0 f7		bne $20e3			bne 	_SPLLoop
.20ec	20 97 20	jsr $2097			jsr 	StackClose 					; drop frame and try again
.20ef	4c ce 20	jmp $20ce			jmp 	StackPopLocals
.20f2					_SPLExit:
.20f2	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: variables/common/varcreate.asm

.20f3					VariableCreate:
.20f3	a5 10		lda $10				lda 	LowMemory 					; copy LowMemory to temp0 adding 9 as you go
.20f5	85 04		sta $04				sta 	temp0 						; 9 is the size of a variable record.
.20f7	18		clc				clc
.20f8	69 09		adc #$09			adc 	#9
.20fa	85 10		sta $10				sta 	LowMemory
.20fc	a5 11		lda $11				lda 	LowMemory+1
.20fe	85 05		sta $05				sta 	temp0+1
.2100	69 00		adc #$00			adc 	#0
.2102	85 11		sta $11				sta 	LowMemory+1
.2104	c5 0f		cmp $0f				cmp 	StackPtr+1 					; caught up with high memory ?
.2106	b0 30		bcs $2138			bcs 	_CVMemoryError
.2108	a0 00		ldy #$00			ldy 	#0 							; copy the current link from hash table into the 'next' links
.210a	b1 06		lda ($06),y			lda 	(temp1),y 					; from the hash table, inserting it into the front.
.210c	91 04		sta ($04),y			sta 	(temp0),y 					; (offset 0 & 1)
.210e	c8		iny				iny
.210f	b1 06		lda ($06),y			lda 	(temp1),y
.2111	91 04		sta ($04),y			sta 	(temp0),y
.2113	c8		iny				iny
.2114	a5 08		lda $08				lda 	temp2 						; write full 8 bit hash into offset 2
.2116	91 04		sta ($04),y			sta 	(temp0),y
.2118	c8		iny				iny
.2119	18		clc				clc 								; write variable name address into offset 3,4 (codePtr + y)
.211a	a5 0a		lda $0a				lda 	temp3
.211c	91 04		sta ($04),y			sta 	(temp0),y
.211e	c8		iny				iny
.211f	a5 0b		lda $0b				lda 	temp3+1
.2121	91 04		sta ($04),y			sta 	(temp0),y
.2123					_CVClear:
.2123	c8		iny				iny
.2124	a9 00		lda #$00			lda 	#$00
.2126	91 04		sta ($04),y			sta 	(temp0),y
.2128	c0 08		cpy #$08			cpy 	#8
.212a	d0 f7		bne $2123			bne 	_CVClear
.212c	a0 00		ldy #$00			ldy 	#0 							; put the address of the record as the new link head
.212e	a5 04		lda $04				lda 	temp0
.2130	91 06		sta ($06),y			sta 	(temp1),y
.2132	c8		iny				iny
.2133	a5 05		lda $05				lda 	temp0+1
.2135	91 06		sta ($06),y			sta 	(temp1),y
.2137	60		rts				rts
.2138					_CVMemoryError:
.2138	4c ba 19	jmp $19ba			jmp 	EHandlerMemory

;******  Return to file: basic.asm


;******  Processing file: variables/common/variables.asm

.213b					VariableAccess:
.213b	b1 00		lda ($00),y			lda 	(codePtr),y 				; check 20xx where x is 1..1A representing A-Z.
.213d	c9 1a		cmp #$1a			cmp 	#$1A 						; is this A-Z ?
.213f	b0 0b		bcs $214c			bcs 	_VANotBasic
.2141	0a		asl a				asl 	a 							; x 4
.2142	0a		asl a				asl 	a
.2143	95 28		sta $28,x			sta 	esInt0,x 					; set up address
.2145	a9 08		lda #$08			lda 	#RootVariables >> 8
.2147	95 30		sta $30,x			sta 	esInt1,x
.2149	4c 8a 21	jmp $218a			jmp 	VACheckModifier
.214c					_VANotBasic:
.214c	0a		asl a				asl 	a 							; calculate hash as 2 x first byte + second byte
.214d	c8		iny				iny
.214e	18		clc				clc
.214f	71 00		adc ($00),y			adc 	(codePtr),y
.2151	88		dey				dey
.2152	85 08		sta $08				sta 	temp2 						; 8 bit hash in temp2.
.2154	29 0f		and #$0f			and 	#HashTableSize-1 			; force into hash range
.2156	0a		asl a				asl 	a 							; double, word addresses in table and CLC
.2157	69 68		adc #$68			adc 	#HashTable & $FF 			; make temp1 point to the hash table first link.
.2159	85 06		sta $06				sta 	temp1
.215b	a9 08		lda #$08			lda 	#HashTable >> 8
.215d	85 07		sta $07				sta 	temp1+1
.215f	84 09		sty $09				sty 	temp2+1 					; Y is the offset of the first character.
.2161	98		tya				tya
.2162	18		clc				clc
.2163	65 00		adc $00				adc 	codePtr 					; temp3 is the address of that variable name.
.2165	85 0a		sta $0a				sta 	temp3
.2167	a5 01		lda $01				lda		codePtr+1
.2169	69 00		adc #$00			adc 	#0
.216b	85 0b		sta $0b				sta 	temp3+1
.216d	8a		txa				txa
.216e	48		pha				pha
.216f	98		tya				tya
.2170	48		pha				pha
.2171	20 d2 21	jsr $21d2			jsr 	VariableSearch 				; does it exist already ?
.2174	b0 03		bcs $2179			bcs 	_VAExists
.2176	20 f3 20	jsr $20f3			jsr 	VariableCreate 				; no, create it.
.2179					_VAExists:
.2179	68		pla				pla
.217a	a8		tay				tay
.217b	68		pla				pla
.217c	aa		tax				tax
.217d	18		clc				clc
.217e	a5 04		lda $04				lda 	temp0 						; add 5 to temp0, which is the offset in the record
.2180	69 05		adc #$05			adc 	#5 							; of the actual variable data and copy into the stack
.2182	95 28		sta $28,x			sta 	esInt0,x
.2184	a5 05		lda $05				lda 	temp0+1
.2186	69 00		adc #$00			adc 	#0
.2188	95 30		sta $30,x			sta 	esInt1,x
.218a					VACheckModifier:
.218a	b1 00		lda ($00),y			lda 	(codePtr),y
.218c	c8		iny				iny
.218d	c9 30		cmp #$30			cmp 	#$30
.218f	b0 f9		bcs $218a			bcs 	VACheckModifier
.2191	ad a8 08	lda $08a8			lda 	arrayEnabled 				; arrays in operation
.2194	f0 2b		beq $21c1			beq 	_VAExit
.2196	b1 00		lda ($00),y			lda 	(codePtr),y 				; check for (
.2198	c9 95		cmp #$95			cmp 	#KWD_LPAREN
.219a	d0 25		bne $21c1			bne 	_VAExit
.219c	c8		iny				iny
.219d	a9 80		lda #$80			lda 	#$80 						; convert to a reference and derefence it
.219f	95 20		sta $20,x			sta 	esType,x
.21a1	20 05 17	jsr $1705			jsr 	DeRefTop
.21a4	b5 30		lda $30,x			lda 	esInt1,x 					; check address $0000 - uninitialised
.21a6	15 28		ora $28,x			ora 	esInt0,x
.21a8	f0 22		beq $21cc			beq 	_VAUninitialised
.21aa	e8		inx				inx
.21ab	20 3e 16	jsr $163e			jsr 	EvaluateTOSDeRef 			; get the index.
.21ae	20 4a 14	jsr $144a			jsr 	CheckRightParen
.21b1	20 11 1e	jsr $1e11			jsr 	Int32ShiftLeft 				; x 4
.21b4	20 11 1e	jsr $1e11			jsr 	Int32ShiftLeft
.21b7	ca		dex				dex
.21b8	20 ed 1c	jsr $1ced			jsr 	Int32Add 					; add together
.21bb	b5 38		lda $38,x			lda 	esInt2,x 					; check MSBytses result
.21bd	15 40		ora $40,x			ora 	esInt3,x
.21bf	d0 0e		bne $21cf			bne 	_VABadAIndex
.21c1					_VAExit:
.21c1	a9 00		lda #$00			lda 	#0 							; clear the upper two bytes of variable/element address.
.21c3	95 38		sta $38,x			sta 	esInt2,x
.21c5	95 40		sta $40,x			sta 	esInt3,x
.21c7	a9 80		lda #$80			lda 	#$80 						; it's a reference to an integer.
.21c9	95 20		sta $20,x			sta 	esType,x
.21cb	60		rts				rts
.21cc					_VAUninitialised:
.21cc	4c d1 19	jmp $19d1			jmp 	EHandlerNoArray
.21cf					_VABadAIndex:
.21cf	4c 49 19	jmp $1949			jmp 	EHandlerBadAIndex

;******  Return to file: basic.asm


;******  Processing file: variables/common/varsearch.asm

.21d2					VariableSearch:
.21d2	a5 06		lda $06				lda 	temp1 						; put the first hash link address into temp0
.21d4	85 04		sta $04				sta 	temp0
.21d6	a5 07		lda $07				lda 	temp1+1
.21d8	85 05		sta $05				sta 	temp0+1
.21da					_VSLoop:
.21da	a0 01		ldy #$01			ldy 	#1 							; look at MSB of link to follow
.21dc	b1 04		lda ($04),y			lda 	(temp0),y
.21de	f0 29		beq $2209			beq 	_VSFail						; if zero, end of linked list, so exit with CC
.21e0	aa		tax				tax 								; follow the link.
.21e1	88		dey				dey
.21e2	b1 04		lda ($04),y			lda 	(temp0),y
.21e4	85 04		sta $04				sta 	temp0
.21e6	86 05		stx $05				stx 	temp0+1
.21e8	a0 02		ldy #$02			ldy 	#2 							; check the hashes match
.21ea	b1 04		lda ($04),y			lda 	(temp0),y
.21ec	c5 08		cmp $08				cmp 	temp2 						; no, they don't, go around.
.21ee	d0 ea		bne $21da			bne 	_VSLoop
.21f0	c8		iny				iny 								; copy the varname address into temp4
.21f1	b1 04		lda ($04),y			lda 	(temp0),y
.21f3	85 0c		sta $0c				sta 	temp4
.21f5	c8		iny				iny
.21f6	b1 04		lda ($04),y			lda 	(temp0),y
.21f8	85 0d		sta $0d				sta 	temp4+1
.21fa	a0 00		ldy #$00			ldy 	#0 							; now compare them.
.21fc					_VSCompareName:
.21fc	b1 0c		lda ($0c),y			lda 	(temp4),y
.21fe	d1 0a		cmp ($0a),y			cmp 	(temp3),y
.2200	d0 d8		bne $21da			bne 	_VSLoop 					; different, go around
.2202	c8		iny				iny
.2203	c9 30		cmp #$30			cmp 	#$30 						; reached end marker
.2205	b0 f5		bcs $21fc			bcs 	_VSCompareName
.2207	38		sec				sec 								; and we match.
.2208	60		rts				rts
.2209	18		clc		_VSFail:clc
.220a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: system/x16/x16/x16hardware.asm

.220b					XTGetKey:
.220b	8a		txa				txa
.220c	48		pha				pha
.220d	98		tya				tya
.220e	48		pha				pha
.220f	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.2212	85 03		sta $03				sta 	tempShort
.2214	68		pla				pla
.2215	a8		tay				tay
.2216	68		pla				pla
.2217	aa		tax				tax
.2218	a5 03		lda $03				lda 	tempShort
.221a	60		rts				rts
.221b					XTUpdateClock:
.221b	48		pha				pha
.221c	8a		txa				txa
.221d	48		pha				pha
.221e	98		tya				tya
.221f	48		pha				pha
.2220	20 de ff	jsr $ffde			jsr 	$FFDE
.2223	8c a2 08	sty $08a2			sty 	ClockTicks+2
.2226	8e a1 08	stx $08a1			stx 	ClockTicks+1
.2229	8d a0 08	sta $08a0			sta 	ClockTicks
.222c	a9 00		lda #$00			lda 	#0
.222e	8d a3 08	sta $08a3			sta 	ClockTicks+3
.2231	68		pla				pla
.2232	a8		tay				tay
.2233	68		pla				pla
.2234	aa		tax				tax
.2235	68		pla				pla
.2236	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: system/x16/x16/x16print.asm

.2237					XTPrintAC:
.2237	c9 61		cmp #$61			cmp 	#"a"
.2239	90 1c		bcc $2257			bcc 	XTPrintA
.223b	c9 7b		cmp #$7b			cmp 	#"z"+1
.223d	b0 18		bcs $2257			bcs 	XTPrintA
.223f	48		pha				pha
.2240	49 20		eor #$20			eor 	#$20
.2242	20 57 22	jsr $2257			jsr 	XTPrintA
.2245	68		pla				pla
.2246	60		rts				rts
.2247					XTPrintCR:
.2247	48		pha				pha
.2248	a9 0d		lda #$0d			lda 	#13
.224a	20 57 22	jsr $2257			jsr 	XTPrintA
.224d	68		pla				pla
.224e	60		rts				rts
.224f					XTPrintTab:
.224f	48		pha				pha
.2250	a9 20		lda #$20			lda 	#32
.2252	20 57 22	jsr $2257			jsr 	XTPrintA
.2255	68		pla				pla
.2256	60		rts				rts
.2257					XTPrintA:
.2257	85 03		sta $03				sta 	tempShort
.2259	48		pha				pha
.225a	8a		txa				txa
.225b	48		pha				pha
.225c	98		tya				tya
.225d	48		pha				pha
.225e	a5 03		lda $03				lda 	tempShort
.2260	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2263	68		pla				pla
.2264	a8		tay				tay
.2265	68		pla				pla
.2266	aa		tax				tax
.2267	68		pla				pla
.2268	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: testing/code/99program.asm

>2269						.align 256
.2300					BasicProgram:
>2300	0d					.byte $0d
>2301	e8					.byte $e8
>2302	03					.byte $03
>2303	3c					.byte $3c
>2304	34					.byte $34
>2305	0c					.byte $0c
>2306	89					.byte $89
>2307	aa					.byte $aa
>2308	95					.byte $95
>2309	79					.byte $79
>230a	71					.byte $71
>230b	ae					.byte $ae
>230c	80					.byte $80
>230d	0d					.byte $0d
>230e	f2					.byte $f2
>230f	03					.byte $03
>2310	c6					.byte $c6
>2311	96					.byte $96
>2312	3c					.byte $3c
>2313	34					.byte $34
>2314	0c					.byte $0c
>2315	ac					.byte $ac
>2316	3c					.byte $3c
>2317	34					.byte $34
>2318	0c					.byte $0c
>2319	80					.byte $80
>231a	0c					.byte $0c
>231b	fc					.byte $fc
>231c	03					.byte $03
>231d	3c					.byte $3c
>231e	34					.byte $34
>231f	0c					.byte $0c
>2320	91					.byte $91
>2321	70					.byte $70
>2322	89					.byte $89
>2323	7a					.byte $7a
>2324	72					.byte $72
>2325	80					.byte $80
>2326	0c					.byte $0c
>2327	06					.byte $06
>2328	04					.byte $04
>2329	3c					.byte $3c
>232a	34					.byte $34
>232b	0c					.byte $0c
>232c	91					.byte $91
>232d	74					.byte $74
>232e	89					.byte $89
>232f	8b					.byte $8b
>2330	72					.byte $72
>2331	80					.byte $80
>2332	13					.byte $13
>2333	10					.byte $10
>2334	04					.byte $04
>2335	3c					.byte $3c
>2336	34					.byte $34
>2337	0c					.byte $0c
>2338	91					.byte $91
>2339	78					.byte $78
>233a	89					.byte $89
>233b	96					.byte $96
>233c	78					.byte $78
>233d	77					.byte $77
>233e	76					.byte $76
>233f	75					.byte $75
>2340	74					.byte $74
>2341	73					.byte $73
>2342	72					.byte $72
>2343	71					.byte $71
>2344	80					.byte $80
>2345	17					.byte $17
>2346	1a					.byte $1a
>2347	04					.byte $04
>2348	c6					.byte $c6
>2349	96					.byte $96
>234a	3c					.byte $3c
>234b	34					.byte $34
>234c	0c					.byte $0c
>234d	91					.byte $91
>234e	78					.byte $78
>234f	ac					.byte $ac
>2350	3c					.byte $3c
>2351	34					.byte $34
>2352	0c					.byte $0c
>2353	91					.byte $91
>2354	74					.byte $74
>2355	ac					.byte $ac
>2356	3c					.byte $3c
>2357	34					.byte $34
>2358	0c					.byte $0c
>2359	91					.byte $91
>235a	70					.byte $70
>235b	80					.byte $80
>235c	1a					.byte $1a
>235d	24					.byte $24
>235e	04					.byte $04
>235f	c6					.byte $c6
>2360	96					.byte $96
>2361	3c					.byte $3c
>2362	34					.byte $34
>2363	0c					.byte $0c
>2364	95					.byte $95
>2365	72					.byte $72
>2366	ae					.byte $ae
>2367	ac					.byte $ac
>2368	3c					.byte $3c
>2369	34					.byte $34
>236a	0c					.byte $0c
>236b	95					.byte $95
>236c	71					.byte $71
>236d	ae					.byte $ae
>236e	ac					.byte $ac
>236f	3c					.byte $3c
>2370	34					.byte $34
>2371	0c					.byte $0c
>2372	95					.byte $95
>2373	70					.byte $70
>2374	ae					.byte $ae
>2375	80					.byte $80
>2376	14					.byte $14
>2377	2e					.byte $2e
>2378	04					.byte $04
>2379	3c					.byte $3c
>237a	34					.byte $34
>237b	0c					.byte $0c
>237c	95					.byte $95
>237d	72					.byte $72
>237e	ae					.byte $ae
>237f	89					.byte $89
>2380	96					.byte $96
>2381	75					.byte $75
>2382	75					.byte $75
>2383	7a					.byte $7a
>2384	7a					.byte $7a
>2385	75					.byte $75
>2386	75					.byte $75
>2387	7a					.byte $7a
>2388	7a					.byte $7a
>2389	80					.byte $80
>238a	17					.byte $17
>238b	38					.byte $38
>238c	04					.byte $04
>238d	c6					.byte $c6
>238e	96					.byte $96
>238f	3c					.byte $3c
>2390	34					.byte $34
>2391	0c					.byte $0c
>2392	91					.byte $91
>2393	78					.byte $78
>2394	ac					.byte $ac
>2395	3c					.byte $3c
>2396	34					.byte $34
>2397	0c					.byte $0c
>2398	91					.byte $91
>2399	74					.byte $74
>239a	ac					.byte $ac
>239b	3c					.byte $3c
>239c	34					.byte $34
>239d	0c					.byte $0c
>239e	91					.byte $91
>239f	70					.byte $70
>23a0	80					.byte $80
>23a1	1a					.byte $1a
>23a2	42					.byte $42
>23a3	04					.byte $04
>23a4	c6					.byte $c6
>23a5	96					.byte $96
>23a6	3c					.byte $3c
>23a7	34					.byte $34
>23a8	0c					.byte $0c
>23a9	95					.byte $95
>23aa	72					.byte $72
>23ab	ae					.byte $ae
>23ac	ac					.byte $ac
>23ad	3c					.byte $3c
>23ae	34					.byte $34
>23af	0c					.byte $0c
>23b0	95					.byte $95
>23b1	71					.byte $71
>23b2	ae					.byte $ae
>23b3	ac					.byte $ac
>23b4	3c					.byte $3c
>23b5	34					.byte $34
>23b6	0c					.byte $0c
>23b7	95					.byte $95
>23b8	70					.byte $70
>23b9	ae					.byte $ae
>23ba	80					.byte $80
>23bb	04					.byte $04
>23bc	4c					.byte $4c
>23bd	04					.byte $04
>23be	80					.byte $80
>23bf	00					.byte $00

;******  Return to file: basic.asm


;******  End of listing
