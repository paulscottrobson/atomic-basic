
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -q --m65xx -L asm.out/basic.lst -l asm.out/basic.lbl -o asm.out/basic.prg basic.asm
; Thu Dec 10 09:10:44 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: boot/x16/01constants.inc

=8							DataStackSize = 8
=16							HashTableSize = 16
=$00							ZeroPageStart = $00
=$20							DataStackStart = $20
=$800							DataStart = $800					; must be on a page boundary.
=$1000							CodeBase = $1000
=$9e00							EndMemory = $9E00

;******  Return to file: basic.asm


;******  Processing file: boot/common/02data.inc

>0000					codePtr:.fill 		3 						; code ptr - extra byte for paging.
>0003					tempShort:.fill 	1 						; used for v.short term saving.
>0004					temp0:	.fill 		2
>0006					temp1:	.fill 		2
>0008					temp2:	.fill 		2
>000a					temp3:	.fill 		2
>000c					temp4:	.fill 		2
>000e					StackPtr:.fill 		2						; highest byte allocated, stack works down.
>0010					LowMemory:.fill 	2 						; next byte available working up
>0020					esType:	.fill 		DataStackSize 			; bit 7 any reference, bit 6 byte reference, bit 0 string.
>0028					esInt0:	.fill 		DataStackSize		 	; 32 bit integer, also used for string address
>0030					esInt1:	.fill 		DataStackSize			; (16 bit only)
>0038					esInt2:	.fill 		DataStackSize
>0040					esInt3:	.fill 		DataStackSize
=$28					esStrLow = esInt0 							; String address synonym
=$30					esStrHigh = esInt1
>0800							.align 	256  						; these two must be on one page.
.0800					RootVariables:
>0800							.fill 	26*4 						; variables A-Z which are fixed.
.0868					HashTable:
>0868							.fill 	HashTableSize*2 			; variable hash table.
.0888					Seed32:
>0888							.fill 	4 							; random number
.088c					Buffer:
>088c							.fill 	20
.08a0					ClockTicks:
>08a0							.fill 	4
.08a4					IToSCount:
>08a4							.fill 	1
.08a5					ChrBuffer:
>08a5							.fill 	2

;******  Return to file: basic.asm


;******  Processing file: boot/common/03stdmac.inc


;******  Return to file: basic.asm


;******  Processing file: boot/common/boot.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; initialise 6502 stac
.1002	9a		txs				txs
.1003	4c 64 10	jmp $1064			jmp 	ColdStart

;******  Return to file: basic.asm


;******  Processing file: extern/x16/x16hardware.asm

.1006					XTGetKey:
.1006	8a		txa				txa
.1007	48		pha				pha
.1008	98		tya				tya
.1009	48		pha				pha
.100a	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.100d	85 03		sta $03				sta 	tempShort
.100f	68		pla				pla
.1010	a8		tay				tay
.1011	68		pla				pla
.1012	aa		tax				tax
.1013	a5 03		lda $03				lda 	tempShort
.1015	60		rts				rts
.1016					XTUpdateClock:
.1016	48		pha				pha
.1017	8a		txa				txa
.1018	48		pha				pha
.1019	98		tya				tya
.101a	48		pha				pha
.101b	20 de ff	jsr $ffde			jsr 	$FFDE
.101e	8c a2 08	sty $08a2			sty 	ClockTicks+2
.1021	8e a1 08	stx $08a1			stx 	ClockTicks+1
.1024	8d a0 08	sta $08a0			sta 	ClockTicks
.1027	a9 00		lda #$00			lda 	#0
.1029	8d a3 08	sta $08a3			sta 	ClockTicks+3
.102c	68		pla				pla
.102d	a8		tay				tay
.102e	68		pla				pla
.102f	aa		tax				tax
.1030	68		pla				pla
.1031	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: extern/x16/x16print.asm

.1032					XTPrintAC:
.1032	c9 61		cmp #$61			cmp 	#"a"
.1034	90 1c		bcc $1052			bcc 	XTPrintA
.1036	c9 7b		cmp #$7b			cmp 	#"z"+1
.1038	b0 18		bcs $1052			bcs 	XTPrintA
.103a	48		pha				pha
.103b	49 20		eor #$20			eor 	#$20
.103d	20 52 10	jsr $1052			jsr 	XTPrintA
.1040	68		pla				pla
.1041	60		rts				rts
.1042					XTPrintCR:
.1042	48		pha				pha
.1043	a9 0d		lda #$0d			lda 	#13
.1045	20 52 10	jsr $1052			jsr 	XTPrintA
.1048	68		pla				pla
.1049	60		rts				rts
.104a					XTPrintTab:
.104a	48		pha				pha
.104b	a9 20		lda #$20			lda 	#32
.104d	20 52 10	jsr $1052			jsr 	XTPrintA
.1050	68		pla				pla
.1051	60		rts				rts
.1052					XTPrintA:
.1052	85 03		sta $03				sta 	tempShort
.1054	48		pha				pha
.1055	8a		txa				txa
.1056	48		pha				pha
.1057	98		tya				tya
.1058	48		pha				pha
.1059	a5 03		lda $03				lda 	tempShort
.105b	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.105e	68		pla				pla
.105f	a8		tay				tay
.1060	68		pla				pla
.1061	aa		tax				tax
.1062	68		pla				pla
.1063	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: interface/test/iftdummy.asm

.1064					ColdStart:
.1064	4c d0 19	jmp $19d0			jmp 	TestProgram
.1067					WarmStart:
.1067	4c 67 10	jmp $1067			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: common/generated/keywords.inc

=$80					KWD_LESSLESSENDGREATERGREATER        = $80 ; 128
=$81					KWD_AND                              = $81 ; 129
=$82					KWD_OR                               = $82 ; 130
=$83					KWD_XOR                              = $83 ; 131
=$84					KWD_GREATER                          = $84 ; 132
=$85					KWD_LESS                             = $85 ; 133
=$86					KWD_GREATEREQUAL                     = $86 ; 134
=$87					KWD_LESSEQUAL                        = $87 ; 135
=$88					KWD_LESSGREATER                      = $88 ; 136
=$89					KWD_EQUAL                            = $89 ; 137
=$8a					KWD_PLUS                             = $8a ; 138
=$8b					KWD_MINUS                            = $8b ; 139
=$8c					KWD_ASTERISK                         = $8c ; 140
=$8d					KWD_SLASH                            = $8d ; 141
=$8e					KWD_PERCENT                          = $8e ; 142
=$8f					KWD_GREATERGREATER                   = $8f ; 143
=$90					KWD_LESSLESS                         = $90 ; 144
=$91					KWD_PLING                            = $91 ; 145
=$92					KWD_QUESTION                         = $92 ; 146
=$93					KWD_DOLLAR                           = $93 ; 147
=$94					KWD_TILDE                            = $94 ; 148
=$95					KWD_LPAREN                           = $95 ; 149
=$96					KWD_AMPERSAND                        = $96 ; 150
=$97					KWD_AT                               = $97 ; 151
=$98					KWD_LEN                              = $98 ; 152
=$99					KWD_SGN                              = $99 ; 153
=$9a					KWD_ABS                              = $9a ; 154
=$9b					KWD_RANDOM                           = $9b ; 155
=$9c					KWD_PAGE                             = $9c ; 156
=$9d					KWD_TRUE                             = $9d ; 157
=$9e					KWD_FALSE                            = $9e ; 158
=$9f					KWD_MIN                              = $9f ; 159
=$a0					KWD_MAX                              = $a0 ; 160
=$a1					KWD_SYS                              = $a1 ; 161
=$a2					KWD_CODE                             = $a2 ; 162
=$a3					KWD_TIMER                            = $a3 ; 163
=$a4					KWD_EVENT                            = $a4 ; 164
=$a5					KWD_GET                              = $a5 ; 165
=$a6					KWD_JOYPERIODX                       = $a6 ; 166
=$a7					KWD_JOYPERIODY                       = $a7 ; 167
=$a8					KWD_JOYPERIODBTN                     = $a8 ; 168
=$a9					KWD_INKEY                            = $a9 ; 169
=$aa					KWD_ALLOC                            = $aa ; 170
=$ab					KWD_CHR                              = $ab ; 171
=$ac					KWD_COMMA                            = $ac ; 172
=$ad					KWD_SEMICOLON                        = $ad ; 173
=$ae					KWD_RPAREN                           = $ae ; 174
=$af					KWD_PLUSPLUS                         = $af ; 175
=$b0					KWD_MINUSMINUS                       = $b0 ; 176
=$b1					KWD_LSQPAREN                         = $b1 ; 177
=$b2					KWD_RSQPAREN                         = $b2 ; 178
=$b3					KWD_IF                               = $b3 ; 179
=$b4					KWD_FOR                              = $b4 ; 180
=$b5					KWD_REPEAT                           = $b5 ; 181
=$b6					KWD_PROC                             = $b6 ; 182
=$b7					KWD_WHILE                            = $b7 ; 183
=$b8					KWD_ENDIF                            = $b8 ; 184
=$b9					KWD_NEXT                             = $b9 ; 185
=$ba					KWD_UNTIL                            = $ba ; 186
=$bb					KWD_ENDPROC                          = $bb ; 187
=$bc					KWD_WEND                             = $bc ; 188
=$bd					KWD_REM                              = $bd ; 189
=$be					KWD_LET                              = $be ; 190
=$bf					KWD_SQUOTE                           = $bf ; 191
=$c0					KWD_COLON                            = $c0 ; 192
=$c1					KWD_THEN                             = $c1 ; 193
=$c2					KWD_ELSE                             = $c2 ; 194
=$c3					KWD_TO                               = $c3 ; 195
=$c4					KWD_STEP                             = $c4 ; 196
=$c5					KWD_VDU                              = $c5 ; 197
=$c6					KWD_PRINT                            = $c6 ; 198
=$c7					KWD_CALL                             = $c7 ; 199
=$c8					KWD_LOCAL                            = $c8 ; 200
=$c9					KWD_GOTO                             = $c9 ; 201
=$ca					KWD_GOSUB                            = $ca ; 202
=$cb					KWD_RETURN                           = $cb ; 203
=$cc					KWD_ASSERT                           = $cc ; 204
=$cd					KWD_STOP                             = $cd ; 205
=$ce					KWD_END                              = $ce ; 206
=$cf					KWD_DIM                              = $cf ; 207
=$d0					KWD_CLEAR                            = $d0 ; 208
=$d1					KWD_LOAD                             = $d1 ; 209
=$d2					KWD_SAVE                             = $d2 ; 210
=$d3					KWD_LIST                             = $d3 ; 211
=$d4					KWD_NEW                              = $d4 ; 212
=$d5					KWD_RUN                              = $d5 ; 213

;******  Return to file: basic.asm


;******  Processing file: common/math/intmacros.inc


;******  Return to file: basic.asm


;******  Processing file: common/errors/checksyntax.asm

.106a					CheckComma:
.106a	48		pha				pha
.106b	a9 ac		lda #$ac			lda 	#KWD_COMMA
.106d	4c 88 10	jmp $1088			jmp 	CheckSyntax
.1070					CheckLeftParen:
.1070	48		pha				pha
.1071	a9 95		lda #$95			lda 	#KWD_LPAREN
.1073	4c 88 10	jmp $1088			jmp 	CheckSyntax
.1076					CheckEquals:
.1076	48		pha				pha
.1077	a9 89		lda #$89			lda 	#KWD_EQUAL
.1079	4c 88 10	jmp $1088			jmp 	CheckSyntax
.107c					CheckTO:
.107c	48		pha				pha
.107d	a9 c3		lda #$c3			lda 	#KWD_TO
.107f	4c 88 10	jmp $1088			jmp 	CheckSyntax
.1082					CheckRightParen:
.1082	48		pha				pha
.1083	a9 ae		lda #$ae			lda 	#KWD_RPAREN
.1085	4c 88 10	jmp $1088			jmp 	CheckSyntax
.1088					CheckSyntax:
.1088	d1 00		cmp ($00),y			cmp 	(codePtr),y
.108a	d0 03		bne $108f			bne 	_CSFail
.108c	c8		iny				iny
.108d	68		pla				pla
.108e	60		rts				rts
.108f					_CSFail:
.108f	4c d9 15	jmp $15d9			jmp 	EHandlerSyntax
.1092					NoOp1:
.1092					NoOp2:
.1092					NoOp3:
.1092					NoOp6:
.1092					NoOp7:
.1092					NoOp8:
.1092					NoOp9:
.1092	4c d9 15	jmp $15d9			jmp 	EHandlerSyntax

;******  Return to file: basic.asm


;******  Processing file: common/errors/errorhandler.asm

.1095					ErrorHandler:
.1095	84 0a		sty $0a				sty 	temp3
.1097	68		pla				pla 								; line addr into XY.
.1098	a8		tay				tay
.1099	68		pla				pla
.109a	aa		tax				tax
.109b	c8		iny				iny
.109c	d0 01		bne $109f			bne 	_EHNoBump
.109e	e8		inx				inx
.109f					_EHNoBump:
.109f	20 e5 10	jsr $10e5			jsr 	PrintXYString 				; print it
.10a2	a0 00		ldy #$00			ldy 	#0 							; if offset = 0 (e.g. not in program)
.10a4	b1 00		lda ($00),y			lda 	(codePtr),y
.10a6	f0 30		beq $10d8			beq 	_GoWarm 					; no line #
.10a8	20 e0 10	jsr $10e0			jsr 	PrintSpace
.10ab	a9 40		lda #$40			lda 	#'@'
.10ad	20 32 10	jsr $1032			jsr 	XTPrintAC
.10b0	20 e0 10	jsr $10e0			jsr 	PrintSpace
.10b3	a2 00		ldx #$00			ldx 	#0 							; set up for ITOA conversion
.10b5	c8		iny				iny
.10b6	b1 00		lda ($00),y			lda 	(codePtr),y
.10b8	95 28		sta $28,x			sta 	esInt0,x
.10ba	c8		iny				iny
.10bb	b1 00		lda ($00),y			lda 	(codePtr),y
.10bd	95 30		sta $30,x			sta 	esInt1,x
.10bf	8a		txa				txa
.10c0	95 38		sta $38,x			sta 	esInt2,x
.10c2	95 40		sta $40,x			sta 	esInt3,x
.10c4	a9 8c		lda #$8c			lda 	#(buffer) & $FF
.10c6	85 04		sta $04				sta 	temp0
.10c8	a9 08		lda #$08			lda 	#(buffer) >> 8
.10ca	85 05		sta $05				sta 	1+(temp0)
.10cc	a9 0a		lda #$0a			lda 	#10 						; convert base 10.
.10ce	20 c8 18	jsr $18c8			jsr 	Int32ToString
.10d1	a2 08		ldx #$08			ldx 	#buffer >> 8
.10d3	a0 8c		ldy #$8c			ldy 	#buffer & $FF
.10d5	20 e5 10	jsr $10e5			jsr 	PrintXYString
.10d8					_GoWarm:
.10d8	a5 0a		lda $0a				lda 	temp3
.10da	4c 67 10	jmp $1067			jmp 	WarmStart
.10dd					InstructionUndefined:
.10dd	4c ac 15	jmp $15ac			jmp 	EHandlerNotImplemented
.10e0					PrintSpace:
.10e0	a9 20		lda #$20			lda 	#32
.10e2	4c 32 10	jmp $1032			jmp 	XTPrintAC
.10e5					PrintXYString:
.10e5	48		pha				pha
.10e6	84 04		sty $04				sty 	temp0
.10e8	86 05		stx $05				stx 	temp0+1
.10ea	a0 00		ldy #$00			ldy 	#0
.10ec					_PXYSLoop:
.10ec	b1 04		lda ($04),y			lda 	(temp0),y
.10ee	20 32 10	jsr $1032			jsr 	XTPrintAC
.10f1	c8		iny				iny
.10f2	b1 04		lda ($04),y			lda 	(temp0),y
.10f4	d0 f6		bne $10ec			bne 	_PXYSLoop
.10f6	a4 04		ldy $04				ldy 	temp0
.10f8	a6 05		ldx $05				ldx 	temp0+1
.10fa	68		pla				pla
.10fb	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary1.asm

.10fc					BinaryAdd:
.10fc	20 38 13	jsr $1338			jsr		DeRefBoth
.10ff	20 5d 18	jsr $185d			jsr 	Int32Add
.1102	a9 00		lda #$00			lda 	#0
.1104	95 20		sta $20,x			sta 	esType,x
.1106	60		rts				rts
.1107					BinarySub:
.1107	20 38 13	jsr $1338			jsr		DeRefBoth
.110a	20 77 18	jsr $1877			jsr 	Int32Sub
.110d	a9 00		lda #$00			lda 	#0
.110f	95 20		sta $20,x			sta 	esType,x
.1111	60		rts				rts
.1112					BinaryMult:
.1112	20 38 13	jsr $1338			jsr		DeRefBoth
.1115	20 91 18	jsr $1891			jsr 	Int32Multiply
.1118	a9 00		lda #$00			lda 	#0
.111a	95 20		sta $20,x			sta 	esType,x
.111c	60		rts				rts
.111d					BinaryDivide:
.111d	20 38 13	jsr $1338			jsr		DeRefBoth
.1120	20 39 11	jsr $1139			jsr		CheckDivisorNonZero
.1123	20 7a 17	jsr $177a			jsr 	Int32SDivide
.1126	a9 00		lda #$00			lda 	#0
.1128	95 20		sta $20,x			sta 	esType,x
.112a	60		rts				rts
.112b					BinaryModulus:
.112b	20 38 13	jsr $1338			jsr		DeRefBoth
.112e	20 39 11	jsr $1139			jsr 	CheckDivisorNonZero
.1131	20 e9 17	jsr $17e9			jsr		Int32Modulus
.1134	a9 00		lda #$00			lda 	#0
.1136	95 20		sta $20,x			sta 	esType,x
.1138	60		rts				rts
.1139					CheckDivisorNonZero:
.1139	e8		inx				inx
.113a	20 93 19	jsr $1993			jsr 	Int32Zero
.113d	f0 02		beq $1141			beq 	_BDivZero
.113f	ca		dex				dex
.1140	60		rts				rts
.1141					_BDivZero:
.1141	4c 15 15	jmp $1515			jmp 	EHandlerDivideZero
.1144					BinaryXor:
.1144	20 38 13	jsr $1338			jsr		DeRefBoth
.1147	20 2e 17	jsr $172e			jsr 	Int32Xor
.114a	a9 00		lda #$00			lda 	#0
.114c	95 20		sta $20,x			sta 	esType,x
.114e	60		rts				rts
.114f					BinaryOr:
.114f	20 38 13	jsr $1338			jsr		DeRefBoth
.1152	20 15 17	jsr $1715			jsr 	Int32Or
.1155	a9 00		lda #$00			lda 	#0
.1157	95 20		sta $20,x			sta 	esType,x
.1159	60		rts				rts
.115a					BinaryAnd:
.115a	20 38 13	jsr $1338			jsr		DeRefBoth
.115d	20 fc 16	jsr $16fc			jsr 	Int32And
.1160	a9 00		lda #$00			lda 	#0
.1162	95 20		sta $20,x			sta 	esType,x
.1164	60		rts				rts
.1165					BinaryShiftLeft:
.1165	20 38 13	jsr $1338			jsr		DeRefBoth
.1168	20 92 11	jsr $1192			jsr 	CheckShiftParam2
.116b	d0 21		bne $118e			bne 	BinaryShiftZero
.116d					BSLLoop:
.116d	d6 29		dec $29,x			dec 	esInt0+1,x
.116f	30 18		bmi $1189			bmi 	BinaryShiftExit
.1171	20 81 19	jsr $1981			jsr 	Int32ShiftLeft
.1174	4c 6d 11	jmp $116d			jmp 	BSLLoop
.1177					BinaryShiftRight:
.1177	20 38 13	jsr $1338			jsr		DeRefBoth
.117a	20 92 11	jsr $1192			jsr 	CheckShiftParam2
.117d	d0 0f		bne $118e			bne 	BinaryShiftZero
.117f					BSRLoop:
.117f	d6 29		dec $29,x			dec 	esInt0+1,x
.1181	30 06		bmi $1189			bmi 	BinaryShiftExit
.1183	20 8a 19	jsr $198a			jsr 	Int32ShiftRight
.1186	4c 7f 11	jmp $117f			jmp 	BSRLoop
.1189					BinaryShiftExit:
.1189	a9 00		lda #$00			lda 	#0
.118b	95 20		sta $20,x			sta 	esType,x
.118d	60		rts				rts
.118e					BinaryShiftZero:
.118e	20 6c 19	jsr $196c			jsr 	Int32False
.1191	60		rts				rts
.1192					CheckShiftParam2:
.1192	b5 29		lda $29,x			lda 	esInt0+1,x 					; if value >= 32 then result is zero
.1194	29 e0		and #$e0			and 	#$E0
.1196	15 31		ora $31,x			ora 	esInt1+1,x
.1198	15 39		ora $39,x			ora 	esInt2+1,x
.119a	15 41		ora $41,x			ora 	esInt3+1,x
.119c	60		rts				rts
.119d					IndirectWord:
.119d	20 38 13	jsr $1338			jsr		DeRefBoth
.11a0	20 5d 18	jsr $185d			jsr 	Int32Add
.11a3	a9 80		lda #$80			lda 	#$80 						; make it a reference
.11a5	95 20		sta $20,x			sta 	esType,x
.11a7	60		rts				rts
.11a8					IndirectByte:
.11a8	20 38 13	jsr $1338			jsr		DeRefBoth
.11ab	20 5d 18	jsr $185d			jsr 	Int32Add
.11ae	a9 c0		lda #$c0			lda 	#$C0 						; type is set to byte reference.
.11b0	95 20		sta $20,x			sta 	esType,x
.11b2	60		rts				rts
.11b3					IndirectString:
.11b3	20 38 13	jsr $1338			jsr		DeRefBoth
.11b6	20 5d 18	jsr $185d			jsr 	Int32Add
.11b9	a9 81		lda #$81			lda 	#$81 						; type is set to string reference.
.11bb	95 20		sta $20,x			sta 	esType,x
.11bd	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/binary2.asm

.11be					Binary_Equal:
.11be	20 ee 11	jsr $11ee			jsr 	TestEqual
.11c1	b0 04		bcs $11c7			bcs 	CompTrue
.11c3					CompFalse:
.11c3	20 6c 19	jsr $196c			jsr 	Int32False
.11c6	60		rts				rts
.11c7					CompTrue
.11c7	20 68 19	jsr $1968			jsr 	Int32True
.11ca	60		rts				rts
.11cb					Binary_NotEqual:
.11cb	20 ee 11	jsr $11ee			jsr 	TestEqual
.11ce	90 f7		bcc $11c7			bcc 	CompTrue
.11d0	b0 f1		bcs $11c3			bcs 	CompFalse
.11d2					Binary_Less:
.11d2	20 05 12	jsr $1205			jsr 	TestLess
.11d5	b0 f0		bcs $11c7			bcs 	CompTrue
.11d7	90 ea		bcc $11c3			bcc 	CompFalse
.11d9					Binary_GreaterEqual:
.11d9	20 05 12	jsr $1205			jsr 	TestLess
.11dc	90 e9		bcc $11c7			bcc 	CompTrue
.11de	b0 e3		bcs $11c3			bcs 	CompFalse
.11e0					Binary_LessEqual:
.11e0	20 02 12	jsr $1202			jsr 	TestLessSwap
.11e3	90 e2		bcc $11c7			bcc 	CompTrue
.11e5	b0 dc		bcs $11c3			bcs 	CompFalse
.11e7					Binary_Greater:
.11e7	20 02 12	jsr $1202			jsr 	TestLessSwap
.11ea	b0 db		bcs $11c7			bcs 	CompTrue
.11ec	90 d5		bcc $11c3			bcc 	CompFalse
.11ee					TestEqual:
.11ee	20 1c 12	jsr $121c			jsr 	TypeCheck
.11f1	c9 00		cmp #$00			cmp 	#0
.11f3	f0 0a		beq $11ff			beq 	_TEInteger
.11f5	20 45 12	jsr $1245			jsr 	StringCompare
.11f8	c9 00		cmp #$00			cmp 	#0
.11fa	38		sec				sec
.11fb	f0 01		beq $11fe			beq 	_TEZero
.11fd	18		clc				clc
.11fe					_TEZero
.11fe	60		rts				rts
.11ff					_TEInteger:
.11ff	4c 47 17	jmp $1747			jmp 	Int32Equal
.1202					TestLessSwap:
.1202	20 29 12	jsr $1229			jsr 	SwapTopStack
.1205					TestLess:
.1205	20 1c 12	jsr $121c			jsr 	TypeCheck
.1208	c9 00		cmp #$00			cmp 	#0
.120a	f0 0d		beq $1219			beq 	_TLInteger
.120c	20 45 12	jsr $1245			jsr 	StringCompare
.120f	c9 00		cmp #$00			cmp 	#0
.1211	38		sec				sec
.1212	30 01		bmi $1215			bmi 	_TELess
.1214	18		clc				clc
.1215					_TELess:
.1215	60		rts				rts
.1216	4c ac 15	jmp $15ac			jmp 	EHandlerNotImplemented
.1219					_TLInteger:
.1219	4c 61 17	jmp $1761			jmp 	Int32Less
.121c					TypeCheck:
.121c	20 38 13	jsr $1338			jsr 	DerefBoth
.121f	b5 20		lda $20,x			lda 	esType,x
.1221	d5 21		cmp $21,x			cmp 	esType+1,x
.1223	d0 01		bne $1226			bne 	_TCMismatch
.1225	60		rts				rts
.1226					_TCMismatch:
.1226	4c e9 15	jmp $15e9			jmp 	EHandlerTypeMismatch
.1229					SwapTopStack:
.1229	a9 06		lda #$06			lda 	#6
.122b	85 03		sta $03				sta 	tempShort
.122d	8a		txa				txa
.122e	48		pha				pha
.122f					_TLSLoop:
.122f	b5 20		lda $20,x			lda 	esType,x
.1231	48		pha				pha
.1232	b5 21		lda $21,x			lda 	esType+1,x
.1234	95 20		sta $20,x			sta 	esType,x
.1236	68		pla				pla
.1237	95 21		sta $21,x			sta 	esType+1,x
.1239	8a		txa				txa
.123a	18		clc				clc
.123b	69 08		adc #$08			adc 	#DataStackSize
.123d	aa		tax				tax
.123e	c6 03		dec $03				dec 	tempShort
.1240	d0 ed		bne $122f			bne 	_TLSLoop
.1242	68		pla				pla
.1243	aa		tax				tax
.1244	60		rts				rts
.1245					StringCompare:
.1245	b5 28		lda $28,x			lda 	esInt0,x 					; copy addresses.
.1247	85 04		sta $04				sta 	temp0
.1249	b5 30		lda $30,x			lda 	esInt1,x
.124b	85 05		sta $05				sta 	temp0+1
.124d	b5 29		lda $29,x			lda 	esInt0+1,x
.124f	85 06		sta $06				sta 	temp1
.1251	b5 31		lda $31,x			lda 	esInt1+1,x
.1253	85 07		sta $07				sta 	temp1+1
.1255	84 03		sty $03				sty 	tempShort
.1257	a0 ff		ldy #$ff			ldy 	#255
.1259	c8		iny		_SCLoop:iny
.125a	b1 04		lda ($04),y			lda 	(temp0),y 					; check match return +ve/-ve if fail.
.125c	38		sec				sec
.125d	f1 06		sbc ($06),y			sbc 	(temp1),y
.125f	d0 04		bne $1265			bne 	_SCExit
.1261	b1 04		lda ($04),y			lda 	(temp0),y 					; matched zero, then exit with zero
.1263	d0 f4		bne $1259			bne 	_SCLoop
.1265					_SCExit:
.1265	a4 03		ldy $03				ldy 	tempShort
.1267	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/evaluate.asm

.1268					EvaluateTerm:
.1268	a9 0f		lda #$0f			lda 	#15
.126a	20 80 12	jsr $1280			jsr 	EvaluateLevelAX
.126d	4c 3d 13	jmp $133d			jmp 	DeRefTop
.1270					EvaluateBaseDeRef:
.1270	20 7c 12	jsr $127c			jsr 	EvaluateBase
.1273	4c 3d 13	jmp $133d			jmp 	DeRefTop
.1276					EvaluateTOSDeRef:
.1276	20 7e 12	jsr $127e			jsr 	EvaluateTOS
.1279	4c 3d 13	jmp $133d			jmp 	DeRefTop
.127c					EvaluateBase:
.127c	a2 00		ldx #$00			ldx 	#0 							; reset Stack index
.127e					EvaluateTOS:
.127e	a9 00		lda #$00			lda 	#0 							; start from lowest level.
.1280					EvaluateLevelAX:
.1280	48		pha				pha 								; save level on stack
.1281	a9 00		lda #$00			lda 	#0 							; erase the current stack level
.1283	95 28		sta $28,x			sta 	esInt0,x
.1285	95 30		sta $30,x			sta 	esInt1,x
.1287	95 38		sta $38,x			sta 	esInt2,x
.1289	95 40		sta $40,x			sta 	esInt3,x
.128b	95 20		sta $20,x			sta 	esType,x 					; default to integer.
.128d	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next token/element.
.128f	30 59		bmi $12ea			bmi 	EBNotVariable 				; if $80-$FF it is a token.
.1291	c9 70		cmp #$70			cmp 	#$70 						; if $70-$7F it is a constant
.1293	90 06		bcc $129b			bcc 	_EBNotConstant
.1295					_EBConstant:
.1295	20 7c 13	jsr $137c			jsr 	ExtractConstant
.1298	4c be 12	jmp $12be			jmp 	EBHaveTerm
.129b					_EBNotConstant:
.129b	c9 60		cmp #$60			cmp 	#$60 						; 60 is a string.
.129d	f0 06		beq $12a5			beq 	_EBHaveString
.129f	4c ac 15	jmp $15ac			jmp 	EHandlerNotImplemented
.12a2	4c be 12	jmp $12be			jmp 	EBHaveTerm
.12a5					_EBHaveString:
.12a5	98		tya				tya 								; put codePtr + 2 in the address, it's a string.
.12a6	18		clc				clc
.12a7	69 02		adc #$02			adc 	#2
.12a9	65 00		adc $00				adc 	codePtr
.12ab	95 28		sta $28,x			sta 	esInt0,x
.12ad	a5 01		lda $01				lda 	codePtr+1
.12af	69 00		adc #$00			adc 	#0
.12b1	95 30		sta $30,x			sta 	esInt1,x
.12b3	f6 20		inc $20,x			inc 	esType,x 					; make the type a string.
.12b5	98		tya				tya 								; position in A
.12b6	c8		iny				iny 								; point to offset and add it
.12b7	18		clc				clc
.12b8	71 00		adc ($00),y			adc 	(codePtr),y
.12ba	a8		tay				tay
.12bb	4c be 12	jmp $12be			jmp 	EBHaveTerm 				; do the term code.
.12be					EBHaveTerm:
.12be	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the next element.
.12c0	10 26		bpl $12e8			bpl 	_EBPopExit 					; needs to be a token to continue.
.12c2	84 03		sty $03				sty 	tempShort
.12c4	a8		tay				tay
.12c5	b9 7a 15	lda $157a,y			lda 	KeywordTypes-$80,y 			; get the type of the keyword.
.12c8	a4 03		ldy $03				ldy 	tempShort
.12ca	c9 10		cmp #$10			cmp 	#16 						; not a binary operator.
.12cc	b0 1a		bcs $12e8			bcs 	_EBPopExit
.12ce	85 03		sta $03				sta 	tempShort 					; save level of new operator.
.12d0	68		pla				pla 								; restore current level.
.12d1	c5 03		cmp $03				cmp 	tempShort 					; if current >= operator then exit
.12d3	b0 14		bcs $12e9			bcs 	_EBExit
.12d5	48		pha				pha 								; push level on stack.
.12d6	b1 00		lda ($00),y			lda		(codePtr),y					; get the token ID and skip
.12d8	c8		iny				iny
.12d9	48		pha				pha 								; put that on the stack.
.12da	e8		inx				inx 								; do the term in the next stack level.
.12db	a5 03		lda $03				lda 	tempShort 					; get the level of the operator.
.12dd	20 80 12	jsr $1280			jsr 	EvaluateLevelAX
.12e0	ca		dex				dex
.12e1	68		pla				pla 								; get token ID
.12e2	20 ad 13	jsr $13ad			jsr 	ExecuteCommand 				; execute command A.
.12e5	4c be 12	jmp $12be			jmp 	EBHaveTerm 					; keep going round
.12e8					_EBPopExit:
.12e8	68		pla				pla
.12e9					_EBExit:
.12e9	60		rts				rts
.12ea					EBNotVariable:
.12ea	84 03		sty $03				sty 	tempShort 					; get the type
.12ec	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.12ee	a8		tay				tay
.12ef	b9 7a 15	lda $157a,y			lda 	KeywordTypes-$80,y
.12f2	a4 03		ldy $03				ldy 	tempShort
.12f4	29 40		and #$40			and 	#$40 						; check unary function
.12f6	d0 37		bne $132f			bne 	_EBExecUnaryFunction
.12f8	b1 00		lda ($00),y			lda 	(codePtr),y 				; get function keyword.
.12fa	c8		iny				iny
.12fb	c9 8b		cmp #$8b			cmp 	#KWD_MINUS
.12fd	f0 0f		beq $130e			beq 	_EBNegate
.12ff	c9 91		cmp #$91			cmp 	#KWD_PLING
.1301	f0 14		beq $1317			beq 	_EBUnaryReference
.1303	c9 92		cmp #$92			cmp 	#KWD_QUESTION
.1305	f0 10		beq $1317			beq 	_EBUnaryReference
.1307	c9 93		cmp #$93			cmp 	#KWD_DOLLAR
.1309	f0 0c		beq $1317			beq 	_EBUnaryReference
.130b					_EBError:
.130b	4c d9 15	jmp $15d9			jmp 	EHandlerSyntax
.130e					_EBNegate:
.130e	20 68 12	jsr $1268			jsr 	EvaluateTerm
.1311	20 26 19	jsr $1926			jsr 	Int32Negate
.1314	4c be 12	jmp $12be			jmp 	EBHaveTerm
.1317					_EBUnaryReference:
.1317	48		pha				pha 								; save keyword
.1318	20 68 12	jsr $1268			jsr 	EvaluateTerm 				; get the address to case.
.131b	68		pla				pla
.131c	49 91		eor #$91			eor 	#KWD_PLING 					; is it pling, then will now be zero.
.131e	f0 08		beq $1328			beq 	_EBSetType
.1320	49 02		eor #$02			eor 	#KWD_DOLLAR^KWD_PLING 		; if was dollar will now be zero
.1322	f0 02		beq $1326			beq 	_EBSetString
.1324	a9 41		lda #$41			lda 	#$41 						; will end up as $C0
.1326					_EBSetString:
.1326	49 01		eor #$01			eor 	#$01 						; will end up as $81
.1328					_EBSetType:
.1328	09 80		ora #$80			ora 	#$80 						; make it a reference.
.132a	95 20		sta $20,x			sta 	esType,x
.132c	4c be 12	jmp $12be			jmp 	EBHaveTerm
.132f					_EBExecUnaryFunction:
.132f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the function token.
.1331	c8		iny				iny
.1332	20 ad 13	jsr $13ad			jsr 	ExecuteCommand 				; and do it.
.1335	4c be 12	jmp $12be			jmp 	EBHaveTerm
.1338					DeRefBoth:
.1338	e8		inx				inx
.1339	20 3d 13	jsr $133d			jsr 	DeRefTop
.133c	ca		dex				dex
.133d					DeRefTop:
.133d	b5 20		lda $20,x			lda 	esType,x 					; is it a reference ?
.133f	10 3a		bpl $137b			bpl 	_DRTExit
.1341	29 7f		and #$7f			and 	#$7F 						; clear the reference bit and write back.
.1343	95 20		sta $20,x			sta 	esType,x
.1345	4a		lsr a				lsr 	a 							; if string, exit. Strings are always references
.1346	b0 33		bcs $137b			bcs 	_DRTExit
.1348	b5 28		lda $28,x			lda 	esInt0,x 					; copy address over.
.134a	85 04		sta $04				sta 	temp0
.134c	b5 30		lda $30,x			lda 	esInt1,x
.134e	85 05		sta $05				sta 	temp0+1
.1350	98		tya				tya
.1351	48		pha				pha
.1352	a0 00		ldy #$00			ldy 	#0
.1354	b1 04		lda ($04),y			lda 	(temp0),y
.1356	95 28		sta $28,x			sta 	esInt0,x
.1358	b5 20		lda $20,x			lda 	esType,x 					; is it now zero, e.g. it's a !
.135a	f0 0c		beq $1368			beq 	_DRTPling
.135c	98		tya				tya 								; clear upper 3 bytes
.135d	95 30		sta $30,x			sta 	esInt1,x
.135f	95 38		sta $38,x			sta 	esInt2,x
.1361	95 40		sta $40,x			sta 	esInt3,x
.1363	95 20		sta $20,x			sta 	esType,x
.1365	4c 79 13	jmp $1379			jmp	 	_DRTExit2
.1368					_DRTPling:
.1368	94 20		sty $20,x			sty 	esType,x 					; make it an integer
.136a	c8		iny				iny
.136b	b1 04		lda ($04),y			lda 	(temp0),y 					; copy 4 bytes.
.136d	95 30		sta $30,x			sta 	esInt1,x
.136f	c8		iny				iny
.1370	b1 04		lda ($04),y			lda 	(temp0),y
.1372	95 38		sta $38,x			sta 	esInt2,x
.1374	c8		iny				iny
.1375	b1 04		lda ($04),y			lda 	(temp0),y
.1377	95 40		sta $40,x			sta 	esInt3,x
.1379					_DRTExit2:
.1379	68		pla				pla
.137a	a8		tay				tay
.137b					_DRTExit:
.137b	60		rts				rts
.137c					ExtractConstant:
.137c	a9 00		lda #$00			lda 	#0 							; count of number of hex digits read.
.137e	85 03		sta $03				sta 	tempShort 					; use tempShort for that
.1380	8a		txa				txa
.1381	48		pha				pha
.1382					_EBConstLoop:
.1382	e6 03		inc $03				inc 	tempShort 					; bump the hex digit count.
.1384	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character.
.1386	29 f0		and #$f0			and 	#$F0 						; check it is 70-7F
.1388	c9 70		cmp #$70			cmp 	#$70
.138a	d0 1e		bne $13aa			bne 	_EBConstEnd
.138c	a5 03		lda $03				lda 	tempShort 					; check LSB of digit count
.138e	4a		lsr a				lsr 	a
.138f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the digit and bump
.1391	c8		iny				iny
.1392	90 06		bcc $139a			bcc		_EBConstHigh 				; goes in upper byte.
.1394	29 0f		and #$0f			and 	#$0F
.1396	95 28		sta $28,x			sta 	esInt0,x 					; and write it out.
.1398	10 e8		bpl $1382			bpl 	_EBConstLoop 				; try next one.
.139a					_EBConstHigh:
.139a	0a		asl a				asl 	a
.139b	0a		asl a				asl 	a
.139c	0a		asl a				asl 	a
.139d	0a		asl a				asl 	a
.139e	15 28		ora $28,x			ora 	esInt0,x 					; put into upper 4 bits
.13a0	95 28		sta $28,x			sta 	esInt0,x
.13a2	8a		txa				txa 								; move to next slot in data stack.
.13a3	18		clc				clc
.13a4	69 08		adc #$08			adc 	#DataStackSize
.13a6	aa		tax				tax
.13a7	4c 82 13	jmp $1382			jmp 	_EBConstLoop
.13aa					_EBConstEnd:
.13aa	68		pla				pla
.13ab	aa		tax				tax
.13ac	60		rts				rts
.13ad					ExecuteCommand:
.13ad	85 03		sta $03				sta 	tempShort  					; needs making 65C02 specific.
.13af	8a		txa				txa
.13b0	48		pha				pha
.13b1	a6 03		ldx $03				ldx 	tempShort
.13b3	bd d0 15	lda $15d0,x			lda 	TokenVectorLow-$80,x
.13b6	85 04		sta $04				sta 	temp0
.13b8	bd 26 16	lda $1626,x			lda 	TokenVectorHigh-$80,x
.13bb	85 05		sta $05				sta 	temp0+1
.13bd	68		pla				pla
.13be	aa		tax				tax
.13bf	6c 04 00	jmp ($0004)			jmp 	(temp0)

;******  Return to file: basic.asm


;******  Processing file: common/evaluate/unary.asm

.13c2					UnaryPage:
.13c2	20 dd 13	jsr $13dd			jsr 	UnaryFalse 					; set all to zero/int
.13c5	a9 00		lda #$00			lda 	#BasicProgram & $FF
.13c7	95 28		sta $28,x			sta 	esInt0,x
.13c9	a9 1a		lda #$1a			lda 	#BasicProgram >> 8
.13cb	95 30		sta $30,x			sta 	esInt1,x
.13cd	60		rts				rts
.13ce					UnaryParenthesis:
.13ce	20 7e 12	jsr $127e			jsr 	EvaluateTOS					; evaluate expression
.13d1	20 82 10	jsr $1082			jsr 	CheckRightParen				; check for )
.13d4	60		rts				rts
.13d5					UnaryTrue:
.13d5	20 68 19	jsr $1968			jsr 	Int32True
.13d8	a9 00		lda #$00			lda 	#0
.13da	95 20		sta $20,x			sta 	esType,x
.13dc	60		rts				rts
.13dd					UnaryFalse:
.13dd	20 6c 19	jsr $196c			jsr 	Int32False
.13e0	a9 00		lda #$00			lda 	#0
.13e2	95 20		sta $20,x			sta 	esType,x
.13e4	60		rts				rts
.13e5					UnaryAbs:
.13e5	20 68 12	jsr $1268			jsr 	EvaluateTerm				; work out value required and dispatch
.13e8	20 21 19	jsr $1921			jsr		Int32Absolute
.13eb	a9 00		lda #$00			lda 	#0
.13ed	95 20		sta $20,x			sta 	esType,x
.13ef	60		rts				rts
.13f0					UnarySys:
.13f0	20 68 12	jsr $1268			jsr 	EvaluateTerm				; address to call
.13f3	b5 28		lda $28,x			lda 	esInt0,x 					; copy call address
.13f5	85 04		sta $04				sta 	temp0
.13f7	b5 30		lda $30,x			lda 	esInt1,x
.13f9	85 05		sta $05				sta 	temp0+1
.13fb	8a		txa				txa
.13fc	48		pha				pha
.13fd	98		tya				tya
.13fe	48		pha				pha
.13ff	ad 00 08	lda $0800			lda 	('A'-'A')*4+RootVariables 	; load AXY
.1402	ae 5c 08	ldx $085c			ldx 	('X'-'A')*4+RootVariables
.1405	ac 60 08	ldy $0860			ldy 	('Y'-'A')*4+RootVariables
.1408	20 2a 14	jsr $142a			jsr 	_USCall						; call code
.140b	8d 00 08	sta $0800			sta 	('A'-'A')*4+RootVariables 	; save AXY
.140e	8e 5c 08	stx $085c			stx 	('X'-'A')*4+RootVariables
.1411	8c 60 08	sty $0860			sty 	('Y'-'A')*4+RootVariables
.1414	68		pla				pla
.1415	a8		tay				tay
.1416	68		pla				pla
.1417	aa		tax				tax
.1418	ad 00 08	lda $0800			lda 	('A'-'A')*4+RootVariables 	; return A.
.141b	95 28		sta $28,x			sta 	esInt0,x
.141d	a9 00		lda #$00			lda 	#0
.141f	95 30		sta $30,x			sta 	esInt1,x
.1421	95 38		sta $38,x			sta 	esInt2,x
.1423	95 40		sta $40,x			sta 	esInt3,x
.1425	a9 00		lda #$00			lda 	#0
.1427	95 20		sta $20,x			sta 	esType,x
.1429	60		rts				rts
.142a	6c 04 00	jmp ($0004)	_USCall:jmp 	(temp0)
.142d					UnarySgn1:
.142d	20 68 12	jsr $1268			jsr 	EvaluateTerm				; work out value required and dispatch
.1430	20 59 19	jsr $1959			jsr 	Int32Sign
.1433	a9 00		lda #$00			lda 	#0
.1435	95 20		sta $20,x			sta 	esType,x
.1437	60		rts				rts
.1438					UnaryNot:
.1438	20 68 12	jsr $1268			jsr 	EvaluateTerm				; work out value required and dispatch
.143b	20 40 19	jsr $1940			jsr 	Int32Not
.143e	a9 00		lda #$00			lda 	#0
.1440	95 20		sta $20,x			sta 	esType,x
.1442	60		rts				rts
.1443					UnaryMin:
.1443	38		sec				sec 								; min indicated with CS
.1444	b0 01		bcs $1447			bcs 	UnaryMax+1
.1446					UnaryMax:
.1446	18		clc				clc 								; max is CC.
.1447	08		php				php 								; save what we're doing.
.1448	20 70 10	jsr $1070			jsr 	CheckLeftParen 				; check for (, required here
.144b	20 76 12	jsr $1276			jsr 	EvaluateTOSDeRef			; evaluate expression
.144e	e8		inx				inx
.144f	20 6a 10	jsr $106a			jsr 	CheckComma
.1452	20 76 12	jsr $1276			jsr 	EvaluateTOSDeRef
.1455	20 38 13	jsr $1338			jsr 	DerefBoth 					; dereference them.
.1458	ca		dex				dex
.1459	20 82 10	jsr $1082			jsr 	CheckRightParen
.145c	20 61 17	jsr $1761			jsr 	Int32Less 					; is p1 < p2, CS if true.
.145f	a9 00		lda #$00			lda 	#0 							; put into A, now 1 if <, 0 if >
.1461	69 00		adc #$00			adc 	#0
.1463	28		plp				plp
.1464	69 00		adc #$00			adc 	#0 							; toggle bit 0 for Min.
.1466	4a		lsr a				lsr 	a 							; put into carry
.1467	90 03		bcc $146c			bcc 	_UMinMaxExit 				; if clear just exit.
.1469	20 29 12	jsr $1229			jsr 	SwapTopStack 				; swap two values over.
.146c					_UMinMaxExit:
.146c	a9 00		lda #$00			lda 	#0
.146e	95 20		sta $20,x			sta 	esType,x
.1470	60		rts				rts
.1471					UTypeError:
.1471	4c e9 15	jmp $15e9			jmp 	EHandlerTypeMismatch
.1474					UnaryRefToValue:
.1474	a9 0f		lda #$0f			lda 	#15
.1476	20 80 12	jsr $1280			jsr 	EvaluateLevelAX 			; get a term.
.1479	b5 20		lda $20,x			lda 	esType,x
.147b	10 f4		bpl $1471			bpl 	UTypeError 					; not a reference
.147d	29 7f		and #$7f			and 	#$7F 						; clear reference bit.
.147f	95 20		sta $20,x			sta 	esType,x 					; overwrite type
.1481	a9 00		lda #$00			lda 	#0
.1483	95 20		sta $20,x			sta 	esType,x
.1485	60		rts				rts
.1486					UnaryHexMarker:
.1486	4c 68 12	jmp $1268			jmp 	EvaluateTerm
.1489					UnaryRandom:
.1489	20 9c 19	jsr $199c			jsr 	Int32Random 				; random #
.148c	a9 00		lda #$00			lda 	#0
.148e	95 20		sta $20,x			sta 	esType,x
.1490	60		rts				rts
.1491					UnaryLen:
.1491	20 68 12	jsr $1268			jsr 	EvaluateTerm				; work out value required and dispatch
.1494	b5 28		lda $28,x			lda 	esInt0,x 					; copy addr to temp0
.1496	85 04		sta $04				sta 	temp0
.1498	b5 30		lda $30,x			lda 	esInt1,x
.149a	85 05		sta $05				sta 	temp0+1
.149c	20 dd 13	jsr $13dd			jsr 	UnaryFalse 					; sets return to int zero.
.149f	98		tya				tya
.14a0	48		pha				pha
.14a1	a0 00		ldy #$00			ldy 	#0
.14a3					_ULCheck:
.14a3	b1 04		lda ($04),y			lda 	(temp0),y
.14a5	f0 03		beq $14aa			beq 	_ULFound
.14a7	c8		iny				iny
.14a8	d0 f9		bne $14a3			bne 	_ULCheck
.14aa					_ULFound:
.14aa	94 28		sty $28,x			sty 	esInt0,x 					; update result
.14ac	68		pla				pla
.14ad	a8		tay				tay
.14ae	60		rts				rts
.14af	60		rts				rts
.14b0					UnaryChr:
.14b0	20 68 12	jsr $1268			jsr 	EvaluateTerm				; work out value required and dereference
.14b3	b5 28		lda $28,x			lda 	esInt0,x 					; get char code
.14b5	8d a5 08	sta $08a5			sta 	ChrBuffer 					; put into buffer.
.14b8	a9 00		lda #$00			lda 	#0
.14ba	8d a6 08	sta $08a6			sta 	ChrBuffer+1 				; make ASCIIZ
.14bd	a9 a5		lda #$a5			lda 	#ChrBuffer & $FF 			; set address
.14bf	95 28		sta $28,x			sta 	esInt0,x
.14c1	a9 08		lda #$08			lda 	#ChrBuffer >> 8
.14c3	95 30		sta $30,x			sta 	esInt1,x
.14c5	f6 20		inc $20,x			inc 	esType,x 					; makes it a string
.14c7	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/generated/errors.asm

.14c8					EHandlerAssert:
.14c8	20 95 10	jsr $1095		jsr	ErrorHandler
>14cb	41 73 73 65 72 74 20 46			.text "Assert Failed",0
>14d3	61 69 6c 65 64 00
.14d9					EHandlerBadIndex:
.14d9	20 95 10	jsr $1095		jsr	ErrorHandler
>14dc	57 72 6f 6e 67 20 4e 45			.text "Wrong NEXT index",0
>14e4	58 54 20 69 6e 64 65 78 00
.14ed					EHandlerBadProc:
.14ed	20 95 10	jsr $1095		jsr	ErrorHandler
>14f0	55 6e 6b 6e 6f 77 6e 20			.text "Unknown Procedure",0
>14f8	50 72 6f 63 65 64 75 72 65 00
.1502					EHandlerClosure:
.1502	20 95 10	jsr $1095		jsr	ErrorHandler
>1505	53 74 72 75 63 74 75 72			.text "Structure Error",0
>150d	65 20 45 72 72 6f 72 00
.1515					EHandlerDivideZero:
.1515	20 95 10	jsr $1095		jsr	ErrorHandler
>1518	44 69 76 69 64 65 20 62			.text "Divide by Zero",0
>1520	79 20 5a 65 72 6f 00
.1527					EHandlerLineNumber:
.1527	20 95 10	jsr $1095		jsr	ErrorHandler
>152a	55 6e 6b 6e 6f 77 6e 20			.text "Unknown line",0
>1532	6c 69 6e 65 00
.1537					EHandlerMemory:
.1537	20 95 10	jsr $1095		jsr	ErrorHandler
>153a	49 6e 73 75 66 66 69 63			.text "Insufficient Memory",0
>1542	69 65 6e 74 20 4d 65 6d 6f 72 79 00
.154e					EHandlerNoGosub:
.154e	20 95 10	jsr $1095		jsr	ErrorHandler
>1551	52 65 74 75 72 6e 20 77			.text "Return without Gosub",0
>1559	69 74 68 6f 75 74 20 47 6f 73 75 62 00
.1566					EHandlerNoProc:
.1566	20 95 10	jsr $1095		jsr	ErrorHandler
>1569	45 6e 64 50 72 6f 63 20			.text "EndProc without Proc",0
>1571	77 69 74 68 6f 75 74 20 50 72 6f 63 00
.157e					EHandlerNoRepeat:
.157e	20 95 10	jsr $1095		jsr	ErrorHandler
>1581	55 6e 74 69 6c 20 77 69			.text "Until without Repeat",0
>1589	74 68 6f 75 74 20 52 65 70 65 61 74 00
.1596					EHandlerNoWhile:
.1596	20 95 10	jsr $1095		jsr	ErrorHandler
>1599	57 65 6e 64 20 77 69 74			.text "Wend without While",0
>15a1	68 6f 75 74 20 57 68 69 6c 65 00
.15ac					EHandlerNotImplemented:
.15ac	20 95 10	jsr $1095		jsr	ErrorHandler
>15af	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>15b7	65 6d 65 6e 74 65 64 00
.15bf					EHandlerParameters:
.15bf	20 95 10	jsr $1095		jsr	ErrorHandler
>15c2	42 61 64 20 50 61 72 61			.text "Bad Parameters",0
>15ca	6d 65 74 65 72 73 00
.15d1					EHandlerStop:
.15d1	20 95 10	jsr $1095		jsr	ErrorHandler
>15d4	53 74 6f 70 00				.text "Stop",0
.15d9					EHandlerSyntax:
.15d9	20 95 10	jsr $1095		jsr	ErrorHandler
>15dc	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>15e4	72 72 6f 72 00
.15e9					EHandlerTypeMismatch:
.15e9	20 95 10	jsr $1095		jsr	ErrorHandler
>15ec	54 79 70 65 20 4d 69 73			.text "Type Mismatch",0
>15f4	6d 61 74 63 68 00

;******  Return to file: basic.asm


;******  Processing file: common/generated/keytypes.asm

.15fa					KeywordTypes:
>15fa	81					.byte $81 ; $80 <<end>>
>15fb	01					.byte $01 ; $81 and
>15fc	01					.byte $01 ; $82 or
>15fd	01					.byte $01 ; $83 xor
>15fe	02					.byte $02 ; $84 >
>15ff	02					.byte $02 ; $85 <
>1600	02					.byte $02 ; $86 >=
>1601	02					.byte $02 ; $87 <=
>1602	02					.byte $02 ; $88 <>
>1603	02					.byte $02 ; $89 =
>1604	03					.byte $03 ; $8a +
>1605	03					.byte $03 ; $8b -
>1606	04					.byte $04 ; $8c *
>1607	04					.byte $04 ; $8d /
>1608	04					.byte $04 ; $8e %
>1609	04					.byte $04 ; $8f >>
>160a	04					.byte $04 ; $90 <<
>160b	05					.byte $05 ; $91 !
>160c	05					.byte $05 ; $92 ?
>160d	05					.byte $05 ; $93 $
>160e	40					.byte $40 ; $94 ~
>160f	40					.byte $40 ; $95 (
>1610	40					.byte $40 ; $96 &
>1611	40					.byte $40 ; $97 @
>1612	40					.byte $40 ; $98 len
>1613	40					.byte $40 ; $99 sgn
>1614	40					.byte $40 ; $9a abs
>1615	40					.byte $40 ; $9b random
>1616	40					.byte $40 ; $9c page
>1617	40					.byte $40 ; $9d true
>1618	40					.byte $40 ; $9e false
>1619	40					.byte $40 ; $9f min
>161a	40					.byte $40 ; $a0 max
>161b	40					.byte $40 ; $a1 sys
>161c	40					.byte $40 ; $a2 code
>161d	40					.byte $40 ; $a3 timer
>161e	40					.byte $40 ; $a4 event
>161f	40					.byte $40 ; $a5 get
>1620	40					.byte $40 ; $a6 joy.x
>1621	40					.byte $40 ; $a7 joy.y
>1622	40					.byte $40 ; $a8 joy.btn
>1623	40					.byte $40 ; $a9 inkey
>1624	40					.byte $40 ; $aa alloc
>1625	40					.byte $40 ; $ab chr
>1626	81					.byte $81 ; $ac ,
>1627	81					.byte $81 ; $ad ;
>1628	81					.byte $81 ; $ae )
>1629	81					.byte $81 ; $af ++
>162a	81					.byte $81 ; $b0 --
>162b	81					.byte $81 ; $b1 [
>162c	81					.byte $81 ; $b2 ]
>162d	82					.byte $82 ; $b3 if
>162e	82					.byte $82 ; $b4 for
>162f	82					.byte $82 ; $b5 repeat
>1630	82					.byte $82 ; $b6 proc
>1631	82					.byte $82 ; $b7 while
>1632	80					.byte $80 ; $b8 endif
>1633	80					.byte $80 ; $b9 next
>1634	80					.byte $80 ; $ba until
>1635	80					.byte $80 ; $bb endproc
>1636	80					.byte $80 ; $bc wend
>1637	81					.byte $81 ; $bd rem
>1638	81					.byte $81 ; $be let
>1639	81					.byte $81 ; $bf '
>163a	81					.byte $81 ; $c0 :
>163b	81					.byte $81 ; $c1 then
>163c	81					.byte $81 ; $c2 else
>163d	81					.byte $81 ; $c3 to
>163e	81					.byte $81 ; $c4 step
>163f	81					.byte $81 ; $c5 vdu
>1640	81					.byte $81 ; $c6 print
>1641	81					.byte $81 ; $c7 call
>1642	81					.byte $81 ; $c8 local
>1643	81					.byte $81 ; $c9 goto
>1644	81					.byte $81 ; $ca gosub
>1645	81					.byte $81 ; $cb return
>1646	81					.byte $81 ; $cc assert
>1647	81					.byte $81 ; $cd stop
>1648	81					.byte $81 ; $ce end
>1649	81					.byte $81 ; $cf dim
>164a	81					.byte $81 ; $d0 clear
>164b	81					.byte $81 ; $d1 load
>164c	81					.byte $81 ; $d2 save
>164d	81					.byte $81 ; $d3 list
>164e	81					.byte $81 ; $d4 new
>164f	81					.byte $81 ; $d5 run

;******  Return to file: basic.asm


;******  Processing file: common/generated/vectors.asm

.1650					TokenVectorLow:
>1650	dd					.byte InstructionUndefined & $FF       ; <<end>>
>1651	5a					.byte BinaryAnd & $FF                  ; and
>1652	4f					.byte BinaryOr & $FF                   ; or
>1653	44					.byte BinaryXor & $FF                  ; xor
>1654	e7					.byte Binary_Greater & $FF             ; >
>1655	d2					.byte Binary_Less & $FF                ; <
>1656	d9					.byte Binary_GreaterEqual & $FF        ; >=
>1657	e0					.byte Binary_LessEqual & $FF           ; <=
>1658	cb					.byte Binary_NotEqual & $FF            ; <>
>1659	be					.byte Binary_Equal & $FF               ; =
>165a	fc					.byte BinaryAdd & $FF                  ; +
>165b	07					.byte BinarySub & $FF                  ; -
>165c	12					.byte BinaryMult & $FF                 ; *
>165d	1d					.byte BinaryDivide & $FF               ; /
>165e	2b					.byte BinaryModulus & $FF              ; %
>165f	77					.byte BinaryShiftRight & $FF           ; >>
>1660	65					.byte BinaryShiftLeft & $FF            ; <<
>1661	9d					.byte IndirectWord & $FF               ; !
>1662	a8					.byte IndirectByte & $FF               ; ?
>1663	b3					.byte IndirectString & $FF             ; $
>1664	38					.byte UnaryNot & $FF                   ; ~
>1665	ce					.byte UnaryParenthesis & $FF           ; (
>1666	86					.byte UnaryHexMarker & $FF             ; &
>1667	74					.byte UnaryRefToValue & $FF            ; @
>1668	91					.byte UnaryLen & $FF                   ; len
>1669	2d					.byte UnarySgn1 & $FF                  ; sgn
>166a	e5					.byte UnaryAbs & $FF                   ; abs
>166b	89					.byte UnaryRandom & $FF                ; random
>166c	c2					.byte UnaryPage & $FF                  ; page
>166d	d5					.byte UnaryTrue & $FF                  ; true
>166e	dd					.byte UnaryFalse & $FF                 ; false
>166f	43					.byte UnaryMin & $FF                   ; min
>1670	46					.byte UnaryMax & $FF                   ; max
>1671	f0					.byte UnarySys & $FF                   ; sys
>1672	dd					.byte InstructionUndefined & $FF       ; code
>1673	dd					.byte InstructionUndefined & $FF       ; timer
>1674	dd					.byte InstructionUndefined & $FF       ; event
>1675	dd					.byte InstructionUndefined & $FF       ; get
>1676	dd					.byte InstructionUndefined & $FF       ; joy.x
>1677	dd					.byte InstructionUndefined & $FF       ; joy.y
>1678	dd					.byte InstructionUndefined & $FF       ; joy.btn
>1679	dd					.byte InstructionUndefined & $FF       ; inkey
>167a	dd					.byte InstructionUndefined & $FF       ; alloc
>167b	b0					.byte UnaryChr & $FF                   ; chr
>167c	92					.byte NoOp1 & $FF                      ; ,
>167d	92					.byte NoOp2 & $FF                      ; ;
>167e	92					.byte NoOp3 & $FF                      ; )
>167f	dd					.byte InstructionUndefined & $FF       ; ++
>1680	dd					.byte InstructionUndefined & $FF       ; --
>1681	dd					.byte InstructionUndefined & $FF       ; [
>1682	dd					.byte InstructionUndefined & $FF       ; ]
>1683	dd					.byte InstructionUndefined & $FF       ; if
>1684	dd					.byte InstructionUndefined & $FF       ; for
>1685	dd					.byte InstructionUndefined & $FF       ; repeat
>1686	92					.byte NoOp6 & $FF                      ; proc
>1687	dd					.byte InstructionUndefined & $FF       ; while
>1688	dd					.byte InstructionUndefined & $FF       ; endif
>1689	dd					.byte InstructionUndefined & $FF       ; next
>168a	dd					.byte InstructionUndefined & $FF       ; until
>168b	dd					.byte InstructionUndefined & $FF       ; endproc
>168c	dd					.byte InstructionUndefined & $FF       ; wend
>168d	dd					.byte InstructionUndefined & $FF       ; rem
>168e	dd					.byte InstructionUndefined & $FF       ; let
>168f	dd					.byte InstructionUndefined & $FF       ; '
>1690	dd					.byte InstructionUndefined & $FF       ; :
>1691	92					.byte NoOp7 & $FF                      ; then
>1692	dd					.byte InstructionUndefined & $FF       ; else
>1693	92					.byte NoOp8 & $FF                      ; to
>1694	92					.byte NoOp9 & $FF                      ; step
>1695	dd					.byte InstructionUndefined & $FF       ; vdu
>1696	dd					.byte InstructionUndefined & $FF       ; print
>1697	dd					.byte InstructionUndefined & $FF       ; call
>1698	dd					.byte InstructionUndefined & $FF       ; local
>1699	dd					.byte InstructionUndefined & $FF       ; goto
>169a	dd					.byte InstructionUndefined & $FF       ; gosub
>169b	dd					.byte InstructionUndefined & $FF       ; return
>169c	dd					.byte InstructionUndefined & $FF       ; assert
>169d	dd					.byte InstructionUndefined & $FF       ; stop
>169e	dd					.byte InstructionUndefined & $FF       ; end
>169f	dd					.byte InstructionUndefined & $FF       ; dim
>16a0	dd					.byte InstructionUndefined & $FF       ; clear
>16a1	dd					.byte InstructionUndefined & $FF       ; load
>16a2	dd					.byte InstructionUndefined & $FF       ; save
>16a3	dd					.byte InstructionUndefined & $FF       ; list
>16a4	dd					.byte InstructionUndefined & $FF       ; new
>16a5	dd					.byte InstructionUndefined & $FF       ; run
.16a6					TokenVectorHigh:
>16a6	10					.byte InstructionUndefined >> 8        ; <<end>>
>16a7	11					.byte BinaryAnd >> 8                   ; and
>16a8	11					.byte BinaryOr >> 8                    ; or
>16a9	11					.byte BinaryXor >> 8                   ; xor
>16aa	11					.byte Binary_Greater >> 8              ; >
>16ab	11					.byte Binary_Less >> 8                 ; <
>16ac	11					.byte Binary_GreaterEqual >> 8         ; >=
>16ad	11					.byte Binary_LessEqual >> 8            ; <=
>16ae	11					.byte Binary_NotEqual >> 8             ; <>
>16af	11					.byte Binary_Equal >> 8                ; =
>16b0	10					.byte BinaryAdd >> 8                   ; +
>16b1	11					.byte BinarySub >> 8                   ; -
>16b2	11					.byte BinaryMult >> 8                  ; *
>16b3	11					.byte BinaryDivide >> 8                ; /
>16b4	11					.byte BinaryModulus >> 8               ; %
>16b5	11					.byte BinaryShiftRight >> 8            ; >>
>16b6	11					.byte BinaryShiftLeft >> 8             ; <<
>16b7	11					.byte IndirectWord >> 8                ; !
>16b8	11					.byte IndirectByte >> 8                ; ?
>16b9	11					.byte IndirectString >> 8              ; $
>16ba	14					.byte UnaryNot >> 8                    ; ~
>16bb	13					.byte UnaryParenthesis >> 8            ; (
>16bc	14					.byte UnaryHexMarker >> 8              ; &
>16bd	14					.byte UnaryRefToValue >> 8             ; @
>16be	14					.byte UnaryLen >> 8                    ; len
>16bf	14					.byte UnarySgn1 >> 8                   ; sgn
>16c0	13					.byte UnaryAbs >> 8                    ; abs
>16c1	14					.byte UnaryRandom >> 8                 ; random
>16c2	13					.byte UnaryPage >> 8                   ; page
>16c3	13					.byte UnaryTrue >> 8                   ; true
>16c4	13					.byte UnaryFalse >> 8                  ; false
>16c5	14					.byte UnaryMin >> 8                    ; min
>16c6	14					.byte UnaryMax >> 8                    ; max
>16c7	13					.byte UnarySys >> 8                    ; sys
>16c8	10					.byte InstructionUndefined >> 8        ; code
>16c9	10					.byte InstructionUndefined >> 8        ; timer
>16ca	10					.byte InstructionUndefined >> 8        ; event
>16cb	10					.byte InstructionUndefined >> 8        ; get
>16cc	10					.byte InstructionUndefined >> 8        ; joy.x
>16cd	10					.byte InstructionUndefined >> 8        ; joy.y
>16ce	10					.byte InstructionUndefined >> 8        ; joy.btn
>16cf	10					.byte InstructionUndefined >> 8        ; inkey
>16d0	10					.byte InstructionUndefined >> 8        ; alloc
>16d1	14					.byte UnaryChr >> 8                    ; chr
>16d2	10					.byte NoOp1 >> 8                       ; ,
>16d3	10					.byte NoOp2 >> 8                       ; ;
>16d4	10					.byte NoOp3 >> 8                       ; )
>16d5	10					.byte InstructionUndefined >> 8        ; ++
>16d6	10					.byte InstructionUndefined >> 8        ; --
>16d7	10					.byte InstructionUndefined >> 8        ; [
>16d8	10					.byte InstructionUndefined >> 8        ; ]
>16d9	10					.byte InstructionUndefined >> 8        ; if
>16da	10					.byte InstructionUndefined >> 8        ; for
>16db	10					.byte InstructionUndefined >> 8        ; repeat
>16dc	10					.byte NoOp6 >> 8                       ; proc
>16dd	10					.byte InstructionUndefined >> 8        ; while
>16de	10					.byte InstructionUndefined >> 8        ; endif
>16df	10					.byte InstructionUndefined >> 8        ; next
>16e0	10					.byte InstructionUndefined >> 8        ; until
>16e1	10					.byte InstructionUndefined >> 8        ; endproc
>16e2	10					.byte InstructionUndefined >> 8        ; wend
>16e3	10					.byte InstructionUndefined >> 8        ; rem
>16e4	10					.byte InstructionUndefined >> 8        ; let
>16e5	10					.byte InstructionUndefined >> 8        ; '
>16e6	10					.byte InstructionUndefined >> 8        ; :
>16e7	10					.byte NoOp7 >> 8                       ; then
>16e8	10					.byte InstructionUndefined >> 8        ; else
>16e9	10					.byte NoOp8 >> 8                       ; to
>16ea	10					.byte NoOp9 >> 8                       ; step
>16eb	10					.byte InstructionUndefined >> 8        ; vdu
>16ec	10					.byte InstructionUndefined >> 8        ; print
>16ed	10					.byte InstructionUndefined >> 8        ; call
>16ee	10					.byte InstructionUndefined >> 8        ; local
>16ef	10					.byte InstructionUndefined >> 8        ; goto
>16f0	10					.byte InstructionUndefined >> 8        ; gosub
>16f1	10					.byte InstructionUndefined >> 8        ; return
>16f2	10					.byte InstructionUndefined >> 8        ; assert
>16f3	10					.byte InstructionUndefined >> 8        ; stop
>16f4	10					.byte InstructionUndefined >> 8        ; end
>16f5	10					.byte InstructionUndefined >> 8        ; dim
>16f6	10					.byte InstructionUndefined >> 8        ; clear
>16f7	10					.byte InstructionUndefined >> 8        ; load
>16f8	10					.byte InstructionUndefined >> 8        ; save
>16f9	10					.byte InstructionUndefined >> 8        ; list
>16fa	10					.byte InstructionUndefined >> 8        ; new
>16fb	10					.byte InstructionUndefined >> 8        ; run

;******  Return to file: basic.asm


;******  Processing file: common/math/int32binary.asm

.16fc					Int32And:
.16fc	b5 28		lda $28,x			lda 	esInt0,x
.16fe	35 29		and $29,x			and 	esInt0+1,x
.1700	95 28		sta $28,x			sta 	esInt0,x
.1702	b5 30		lda $30,x			lda 	esInt1,x
.1704	35 31		and $31,x			and 	esInt1+1,x
.1706	95 30		sta $30,x			sta 	esInt1,x
.1708	b5 38		lda $38,x			lda 	esInt2,x
.170a	35 39		and $39,x			and 	esInt2+1,x
.170c	95 38		sta $38,x			sta 	esInt2,x
.170e	b5 40		lda $40,x			lda 	esInt3,x
.1710	35 41		and $41,x			and 	esInt3+1,x
.1712	95 40		sta $40,x			sta 	esInt3,x
.1714	60		rts				rts
.1715					Int32Or:
.1715	b5 28		lda $28,x			lda 	esInt0,x
.1717	15 29		ora $29,x			ora 	esInt0+1,x
.1719	95 28		sta $28,x			sta 	esInt0,x
.171b	b5 30		lda $30,x			lda 	esInt1,x
.171d	15 31		ora $31,x			ora 	esInt1+1,x
.171f	95 30		sta $30,x			sta 	esInt1,x
.1721	b5 38		lda $38,x			lda 	esInt2,x
.1723	15 39		ora $39,x			ora 	esInt2+1,x
.1725	95 38		sta $38,x			sta 	esInt2,x
.1727	b5 40		lda $40,x			lda 	esInt3,x
.1729	15 41		ora $41,x			ora 	esInt3+1,x
.172b	95 40		sta $40,x			sta 	esInt3,x
.172d	60		rts				rts
.172e					Int32Xor:
.172e	b5 28		lda $28,x			lda 	esInt0,x
.1730	55 29		eor $29,x			eor 	esInt0+1,x
.1732	95 28		sta $28,x			sta 	esInt0,x
.1734	b5 30		lda $30,x			lda 	esInt1,x
.1736	55 31		eor $31,x			eor 	esInt1+1,x
.1738	95 30		sta $30,x			sta 	esInt1,x
.173a	b5 38		lda $38,x			lda 	esInt2,x
.173c	55 39		eor $39,x			eor 	esInt2+1,x
.173e	95 38		sta $38,x			sta 	esInt2,x
.1740	b5 40		lda $40,x			lda 	esInt3,x
.1742	55 41		eor $41,x			eor 	esInt3+1,x
.1744	95 40		sta $40,x			sta 	esInt3,x
.1746	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32compare.asm

.1747					Int32Equal:
.1747	b5 28		lda $28,x			lda 	esInt0,x
.1749	d5 29		cmp $29,x			cmp 	esInt0+1,x
.174b	d0 2b		bne $1778			bne 	Int32CFail
.174d	b5 30		lda $30,x			lda 	esInt1,x
.174f	d5 31		cmp $31,x			cmp 	esInt1+1,x
.1751	d0 25		bne $1778			bne 	Int32CFail
.1753	b5 38		lda $38,x			lda 	esInt2,x
.1755	d5 39		cmp $39,x			cmp 	esInt2+1,x
.1757	d0 1f		bne $1778			bne 	Int32CFail
.1759	b5 40		lda $40,x			lda 	esInt3,x
.175b	d5 41		cmp $41,x			cmp 	esInt3+1,x
.175d	d0 19		bne $1778			bne 	Int32CFail
.175f					Int32CSucceed:
.175f	38		sec				sec
.1760	60		rts				rts
.1761					Int32Less:
.1761	38		sec				sec
.1762	b5 28		lda $28,x			lda		esInt0,x
.1764	f5 29		sbc $29,x			sbc 	esInt0+1,x
.1766	b5 30		lda $30,x			lda		esInt1,x
.1768	f5 31		sbc $31,x			sbc 	esInt1+1,x
.176a	b5 38		lda $38,x			lda		esInt2,x
.176c	f5 39		sbc $39,x			sbc 	esInt2+1,x
.176e	b5 40		lda $40,x			lda		esInt3,x
.1770	f5 41		sbc $41,x			sbc 	esInt3+1,x
.1772	50 02		bvc $1776			bvc 	_I32LNoOverflow
.1774	49 80		eor #$80			eor 	#$80
.1776					_I32LNoOverflow
.1776	30 e7		bmi $175f			bmi 	Int32CSucceed
.1778					Int32CFail:
.1778	18		clc				clc
.1779	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32divide.asm

.177a					Int32SDivide:
.177a	98		tya				tya  								; save Y, which is the count of negations
.177b	48		pha				pha
.177c	a0 00		ldy #$00			ldy 	#0 							; zero count
.177e	20 96 17	jsr $1796			jsr 	_Int32SRemSign 				; unsign TOS
.1781	e8		inx				inx 								; unsign TOS+1
.1782	20 96 17	jsr $1796			jsr 	_Int32SRemSign
.1785	ca		dex				dex
.1786	98		tya				tya 								; save sign count on stack
.1787	48		pha				pha
.1788	20 9f 17	jsr $179f			jsr 	Int32UDivide 				; unsigned division
.178b	68		pla				pla 								; get sign count back
.178c	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.178e	f0 03		beq $1793			beq 	_I32SNoNeg
.1790	20 26 19	jsr $1926			jsr 	Int32Negate
.1793					_I32SNoNeg:
.1793	68		pla				pla 								; restoe Y and exit
.1794	a8		tay				tay
.1795	60		rts				rts
.1796					_Int32SRemSign:
.1796	b5 40		lda $40,x			lda 	esInt3,x 					; is it -ve
.1798	10 04		bpl $179e			bpl 	_Int32SRSExit
.179a	c8		iny				iny 								; increment the sign count
.179b	20 26 19	jsr $1926			jsr 	Int32Negate 				; negate the value.
.179e					_Int32SRSExit:
.179e	60		rts				rts
.179f					Int32UDivide:
.179f	e8		inx				inx 								; clear A
.17a0	e8		inx				inx
.17a1	20 6c 19	jsr $196c			jsr 	Int32False
.17a4	ca		dex				dex
.17a5	ca		dex				dex
.17a6	98		tya				tya 								; save Y on the stack
.17a7	48		pha				pha
.17a8	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.17aa					_Int32UDLoop:
.17aa	16 28		asl $28,x			asl 	esInt0,x					; shift QA left. First Q
.17ac	36 30		rol $30,x			rol 	esInt1,x
.17ae	36 38		rol $38,x			rol 	esInt2,x
.17b0	36 40		rol $40,x			rol 	esInt3,x
.17b2	36 2a		rol $2a,x			rol 	esInt0+2,x 					; then A.
.17b4	36 32		rol $32,x			rol 	esInt1+2,x
.17b6	36 3a		rol $3a,x			rol 	esInt2+2,x
.17b8	36 42		rol $42,x			rol 	esInt3+2,x
.17ba	38		sec				sec 								; calculate A-M saving result on the stack
.17bb	b5 2a		lda $2a,x			lda 	esInt0+2,x
.17bd	f5 29		sbc $29,x			sbc 	esInt0+1,x
.17bf	48		pha				pha
.17c0	b5 32		lda $32,x			lda 	esInt1+2,x
.17c2	f5 31		sbc $31,x			sbc 	esInt1+1,x
.17c4	48		pha				pha
.17c5	b5 3a		lda $3a,x			lda 	esInt2+2,x
.17c7	f5 39		sbc $39,x			sbc 	esInt2+1,x
.17c9	48		pha				pha
.17ca	b5 42		lda $42,x			lda 	esInt3+2,x
.17cc	f5 41		sbc $41,x			sbc 	esInt3+1,x
.17ce	90 10		bcc $17e0			bcc		_Int32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.17d0	95 42		sta $42,x			sta 	esInt3+2,x 					; write result back to A
.17d2	68		pla				pla
.17d3	95 3a		sta $3a,x			sta 	esInt2+2,x
.17d5	68		pla				pla
.17d6	95 32		sta $32,x			sta 	esInt1+2,x
.17d8	68		pla				pla
.17d9	95 2a		sta $2a,x			sta 	esInt0+2,x
.17db	f6 28		inc $28,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.17dd	4c e3 17	jmp $17e3			jmp 	_Int32Next 					; do the next iteration
.17e0					_Int32NoSubtract:
.17e0	68		pla				pla
.17e1	68		pla				pla
.17e2	68		pla				pla
.17e3					_Int32Next:
.17e3	88		dey				dey 								; do this 32 times.
.17e4	d0 c4		bne $17aa			bne 	_Int32UDLoop
.17e6	68		pla				pla 								; restore Y and exit
.17e7	a8		tay				tay
.17e8	60		rts				rts
.17e9					Int32Modulus:
.17e9	20 9f 17	jsr $179f			jsr 	Int32UDivide 				; do the division.
.17ec	b5 42		lda $42,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.17ee	95 40		sta $40,x			sta 	esInt3,x
.17f0	b5 3a		lda $3a,x			lda 	esInt2+2,x
.17f2	95 38		sta $38,x			sta 	esInt2,x
.17f4	b5 32		lda $32,x			lda 	esInt1+2,x
.17f6	95 30		sta $30,x			sta 	esInt1,x
.17f8	b5 2a		lda $2a,x			lda 	esInt0+2,x
.17fa	95 28		sta $28,x			sta 	esInt0,x
.17fc	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32fromstr.asm

.17fd					Int32FromString:
.17fd	85 03		sta $03				sta 	tempShort 					; save base
.17ff	98		tya				tya
.1800	48		pha				pha
.1801	a0 00		ldy #$00			ldy 	#0 							; set index into string being read
.1803	b1 04		lda ($04),y			lda 	(temp0),y 					; look at first character
.1805	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.1807	d0 01		bne $180a			bne 	_I32FSNotNegative
.1809	c8		iny				iny 								; if so consume it.
.180a					_I32FSNotNegative:
.180a	a5 03		lda $03				lda 	tempShort 					; get the base back.
.180c	c0 00		cpy #$00			cpy 	#0 							; if we read a -ve (e.g. Y != 0)
.180e	f0 02		beq $1812			beq 	_I32FSNN2
.1810	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.1812					_I32FSNN2:
.1812	48		pha				pha 								; save base + final sign on stack.
.1813	20 6c 19	jsr $196c			jsr 	Int32False 					; zero the return value.
.1816					I32FSMainLoop:
.1816	68		pla				pla 								; get the base back into tempshort
.1817	48		pha				pha
.1818	29 7f		and #$7f			and 	#$7F
.181a	85 03		sta $03				sta 	tempShort
.181c	b1 04		lda ($04),y			lda 	(temp0),y 					; look at next character.
.181e	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.1820	90 02		bcc $1824			bcc 	_I32FSNotLC
.1822	e9 20		sbc #$20			sbc 	#32
.1824					_I32FSNotLC:
.1824	38		sec				sec 								; subtract 48 (ASCII "0")
.1825	e9 30		sbc #$30			sbc 	#"0"
.1827	90 26		bcc $184f			bcc 	_I32FSDone 					; nothing more to do.
.1829	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.182b	90 06		bcc $1833			bcc 	_I32FSValidate
.182d	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.182f	90 1e		bcc $184f			bcc 	_I32FSDone
.1831	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.1833					_I32FSValidate:
.1833	c5 03		cmp $03				cmp 	tempShort 					; compare against the base.
.1835	b0 18		bcs $184f			bcs 	_I32FSDone 					; sorry, too large for this base.
.1837	48		pha				pha 								; save the new digit value.
.1838	e8		inx				inx 								; put base into next slot.
.1839	a5 03		lda $03				lda 	tempShort
.183b	20 7b 19	jsr $197b			jsr 	Int32Set8Bit
.183e	ca		dex				dex
.183f	20 91 18	jsr $1891			jsr 	Int32Multiply 				; multiply current by the base
.1842	e8		inx				inx
.1843	68		pla				pla  								; put additive into next slot
.1844	20 7b 19	jsr $197b			jsr 	Int32Set8Bit
.1847	ca		dex				dex
.1848	20 5d 18	jsr $185d			jsr 	Int32Add 					; and add it
.184b	c8		iny				iny 								; look at next character
.184c	4c 16 18	jmp $1816			jmp 	I32FSMainLoop 				; and go round again.
.184f					_I32FSDone:
.184f	68		pla				pla 								; get base/final sign back
.1850	10 04		bpl $1856			bpl 	_I32FSNN3
.1852	88		dey				dey 								; one fewer character to allow for the - prefix.
.1853	20 26 19	jsr $1926			jsr 	Int32Negate 				; negate the result.
.1856					_I32FSNN3:
.1856	84 03		sty $03				sty 	tempShort 					; save the count of characters read
.1858	68		pla				pla
.1859	a8		tay				tay
.185a	a5 03		lda $03				lda 	tempShort 					; get the count of characters read into A and exit
.185c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32math.asm

.185d					Int32Add:
.185d	18		clc				clc
.185e	b5 28		lda $28,x			lda 	esInt0,x
.1860	75 29		adc $29,x			adc 	esInt0+1,x
.1862	95 28		sta $28,x			sta 	esInt0,x
.1864	b5 30		lda $30,x			lda 	esInt1,x
.1866	75 31		adc $31,x			adc 	esInt1+1,x
.1868	95 30		sta $30,x			sta 	esInt1,x
.186a	b5 38		lda $38,x			lda 	esInt2,x
.186c	75 39		adc $39,x			adc 	esInt2+1,x
.186e	95 38		sta $38,x			sta 	esInt2,x
.1870	b5 40		lda $40,x			lda 	esInt3,x
.1872	75 41		adc $41,x			adc 	esInt3+1,x
.1874	95 40		sta $40,x			sta 	esInt3,x
.1876	60		rts				rts
.1877					Int32Sub:
.1877	38		sec				sec
.1878	b5 28		lda $28,x			lda 	esInt0,x
.187a	f5 29		sbc $29,x			sbc 	esInt0+1,x
.187c	95 28		sta $28,x			sta 	esInt0,x
.187e	b5 30		lda $30,x			lda 	esInt1,x
.1880	f5 31		sbc $31,x			sbc 	esInt1+1,x
.1882	95 30		sta $30,x			sta 	esInt1,x
.1884	b5 38		lda $38,x			lda 	esInt2,x
.1886	f5 39		sbc $39,x			sbc 	esInt2+1,x
.1888	95 38		sta $38,x			sta 	esInt2,x
.188a	b5 40		lda $40,x			lda 	esInt3,x
.188c	f5 41		sbc $41,x			sbc 	esInt3+1,x
.188e	95 40		sta $40,x			sta 	esInt3,x
.1890	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32multiply.asm

.1891					Int32Multiply:
.1891	e8		inx				inx 								; copy 2nd -> 3rd
.1892	20 b7 18	jsr $18b7			jsr 	Int32CopyUp
.1895	ca		dex				dex
.1896	20 b7 18	jsr $18b7			jsr 	Int32CopyUp 				; copy 1st -> 2nd
.1899	20 6c 19	jsr $196c			jsr 	Int32False 					; zero 1st.
.189c					_I32Loop:
.189c	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.189e	29 01		and #$01			and 	#1
.18a0	f0 03		beq $18a5			beq 	_I32NoAdd 					; if set
.18a2	20 5d 18	jsr $185d			jsr 	Int32Add 					; add 2nd to 1st.
.18a5					_I32NoAdd:
.18a5	e8		inx				inx 								; shift 2nd left
.18a6	20 81 19	jsr $1981			jsr 	Int32ShiftLeft
.18a9	e8		inx				inx  								; shift 3rd right
.18aa	20 8a 19	jsr $198a			jsr 	Int32ShiftRight
.18ad	20 93 19	jsr $1993			jsr 	Int32Zero 					; check if zero.
.18b0	08		php				php 								; save status bits
.18b1	ca		dex				dex 	 							; point back to 1st
.18b2	ca		dex				dex
.18b3	28		plp				plp 								; get status bits
.18b4	d0 e6		bne $189c			bne 	_I32Loop 					; if non-zero keep going.
.18b6	60		rts				rts
.18b7					Int32CopyUp:
.18b7	b5 28		lda $28,x			lda 	esInt0,x
.18b9	95 29		sta $29,x			sta 	esInt0+1,x
.18bb	b5 30		lda $30,x			lda 	esInt1,x
.18bd	95 31		sta $31,x			sta 	esInt1+1,x
.18bf	b5 38		lda $38,x			lda 	esInt2,x
.18c1	95 39		sta $39,x			sta 	esInt2+1,x
.18c3	b5 40		lda $40,x			lda 	esInt3,x
.18c5	95 41		sta $41,x			sta 	esInt3+1,x
.18c7	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32tostr.asm

.18c8					Int32ToString:
.18c8	48		pha				pha 								; save base
.18c9	85 03		sta $03				sta 	tempShort 					; save target base.
.18cb	a9 00		lda #$00			lda 	#0
.18cd	8d a4 08	sta $08a4			sta 	IToSCount 					; clear character count.
.18d0	98		tya				tya
.18d1	48		pha				pha
.18d2	a5 03		lda $03				lda 	tempShort 					; check if we are signed conversion
.18d4	10 10		bpl $18e6			bpl 	_I32TSUnsigned
.18d6	48		pha				pha 								; save base on stack.
.18d7	b5 40		lda $40,x			lda 	esInt3,x 					; is it actually negative
.18d9	10 08		bpl $18e3			bpl 	_I32TSNoFlip
.18db	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.18dd	20 12 19	jsr $1912			jsr 	I32WriteCharacter
.18e0	20 26 19	jsr $1926			jsr 	Int32Negate 				; negate the value.
.18e3					_I32TSNoFlip:
.18e3	68		pla				pla 								; get the base back
.18e4	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.18e6					_I32TSUnsigned:
.18e6	20 ed 18	jsr $18ed			jsr 	I32DivideWrite 				; recursive code to output string.
.18e9	68		pla				pla
.18ea	a8		tay				tay
.18eb	68		pla				pla
.18ec	60		rts				rts
.18ed					I32DivideWrite:
.18ed	48		pha				pha 								; save the divisor/base
.18ee	e8		inx				inx 								; write in the dividing position.
.18ef	20 7b 19	jsr $197b			jsr 	Int32Set8Bit
.18f2	ca		dex				dex
.18f3	20 9f 17	jsr $179f			jsr 	Int32UDivide 				; divide number by base.
.18f6	68		pla				pla 								; get the base into Y
.18f7	a8		tay				tay
.18f8	b5 2a		lda $2a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.18fa	48		pha				pha
.18fb	20 93 19	jsr $1993			jsr 	Int32Zero 					; is the result zero ?
.18fe	f0 04		beq $1904			beq 	_I32NoRecurse 				; if so, don't recurse.
.1900	98		tya				tya 								; put base into A
.1901	20 ed 18	jsr $18ed			jsr 	I32DivideWrite 				; and jsr the dividor recursively.
.1904					_I32NoRecurse:
.1904	68		pla				pla 								; get the remainder back
.1905	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.1907	90 02		bcc $190b			bcc 	_I32NotHex
.1909	69 06		adc #$06			adc 	#7-1
.190b					_I32NotHex:
.190b	18		clc				clc 								; make it ASCII
.190c	69 30		adc #$30			adc 	#48
.190e	20 12 19	jsr $1912			jsr 	I32WriteCharacter 			; write the character out
.1911	60		rts				rts 								; and exit.
.1912					I32WriteCharacter:
.1912	ac a4 08	ldy $08a4			ldy 	IToSCount 					; get position
.1915	91 04		sta ($04),y			sta 	(temp0),y 					; write out with trailing 0
.1917	c8		iny				iny
.1918	a9 00		lda #$00			lda 	#0
.191a	91 04		sta ($04),y			sta 	(temp0),y
.191c	ee a4 08	inc $08a4			inc 	IToSCount 					; bump count
.191f	60		rts				rts
.1920	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: common/math/int32unary.asm

.1921					Int32Absolute:
.1921	b5 40		lda $40,x			lda 	esInt3,x 					; use negate code if -ve.
.1923	30 01		bmi $1926			bmi 	Int32Negate
.1925	60		rts				rts
.1926					Int32Negate:
.1926	38		sec				sec
.1927	a9 00		lda #$00			lda 	#0
.1929	f5 28		sbc $28,x			sbc 	esInt0,x
.192b	95 28		sta $28,x			sta 	esInt0,x
.192d	a9 00		lda #$00			lda 	#0
.192f	f5 30		sbc $30,x			sbc 	esInt1,x
.1931	95 30		sta $30,x			sta 	esInt1,x
.1933	a9 00		lda #$00			lda 	#0
.1935	f5 38		sbc $38,x			sbc 	esInt2,x
.1937	95 38		sta $38,x			sta 	esInt2,x
.1939	a9 00		lda #$00			lda 	#0
.193b	f5 40		sbc $40,x			sbc 	esInt3,x
.193d	95 40		sta $40,x			sta 	esInt3,x
.193f	60		rts				rts
.1940					Int32Not:
.1940	b5 28		lda $28,x			lda 	esInt0,x
.1942	49 ff		eor #$ff			eor 	#$FF
.1944	95 28		sta $28,x			sta 	esInt0,x
.1946	b5 30		lda $30,x			lda 	esInt1,x
.1948	49 ff		eor #$ff			eor 	#$FF
.194a	95 30		sta $30,x			sta 	esInt1,x
.194c	b5 38		lda $38,x			lda 	esInt2,x
.194e	49 ff		eor #$ff			eor 	#$FF
.1950	95 38		sta $38,x			sta 	esInt2,x
.1952	b5 40		lda $40,x			lda 	esInt3,x
.1954	49 ff		eor #$ff			eor 	#$FF
.1956	95 40		sta $40,x			sta 	esInt3,x
.1958	60		rts				rts
.1959					Int32Sign:
.1959	b5 40		lda $40,x			lda 	esInt3,x					; look at MSB
.195b	30 0b		bmi $1968			bmi 	Int32True 					; if set return -1 (true)
.195d	20 93 19	jsr $1993			jsr 	Int32Zero 					; is it zero ?
.1960	f0 0a		beq $196c			beq 	Int32False 					; if zero return 0 (false)
.1962	20 6c 19	jsr $196c			jsr 	Int32False 					; > 0 return 1
.1965	f6 28		inc $28,x			inc 	esInt0,x
.1967	60		rts				rts
.1968					Int32True:
.1968	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.196a	d0 02		bne $196e			bne 	Int32WriteAll
.196c					Int32False:
.196c	a9 00		lda #$00			lda 	#0
.196e					Int32WriteAll:
.196e	95 28		sta $28,x			sta 	esInt0,x
.1970					Int32Write123:
.1970	95 30		sta $30,x			sta 	esInt1,x
.1972	95 38		sta $38,x			sta 	esInt2,x
.1974	95 40		sta $40,x			sta 	esInt3,x
.1976	a9 00		lda #$00			lda 	#$00						; and make it an integer
.1978	95 20		sta $20,x			sta 	esType,x
.197a	60		rts				rts
.197b					Int32Set8Bit:
.197b	95 28		sta $28,x			sta 	esInt0,x
.197d	a9 00		lda #$00			lda 	#0
.197f	f0 ef		beq $1970			beq		Int32Write123
.1981					Int32ShiftLeft:
.1981	16 28		asl $28,x			asl 	esInt0,x
.1983	36 30		rol $30,x			rol	 	esInt1,x
.1985	36 38		rol $38,x			rol	 	esInt2,x
.1987	36 40		rol $40,x			rol	 	esInt3,x
.1989	60		rts				rts
.198a					Int32ShiftRight:
.198a	56 40		lsr $40,x			lsr 	esInt3,x
.198c	76 38		ror $38,x			ror 	esInt2,x
.198e	76 30		ror $30,x			ror 	esInt1,x
.1990	76 28		ror $28,x			ror 	esInt0,x
.1992	60		rts				rts
.1993					Int32Zero:
.1993	b5 28		lda $28,x			lda 	esInt0,x
.1995	15 30		ora $30,x			ora 	esInt1,x
.1997	15 38		ora $38,x			ora 	esInt2,x
.1999	15 40		ora $40,x			ora 	esInt3,x
.199b	60		rts				rts
.199c					Int32Random:
.199c	98		tya				tya
.199d	48		pha				pha
.199e	a0 07		ldy #$07			ldy 	#7
.19a0	ad 88 08	lda $0888			lda 	Seed32+0
.19a3	d0 03		bne $19a8			bne 	_Random1
.19a5	a8		tay				tay
.19a6	a9 aa		lda #$aa			lda		#$AA
.19a8					_Random1:
.19a8	0a		asl a				asl 	a
.19a9	2e 89 08	rol $0889			rol 	Seed32+1
.19ac	2e 8a 08	rol $088a			rol 	Seed32+2
.19af	2e 8b 08	rol $088b			rol 	Seed32+3
.19b2	90 02		bcc $19b6			bcc 	_Random2
.19b4	49 c5		eor #$c5			eor 	#$C5
.19b6					_Random2:
.19b6	88		dey				dey
.19b7	d0 ef		bne $19a8			bne 	_Random1
.19b9	8d 88 08	sta $0888			sta 	Seed32+0
.19bc	95 28		sta $28,x			sta 	esInt0,x
.19be	ad 89 08	lda $0889			lda 	Seed32+1
.19c1	95 30		sta $30,x			sta 	esInt1,x
.19c3	ad 8a 08	lda $088a			lda 	Seed32+2
.19c6	95 38		sta $38,x			sta 	esInt2,x
.19c8	ad 8b 08	lda $088b			lda 	Seed32+3
.19cb	95 40		sta $40,x			sta 	esInt3,x
.19cd	68		pla				pla
.19ce	a8		tay				tay
.19cf	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: testing/simple/01testing.asm

.19d0					TestProgram:
.19d0	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.19d2	85 00		sta $00				sta 	codePtr
.19d4	a9 1a		lda #$1a			lda 	#(BasicProgram) >> 8
.19d6	85 01		sta $01				sta 	1+(codePtr)
.19d8	a0 00		ldy #$00			ldy 	#0
.19da	a2 01		ldx #$01			ldx 	#1
.19dc	20 7e 12	jsr $127e			jsr 	EvaluateTOS
>19df	db						.byte 	$DB
>19e0	db						.byte 	$DB
.19e1	4c e1 19	jmp $19e1	w1:		jmp 	w1

;******  Return to file: basic.asm


;******  Processing file: testing/simple/02testcode.asm

>19e4						.align 256
.1a00					BasicProgram:
>1a00	99 8b 75 8b 71 80			.byte $99,$8b,$75,$8b,$71,$80

;******  Return to file: basic.asm


;******  End of listing
